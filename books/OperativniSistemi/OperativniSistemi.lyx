#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass mwbk
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language serbian-latin
\language_package default
\inputencoding auto
\fontencoding global
\font_roman utopia
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\boxbgcolor #c8c8c8
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.75cm
\topmargin 5.1cm
\rightmargin 3.75cm
\bottommargin 5.1cm
\secnumdepth 2
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\bullet 0 0 17 -1
\bullet 1 0 9 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begingroup
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
vspace*{0.14
\backslash
textheight} 
\end_layout

\begin_layout Plain Layout

{
\backslash
LARGE RANKO POPOVIĆ}
\backslash

\backslash
[1.5
\backslash
baselineskip] 
\end_layout

\begin_layout Plain Layout

{
\backslash
LARGE IRINA BRANOVIĆ}
\backslash

\backslash
[1.5
\backslash
baselineskip]
\end_layout

\begin_layout Plain Layout

{
\backslash
LARGE MARKO ŠARAC}
\backslash

\backslash
[2
\backslash
baselineskip]
\end_layout

\begin_layout Plain Layout

{
\backslash
Huge
\backslash
bf OPERATIVNI SISTEMI}
\backslash

\backslash
[2
\backslash
baselineskip] 
\end_layout

\begin_layout Plain Layout


\backslash
vspace*{0.4
\backslash
textheight}
\end_layout

\begin_layout Plain Layout


\backslash
rule{0.6
\backslash
textwidth}{0.4pt}
\backslash

\backslash
[1
\backslash
baselineskip] 
\end_layout

\begin_layout Plain Layout

{
\backslash
LARGE
\backslash
sffamily UNIVERZITET SINGIDUNUM}
\backslash

\backslash
[
\backslash
baselineskip] 
\end_layout

\begin_layout Plain Layout

{
\backslash
LARGE Beograd, 2011}
\backslash
par
\end_layout

\begin_layout Plain Layout


\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OPERATIVNI SISTEMI
\end_layout

\begin_layout Standard
prvo izdanje
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Autori:
\end_layout

\begin_layout Standard
Prof.
 dr Ranko Popović
\end_layout

\begin_layout Standard
Doc.
 dr Irina Branović
\end_layout

\begin_layout Standard
Marko Šarac
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Recenzenti:
\end_layout

\begin_layout Standard
Prof.
 dr Dejan Živković
\end_layout

\begin_layout Standard
Prof.
 dr Boško Nikolić
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Izdavač:
\end_layout

\begin_layout Standard
UNIVERZITET SINGIDUNUM
\end_layout

\begin_layout Standard
Danijelova 32, Beograd
\end_layout

\begin_layout Standard
www.singidunum.ac.rs
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Za izdavača:
\end_layout

\begin_layout Standard
Prof.
 dr Milovan Stanišić
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Tehnička obrada:
\end_layout

\begin_layout Standard
Irina Branović
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Dizajn korica:
\end_layout

\begin_layout Standard
Ime Prezime
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Godina izdanja:
\end_layout

\begin_layout Standard
2011
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Tiraž:
\end_layout

\begin_layout Standard
??? primeraka
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Štampa:
\end_layout

\begin_layout Standard
Mladost Grup
\end_layout

\begin_layout Standard
Loznica
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
ISBN:
\end_layout

\begin_layout Standard
\paragraph_spacing single
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter*
Predgovor
\end_layout

\begin_layout Standard
Sadržaj ove knjige prilagođen je nastavnom planu i programu istoimenog predmeta
 na Fakultetu za Informatiku i Računarstvo Univerziteta Singidunum u Beogradu.
 Autori se nadaju da će knjiga poslužiti i svima onima koji žele da steknu
 osnovna znanja o operativnim sistemima.
 
\end_layout

\begin_layout Standard
U skladu sa nastavnim planom predmeta, knjiga je podeljena u tri dela.
 Prvi deo objašnjava osnovne pojmove i principe projektovanja savremenih
 operativnih sistema.
 U drugom delu detaljno je opisana implementacija jezgra operativnog sistema
 Linux, dok treći deo na primerima virtuelnih mašina i različitih operativnih
 sistema ilustruje teorijske principe objašnjene u knjizi.
\end_layout

\begin_layout Standard
Čitaocima koji nisu upoznati sa osnovama jezika C namenjen je dodatak u
 kome će pronaći osnove ovog programskog jezika čije je poznavanje neophodno
 da bi se upućenost u operativne sisteme mogla nazvati kompletnom.
\end_layout

\begin_layout Standard
Zahvaljujemo svima čije su preporuke doprinele da ova knjiga bude bolja,
 a posebno studentima.
 
\end_layout

\begin_layout Standard
Sve primedbe, komentari i pohvale mogu se uputiti na adresu 
\family typewriter

\begin_inset Newline newline
\end_inset

rpopovic@singidunum.ac.rs
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Operativni sistemi
\end_layout

\begin_layout Chapter
Kako radi računar?
\end_layout

\begin_layout Section
Osnovne komponente računarskog sistema
\end_layout

\begin_layout Standard
Računarski sistem može se grubo podeliti u dva dela: hardver
\begin_inset Index idx
status open

\begin_layout Plain Layout
hardver
\end_layout

\end_inset

 i softver.
\end_layout

\begin_layout Standard
Hardver, čiji su najvažniji sastavni delovi procesor, memorija, magistrala
 i ulazno izlazni uređaji, obezbeđuje osnovne resurse za funkcionisanje
 sistema.
 Pod softverom se obično podrazumevaju operativni sistem (poznat i kao sistemski
 softver) i aplikativni softver.
 Operativni sistem upravlja hardverom i koordinira njegovo deljenje između
 različitih aplikacija i korisnika.
 Aplikativni programi
\series bold
 
\series default
(npr.
 softver za obradu teksta, tabelarna izračunavanja, kompajleri, Web čitači)
 rešavaju probleme korisnika.
 Hardver i softver su logički ekvivalentni; bilo koja operacija koju izvodi
 softver može se ugraditi direktno u hadrver.
 Takođe, svaka instrukcija koju izvršava hardver može se simulirati u softveru.
 Presudni faktori za odlučivanje koje će se funkcije implementirati hardverski,
 a koje softverski jesu cena, brzina, pouzdanost i brzina promene okruženja.
\end_layout

\begin_layout Section
Arhitektura računarskog sistema
\end_layout

\begin_layout Standard
Savremen računarski sistem opšte namene sastoji se od jednog ili više procesora,
 brojnih ulazno-izlaznih uređaja (periferija) povezanih na zajedničku magistralu
\begin_inset Index idx
status open

\begin_layout Plain Layout
magistrala
\end_layout

\end_inset

 (bus) koja vodi do memorije (Slika 1.1).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika1.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 1.1: Moderan računarski sistem.
\end_layout

\begin_layout Section
Procesor
\end_layout

\begin_layout Standard
Za procesor
\begin_inset Index idx
status open

\begin_layout Plain Layout
procesor
\end_layout

\end_inset

 ili CPU (Central Processing Unit) se obično kaže da je mozak sistema, jer
 je njegova funkcija da izvršava programe koji se nalaze u radnoj memoriji
 računara.
 Procesor dohvata instrukcije iz memorije, ispituje ih i zatim redom izvršava.
 CPU se sastoji iz nekoliko delova.
 
\series bold
Kontrolna jedinica
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
kontrolna jedinica procesora
\end_layout

\end_inset

 (control unit) dohvata instrukcije iz memorije i određuje kog su tipa.
 
\series bold
Aritmetičko-logička jedinica
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
aritmetičko-logička jedinica procesora
\end_layout

\end_inset

 (ALU, Arithmetic and Logical Unit) izvršava operacije poput sabiranja i
 logičke konjukcije.
 Procesor ima i malo memorije koja je veoma brza, a služi da se u njoj čuvaju
 privremeni rezultati i kontrolne informacije.
 Tu memoriju čini nekoliko 
\series bold
registara
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
registri
\end_layout

\end_inset

, od kojih svaki ima svoju namenu.
 Registri se mogu podeliti u dve grupe: one koji su vidiljivi za korisnika,
 i kontrolno-statusne registre.
 U prvu grupu spadaju programski brojač i registar instrukcija.
 Najvažniji registar je 
\series bold
programski brojač
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
programski brojač
\end_layout

\end_inset

 (program counter, PC) koji ukazuje na sledeću instrukciju koja treba da
 se izvrši.
 
\series bold
Registar instrukcija
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
registar instrukcija
\end_layout

\end_inset

 (instruction register, IR) sadrži instrukciju koja se trenutno izvršava.
 U grupu registara koji su vidljivi korisnicima spadaju registri podataka
 koji čuvaju međurezultate izračunavanja, kao i adresni registri u koje
 se smeštaju adrese i podaci iz radne memorije.
 Primer adresnog registra je pokazivač steka
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivač steka
\end_layout

\end_inset

 (stack pointer); detalje o steku potražite u odeljku 1.4.1.
 
\end_layout

\begin_layout Standard
Procesor izvršava svaku instrukciju u nizu malih koraka:
\end_layout

\begin_layout Enumerate
Instrukcija se dohvata iz memorije i smešta u registar instrukcija.
\end_layout

\begin_layout Enumerate
Programski brojač se menja tako da ukazuje na sledeću instrukciju.
\end_layout

\begin_layout Enumerate
Određuje se tip instrukcije koja je upravo dohvaćena.
\end_layout

\begin_layout Enumerate
Ako su instrukciji potrebni podaci iz memorije, određuje se gde se oni nalaze.
\end_layout

\begin_layout Enumerate
Ako su potrebni podaci, oni se dohvataju iz radne memorije i smeštaju u
 registre procesora.
\end_layout

\begin_layout Enumerate
Instrukcija se izvršava.
\end_layout

\begin_layout Enumerate
Rezultati se smeštaju na odgovarajuće mesto.
\end_layout

\begin_layout Enumerate
Izvršavanje sledeće instrukcije počinje od tačke 1.
\end_layout

\begin_layout Standard
Rani računari imali su samo jedan procesor koji je izvršavao instrukcije
 jednu po jednu; noviji računari imaju više nezavisnih procesora koji dele
 zajedničku radnu memoriju.
 Ovakav pristup zove se 
\series bold
multiprocesiranje
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
multiprocesiranje
\end_layout

\end_inset

 i omogućuje istovremeno izvršavanje nekoliko instrukcija.
\end_layout

\begin_layout Standard
Takođe, moderni procesori u izvršavanju instrukcija primenjuju tzv.
 
\series bold
pajplajn
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pajplajn
\end_layout

\end_inset

 (pipeline).
 U ovom pristupu za svaki od prethodno pomenutih koraka u izvršavanju instrukcij
a (tj.
 prenošenje u registar instrukcija, određivanje tipa instrukcije itd.) postoji
 posebna jedinica koja ga izvršava.
 Kada se računar pokrene, prva jedinica dohvata prvu instrukciju, druga
 počinje da je tumači (dekodira), a za to vreme je prva jedinica već zauzeta
 dohvatanjem sledeće instrukcije.
 Nešto kasnije, dok je treća jedinica zaposlena ispitivanjem da li početnoj
 instrukciji trebaju podaci iz memorije, druga jedinica dekoduje drugu instrukci
ju, a prva jedinica već dohvata treću instrukciju iz memorije.
 Pajplajn procesori se mogu uporediti sa proizvodnom trakom; dok proizvodi
 na početku linije nisu još ni sastavljeni, oni na kraju su skoro završeni.
\end_layout

\begin_layout Section
Memorija
\end_layout

\begin_layout Standard
Programi koje računar izvršava moraju da se nalaze u glavnoj memoriji (RAM
\begin_inset Index idx
status open

\begin_layout Plain Layout
RAM
\end_layout

\end_inset

 ili random access memory).
 Radna memorija
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!glavna
\end_layout

\end_inset

 je jedini veliki prostor za smeštanje podataka kome procesor može direktno
 da pristupa.
 
\end_layout

\begin_layout Standard
Memorije su obično implementirane u poluprovodničkoj DRAM
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!DRAM
\end_layout

\end_inset

 (dynamic RAM) tehnologiji sa nizom memorijskih reči
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!reči
\end_layout

\end_inset

 (lokacija), tako da svaka lokacija ima svoju adresu.
 Ako memorija ima 
\family typewriter
n
\family default
 lokacija, one će imati adrese od 
\family typewriter
0
\family default
 do 
\family typewriter
n-1
\family default
.
 Sve memorijske lokacije sadrže isti broj bitova.
 Ako lokacija ima 
\family typewriter
k
\family default
 bitova, ona može da sadrži neku od 
\family typewriter
2
\begin_inset script superscript

\begin_layout Plain Layout

\family typewriter
k
\end_layout

\end_inset


\family default
 mogućih kombinacija podataka.
 Interakcija sa memorijom obavlja se pomoću niza naredbi 
\family typewriter
load
\family default
 i 
\family typewriter
store
\family default
.
 Naredba 
\family typewriter
load
\family default
 prenosi reč iz glavne memorije u interni registar procesora, dok naredba
 
\family typewriter
store
\family default
 prenosi sadržaj iz registra u zadatu lokaciju glavne memorije.
 Osim eksplicitnih čitanja i pisanja u glavnu memoriju, procesor takođe
 automatski iz memorije čita naredbe koje treba da se izvrše.
 Procesor komunicira sa radnom memorijom preko dva registra: adresnog registra
 memorije
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!adresni registar (MAR)
\end_layout

\end_inset

 (MAR, Memory Address Register) i registra za memorijske podatke
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!registar podataka (MDR)
\end_layout

\end_inset

 (MDR, Memory Data Register).
\end_layout

\begin_layout Standard
Idealno bi bilo kada bi se naredbe za izvršavanje i podaci za programe stalno
 nalazili u glavnoj memoriji, ali to nije moguće iz dva razloga: prvo, glavna
 memorija je premala da bi u nju stalo sve što je potrebno, i drugo, ona
 gubi sadržaj čim se isključi napajanje.
 Zbog toga većina računarskih sistema ima i sekundarne
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!sekundarna
\end_layout

\end_inset

 sisteme za čuvanje podataka (secondary storage) koji služe kao 
\begin_inset Quotes eld
\end_inset

produžetak
\begin_inset Quotes erd
\end_inset

 glavne memorije.
 Najčešće se kao uređaj za sekundarnu memoriju koristi magnetni disk
\begin_inset Index idx
status open

\begin_layout Plain Layout
magnetni disk
\end_layout

\end_inset

, koji čuva i programe i podatke.
 Većina programa (čitači Weba, kompajleri, programi za obradu teksta i tabelarna
 izračunavanja) čuvaju se na disku do trenutka dok se ne učitaju u glavnu
 memoriju.
 
\end_layout

\begin_layout Standard
U opštem slučaju, međutim, strukture za čuvanje podataka koje smo do sada
 pomenuli (registri, glavna memorija i magnetni disk) čine samo deo sistema
 za čuvanje podataka.
 Njemu pripadaju i keš memorija, kompakt diskovi, magnetne trake itd.
 Osnovni zadatak svih sistema za čuvanje podataka jeste da te podatke čuvaju
 sve dok oni sledeći put ne zatrebaju.
 Najvažnije razlike između memorija su u brzini, ceni, kapacitetu i trajnosti
 podataka.
 Različiti sistemi za čuvanje podataka u računarskom sistemu mogu se organizovat
i u hijerarhiju
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!hijerarhija
\end_layout

\end_inset

 (Slika 1.2).
 Memorije na višem nivou su skuplje, ali i brže; kako se spuštamo niže,
 cena po bitu pada, a vreme pristupa raste.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Hijerarhija.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 1.2: Hijerarhija uređaja za čuvanje podataka.
\end_layout

\begin_layout Subsection
Stek
\end_layout

\begin_layout Standard
Stek
\begin_inset Index idx
status open

\begin_layout Plain Layout
stek
\end_layout

\end_inset

 (stack) je skup sekvencijalnih lokacija u radnoj memoriji koji liči na
 hrpu papira; na nju se dodaju papiri sa vrha i odatle se i skidaju.
 U svakom trenutku može se pristupati samo jednoj lokaciji koja se nalazi
 na vrhu steka; zbog toga se ova struktura zove i LIFO (last-in, first-out).
 
\end_layout

\begin_layout Standard
Stek se implementira tako što se u memoriji odvaja kontinualan skup lokacija
 u kojima će se čuvati sadržaj steka.
 Obično je popunjen samo deo tih lokacija, a ostatak steka se popunjava
 kako on raste.
 U radu sa stekom potrebno je znati tri adrese, koje se obično čuvaju u
 registrima procesora:
\end_layout

\begin_layout Itemize
Pokazivač steka: sadrži adresu vrha steka; njegove vrednosti se menjaju
 (inkrementiraju/dekrementiraju) naredbama
\family typewriter
 push
\family default
 (stavljanje na stek) i 
\family typewriter
pop
\family default
 (skidanje sa steka).
\end_layout

\begin_layout Itemize
Osnova steka (stack base): sadrži adresu najniže lokacije u rezervisanom
 bloku, koja služi i kao prva lokacija za smeštanje elementa u prazan stek.
 Ako se operacija 
\family typewriter
pop
\family default
 primeni na prazan stek, prijavljuje se greška.
\end_layout

\begin_layout Itemize
Granica steka (stack limit): sadrži adresu drugog kraja, odnosno vrha rezervisan
og bloka.
 Ako se operacija 
\family typewriter
push
\family default
 primeni na pun stek, prijavljuje se greška.
\end_layout

\begin_layout Standard
Na većini današnjih mašina stek 
\begin_inset Quotes eld
\end_inset

raste
\begin_inset Quotes erd
\end_inset

 od viših ka nižim memorijskim adresama, tj.
 adresa osnove steka ima višu vrednost od adrese vrha steka (Slika 1.3).
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/memorijaStek.PNG
	scale 65

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 1.3: Radna memorija i stek.
\end_layout

\begin_layout Subsection
Keš memorije
\end_layout

\begin_layout Standard
U svim fazama izvršavanja instrukcija, procesor pristupa memoriji barem
 jednom, da bi dohvatio instrukciju, a zatim i da bi dobio podatke i(li)
 sačuvao rezultate.
 Pošto procesor radi sa taktom koji je kraći od vremena pristupa memoriji,
 brzina izvršavanja instrukcije direktno zavisi od vremena pristupa memoriji.
 Kada bi radna memorija mogla da bude proizvedena u istoj tehnologiji kao
 procesorski registri, tada bi pomenuta vremena bila približno ista, ali
 je to nažalost preskupo.
 Zbog toga se između procesora i radne memorije dodaje malo brze memorije
 koja se zove 
\series bold
keš memorija
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!keš
\end_layout

\end_inset

 (cache).
 Keš memorija sadrži kopiju malog dela sadržaja radne memorije; kada procesor
 zatraži čitanje bajta sadržaja iz memorije, prvo se proverava da li je
 taj sadržaj već u keš memoriji, i ako jeste, šalje se procesoru.
 Ako nije, onda se blok bajtova, tj.
 određen fiksni broj bajtova iz glavne memorije učitava u keš memoriju,
 a traženi bajt se šalje procesoru.
 To se radi zato što se najčešće dešava da kada je određeni podatak potreban
 procesoru, velika je verovatnoća da će mu zatrebati i neki podatak iz neposredn
e blizine (tzv.
 princip lokaliteta referenci
\begin_inset Index idx
status open

\begin_layout Plain Layout
lokalitet referenci
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Prilikom projektovanja keš memorije mora se voditi računa o sledećim parametrima
:
\end_layout

\begin_layout Itemize
kapacitet keš memorije
\end_layout

\begin_layout Itemize
veličina bloka
\end_layout

\begin_layout Itemize
funkcija za mapiranje
\end_layout

\begin_layout Itemize
algoritam zamene
\end_layout

\begin_layout Itemize
tehnika upisa u radnu memoriju
\end_layout

\begin_layout Standard
Čak i vrlo mala keš memorija može primetno da poboljša performanse sistema.
 Kada je reč o veličini bloka, praktične primene su pokazale sa porastom
 bloka, broj "pogodaka
\begin_inset Quotes erd
\end_inset

 (tj.
 broj podataka koji su upisani u keš a procesor ih je zatražio) na početku
 raste, ali kada se pređe optimalna veličina bloka, broj 
\begin_inset Quotes eld
\end_inset

pogodaka
\begin_inset Quotes erd
\end_inset

 počinje da opada.
 Verovatnoća da će procesor zatražiti novoupisane podatke je manja od verovatnoć
e da će zatražiti već korišćene podatke koji moraju da se izbace iz keš
 memorije da bi se upisali novi blokovi podataka.
\end_layout

\begin_layout Standard
Kada se u keš memoriju upiše novi blok, funkcija za mapiranje (preslikavanje)
 određuje koja će mu lokacija u keš memoriji biti dodeljena; to mora da
 se obavi tako da se minimizira verovatnoća da će biti zamenjen blok koji
 će procesoru zatrebati u skorije vreme.
 
\end_layout

\begin_layout Standard
Algoritam zamene u funkciji za mapiranje određuje koji će blok biti zamenjen
 novim blokom iz memorije kada u keš memoriji više nema mesta za upis novih
 blokova.
 Obično se koristi tehnika LRU
\begin_inset Index idx
status open

\begin_layout Plain Layout
LRU
\end_layout

\end_inset

 (least recently used), odnosno zamenjuju se blokovi koji su najduže u keš
 memoriji a da ih procesor nije zatražio.
 
\end_layout

\begin_layout Standard
Ako procesor promeni sadržaj bloka, on se mora upisati u radnu memoriju
 pre nego što se zameni drugim blokom.
 Tehnika upisa diktira da li će se to raditi prilikom svakog ažuriranja
 blokova, ili samo kada se blok zamenjuje.
 I u ovom slučaju mora se naći kompromis između efikasnosti i problema sinhroniz
acije podataka.
\end_layout

\begin_layout Section
Ulazno-izlazni uređaji (periferije)
\end_layout

\begin_layout Standard
Već smo pomenuli da računarski sistem čine procesor i brojni kontroleri
 uređaja koje povezuje zajednička magistrala za podatke.
 Svaki kontroler je zadužen za različitu vrstu uređaja.
 Jedan kontroler može da upravlja i sa nekoliko uređaja; takav je na primer,
 SCSI 
\begin_inset Index idx
status open

\begin_layout Plain Layout
SCSI 
\end_layout

\end_inset

(small computer systems interface) kontroler.
 Zadatak kontrolera je da prenese podatke između periferijskih uređaja koje
 kontroliše i lokalnog bafera.
 Operativni sistem obično ima 
\series bold
upravljački program
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
upravljački program
\end_layout

\end_inset

 (drajver
\begin_inset Index idx
status open

\begin_layout Plain Layout
drajver
\end_layout

\end_inset

) za svaki kontroler koji predstavlja uniformni interfejs uređaja ka ostatku
 operativnog sistema.
\end_layout

\begin_layout Standard
Umesto da procesor besposleno čeka dok se ne obavi neka U/I operacija, koristi
 se tehnika prekida (interrupt).
 Kada se desi neki događaj, npr.
 U/I uređaj završi operaciju koju je obavljao, to se obično signalizira
 
\series bold
prekid
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
prekid
\end_layout

\end_inset


\series bold
om
\series default
 koji stiže od hardvera ili iz softvera.
 Hardver može da izazove prekid u bilo kom trenutku tako što će poslati
 signal procesoru, obično preko sistemske magistrale.
 Softver može da izazove prekid izvršavanjem specijalne operacije koja se
 zove 
\series bold
sistemski poziv
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski poziv
\end_layout

\end_inset

 (system call ili monitor call).
\end_layout

\begin_layout Standard
Kada se procesor 
\begin_inset Quotes eld
\end_inset

prekine
\begin_inset Quotes erd
\end_inset

, on prestaje da radi ono što je do tada radio i odmah prelazi na izvršavanje
 prekidne rutine koja se nalazi na fiksnoj lokaciji u memoriji.
 Ta lokacija po pravilu sadrži početnu adresu servisne procedure za prekid.
 Kada se završi izvršavanje servisne procedure, tj.
 obavi se tzv.
 obrada prekida
\begin_inset Index idx
status open

\begin_layout Plain Layout
prekid!obrada
\end_layout

\end_inset

, procesor nastavlja rad tamo gde ga je prekinuo.
 
\end_layout

\begin_layout Standard
Da bi počela U/I operacija, upravljački program u odgovarajuće registre
 kontrolera šalje podatke.
 Kontroler zatim ispituje sadržaj svojih registara da bi odlučio šta da
 preduzme (npr.
 da učita znak sa tastature).
 Kontroler započinje prenos podataka iz uređaja u svoj bafer; kada se prenos
 završi, obaveštava upravljački program putem prekida da je završio sa radom.
 Upravljački program zatim vraća kontrolu operativnom sistemu, kome istovremeno
 šalje i pokazivač na učitane podatke.
\end_layout

\begin_layout Standard
Ovakva vrsta ulaza-izlaza kojim se upravlja pomoću prekida je podesna kada
 se prenosi mala količina podataka, ali nije pogodna za prenos velike količine
 podataka, npr.
 sa diska.
 Taj problem se rešava direktnim pristupom memoriji (DMA
\begin_inset Index idx
status open

\begin_layout Plain Layout
DMA
\end_layout

\end_inset

, direct memory access).
 Nakon postavljanja bafera, pokazivača i brojača za U/I uređaj, kontroler
 prenosi blokove podataka direktno iz svog bafera u memoriju (ili obratno),
 bez intervencije procesora.
 Generiše se samo jedan prekid po bloku, da bi se upravljački program obavestio
 da je operacija završena, umesto jednog prekida po bajtu koji se generiše
 pri radu sa sporim uređajima.
 Dok kontroler uređaja obavlja te operacije, procesor je slobodan za druge
 poslove.
\end_layout

\begin_layout Section
Organizacija računara
\end_layout

\begin_layout Standard
Računarski sistem može da bude organizovan na različite načine, u zavisnosti
 od broja procesora koje koristi.
 
\end_layout

\begin_layout Subsection
Jednoprocesorski sistemi
\end_layout

\begin_layout Standard
Većina sistema ima samo jedan procesor.
 Međutim, jednoprocesorski sistemi
\begin_inset Index idx
status open

\begin_layout Plain Layout
jednoprocesorski sistemi
\end_layout

\end_inset

 se međusobno veoma razlikuju, jer mogu biti i džepni i mainframe računari.
 U svima njima postoji samo jedan glavni, odnosno centralni procesor koji
 je u stanju da izvršava opšti skup naredbi, uključujući i one koje stižu
 iz korisničkih procesa.
 Skoro svi ovakvi sistemi imaju i druge procesore specijalne namene (npr.
 grafičke procesore, kontrolere za tastaturu i sl.).
 Ti specijalni procesori izvršavaju ograničen skup naredbi i nisu u stanju
 da izvršavaju korisničke procese.
 Ponekad njima upravlja operativni sistem, u smislu da im šalje informacije
 o novom zadatku ili nadgleda njihov status.
 Na primer, mikrokontroler diska prima niz zahteva od centralnog procesora
 i implementira sopstveni algoritam za red podataka i raspoređivanje.
 Ovakva organizacija olobađa glavni procesor zadatka raspoređivanja procesa
 za disk.
 PC sadrži specijalni procesor u tastaturi koji konvertuje pritisnute tastere
 u kôd koji se šalje centralnom procesoru.
 U suštini, i ako sistem ima više procesora, ali je samo jedan od njih centralni
 procesor opšte namene, onda se radi o jednoprocesorskom sistemu.
\end_layout

\begin_layout Subsection
Multiprocesorski sistemi
\end_layout

\begin_layout Standard
Sistemi sa više procesora, paralelni
\begin_inset Index idx
status open

\begin_layout Plain Layout
multiprocesorski sistemi
\end_layout

\end_inset

 ili multiprocesorski sistemi (multiprocessor systems)
\begin_inset Index idx
status open

\begin_layout Plain Layout
paralelni sistemi
\end_layout

\end_inset

 postaju sve zastupljeniji.
 To su sistemi u kojima dva ili više procesora direktno komuniciraju, dele
 magistralu, a ponekad i takt, memoriju i periferijske uređaje.
 Sistemi sa više procesora imaju tri glavne prednosti: brži su, jeftiniji
 i pouzdaniji.
\end_layout

\begin_layout Standard
Današnji multiprocesorski sistemi postoje u dve varijante.
 U sistemima koji koriste asimetrično multiprocesiranje
\begin_inset Index idx
status open

\begin_layout Plain Layout
asimetrično multiprocesiranje
\end_layout

\end_inset

 (asymmetric multiprocessing) svakom procesoru se dodeljuje poseban zadatak.
 U tom slučaju glavni (master) procesor kontroliše ceo sistem, dok drugi,
 podređeni (slave) procesori čekaju uputstva od njega ili im je pak dodeljen
 specifičan zadatak.
 Češće se ipak u multiprocesorskim sistemima koristi simetrično multiprocesiranj
e
\begin_inset Index idx
status open

\begin_layout Plain Layout
simetrično multiprocesiranje
\end_layout

\end_inset

 (SMP) u kome svaki procesor izvršava sve zadatke unutar operativnog sistema.
 Kod simetričnog multiprocesiranja svi procesori su međusobno jednaki, tj.
 ne postoji master-slave odnos između procesora.
 
\end_layout

\begin_layout Standard
Takođe, u poslednje vreme u dizajnu procesora sve češće se sreće organizacija
 u kojoj isti procesorski čip sadrži nekoliko jezgara (multicore
\begin_inset Index idx
status open

\begin_layout Plain Layout
multicore procesor
\end_layout

\end_inset

).
 To su u suštini multiprocesorski čipovi.
 Iako se njihova arhitektura razlikuje od običnih jednojezgarnih procesora,
 oni iz ugla operativnog sistema izgledaju kao nekoliko standardnih procesora.
\end_layout

\begin_layout Standard
Najnoviji trend su 
\series bold
blejd serveri
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
blejd server
\end_layout

\end_inset

 u kojima se u istom kućištu nalazi nekoliko procesora, U/I i mrežnih kartica.
 Razlika između blejd servera i multiprocesorskih sistema je u tom što se
 svaki procesor u blejd serveru podiže nezavisno i ima sopstveni operativni
 sistem.
 Neki blejd serveri su i multiprocesorski, čime se narušava granica između
 različitih tipova sistema.
 U suštini, blejd serveri se sastoje od nekoliko nezavisnih multiprocesorskih
 sistema.
\end_layout

\begin_layout Standard
Još jedan tip sistema sa više procesora je 
\begin_inset Index idx
status open

\begin_layout Plain Layout
klaster
\end_layout

\end_inset


\series bold
klaster
\series default
.
 Poput multiprocesorskih sistema, klasterski sistemi sadrže više procesora
 koji obavljaju obradu.
 Klasteri se od multiprocesorskih sistema razlikuju po tome što su sastavljeni
 od nekoliko zasebnih sistema; u tom smislu definicija klastera nije jedinstvena.
 Ipak, najšire prihvaćena definicija jeste da klasterski sistemi dele prostor
 za čuvanje podataka i da su blisko povezani putem lokalne mreže (LAN).
 
\end_layout

\begin_layout Chapter
Pregled operativnih sistema
\end_layout

\begin_layout Standard
Operativni sistem je program koji upravlja hardverom računara, a istovremeno
 služi i kao osnova za aplikativne programe i kao posrednik između korisnika
 računara i hardvera.
 Gledano iz ugla korisnika računara, operativni sistem je interfejs ka računarsk
om sistemu.
 Različiti operativni sistemi predstavljaju se različitim interfejsima:
 neki su projektovani tako da budu udobni za korišćenje, drugi da budu efikasni,
 a treći pak kombinuju oba pristupa.
 Gledano iz ugla računarskog sistema, operativni sistem je softver čija
 je najvažnija uloga da efikasno upravlja sistemskim resursima.
\end_layout

\begin_layout Standard
Operativni sistem se može uporediti sa dirigentom orkestra: sam po sebi,
 on nema nikakvu funkciju, ali obezbeđuje okruženje u kome neko drugi može
 da radi nešto korisno.
 
\end_layout

\begin_layout Section
Operativni sistem iz perspektive korisnika
\end_layout

\begin_layout Standard
Iz ugla korisnika, izgled računara se menja u zavisnosti od interfejsa koji
 mu on predstavlja.
 Većina korisnika računara sedi ispred PC računara koji se sastoji od monitora,
 tastature, miša i sistemske jedinice.
 Takav sistem je projektovan za jednog korisnika koji ima apsolutni monopol
 nad njegovim resursima.
 U tom slučaju, operativni sistem je projektovan tako da bude lak za korišćenje,
 pri čemu je izvesna pažnja poklonjena i performansama sistema, kao i korišćenju
 resursa.
 
\end_layout

\begin_layout Standard
Neki korisnici sede ispred terminala povezanog sa mejnfrejm
\begin_inset Index idx
status open

\begin_layout Plain Layout
mejnfrejm
\end_layout

\end_inset

 računarom; u tom slučaju, istom računaru preko drugih terminala pristupaju
 i drugi korisnici koji tada dele resurse ili razmenjuju informacije.
 U takvim slučajevima operativni sistem je projektovan tako da maksimizira
 korišćenje resursa, odnosno da obezbedi da se svo dostupno procesorsko
 vreme, memorija i ulazno-izlazni uređaji koriste efikasno, a da pri tom
 svi korisnici budu približno ravnopravni u njihovom korišćenju.
\end_layout

\begin_layout Standard
Postoje i slučajevi kada korisnici koriste umrežene radne stanice
\begin_inset Index idx
status open

\begin_layout Plain Layout
radne stanice
\end_layout

\end_inset

 povezane sa drugim radnim stanicama ili server
\begin_inset Index idx
status open

\begin_layout Plain Layout
server
\end_layout

\end_inset

ima.
 Takvi korisnici na raspolaganju imaju sopstvene resurse, ali i deljene
 resurse kao što su mreža i serveri (npr.
 serveri za razmenu datoteka, štampanje itd.).
 U takvim slučajevima operativni sistem je projektovan tako da omogući kompromis
 između upotrebljivosti na nivou pojedinačnih korisnika i korišćenja resursa.
\end_layout

\begin_layout Standard
U poslednje vreme sve češće se koriste razne vrste džepnih računara
\begin_inset Index idx
status open

\begin_layout Plain Layout
džepni računari
\end_layout

\end_inset

.
 Takvi uređaji su pretežno samostalne jedinice namenjene pojedinačnim korisnicim
a.
 Neki od njih se umrežavaju, najčešće bežično.
 Zbog ograničene snage, brzine i interfejsa operativni sistemi za džepne
 uređaje su projektovani tako da naglasak bude na pojedinačnim korisnicima,
 ali se vodi računa i o potrošnji baterije.
\end_layout

\begin_layout Standard
Neke operativne sisteme uopšte nije briga za to kako će se predstavljati
 korisnicima.
 Na primer, računari ugrađeni u kućne uređaje i automobile ponekad imaju
 numeričke tastature ili lampice koje prikazuju stanje, ali su njihovi operativn
i sistemi projektovani tako da se izvršavaju bez ikakvog uticaja korisnika.
\end_layout

\begin_layout Section
Operativni sistem iz perspektive računara
\end_layout

\begin_layout Standard
Sa tačke gledišta računara, operativni sistem je program koji je najbliži
 hardveru.
 U tom smislu, on se može posmatrati i kao upravljač resursima.
 Računarski sistem ima brojne resurse koji su potrebni za rešavanje problema,
 na primer procesorsko vreme, prostor u memoriji, prostor za smeštanje datoteka,
 U/I uređaje itd.
 Operativni sistem upravlja brojnim i potencijalno suprotstavljenim zahtevima
 za dodelu resursa i mora da ih dodeli određenim programima i korisnicima
 tako da sistem u celini radi efikasno i pouzdano.
 Dodeljivanje resursa je posebno važno kada veći broj korisnika pristupa
 istom računaru.
\end_layout

\begin_layout Standard
Operativni sistem je program kao i svi drugi; ono što ga čini toliko važnijim
 od svih ostalih jeste njegova namena.
 To je program koji vodi procesor u korišćenju sistemskih resursa i upravlja
 vremenom izvršavanja svih drugih programa.
 Zbog zahteva da budu laki za korišćenje i održavanje, a istovremeno i efikasni,
 operativni sistemi spadaju u najsloženije programe koji su ikada napravljeni.
\end_layout

\begin_layout Standard
Posmatrano iz nešto drugačije perspektive, operativni sistem je i sredstvo
 za upravljanje različitim U/I uređajima i korisničkim programima.
 Operativni sistem je zapravo kontrolni program koji upravlja korisničkim
 aplikacijama tako da se izbegnu greške i nepravilno korišćenje računara.
 U tom smislu ima jedno specijalno zaduženje: kontrolu rada ulazno-izlaznih
 uređaja.
\end_layout

\begin_layout Section
Definicija operativnog sistema
\end_layout

\begin_layout Standard
Posle svega što smo rekli, teško je precizno definisati šta je tačno operativni
 sistem.
 Takođe, ne postoji opšte prihvaćena definicija šta sve čini operativni
 sistem.
 Postoje operativni sistemi koji zauzimaju manje od 1 MB i nemaju čak ni
 program za obradu teksta, ali isto tako i oni koji zauzimaju gigabajte
 prostora i nude kompletan grafički interfejs.
 Zbog toga se najčešće podrazumeva da je operativni sistem program koji
 se stalno izvršava u računaru (odnosno program koji se stalno nalazi u
 radnoj memoriji računara) i tada se obično zove 
\series bold
kernel
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel
\end_layout

\end_inset

 ili 
\series bold
jezgro
\series default
, a
\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistem!jezgro
\end_layout

\end_inset

 sve ostalo spada u sistemski odnosno aplikativni softver.
 Mi ćemo se držati ove definicije.
\end_layout

\begin_layout Section
Struktura operativnog sistema
\end_layout

\begin_layout Standard
Operativni sistem obezbeđuje okruženje u kome se izvršavaju programi.
 Iako se različiti operativni sistemi međusobno razlikuju, ipak svi imaju
 neke zajedničke karakteristike, o kojima će biti reči u ovom odeljku.
\end_layout

\begin_layout Standard
Jedna od najvažnijih osobina modernih operativnih sistema jeste podrška
 za izvršavanje više programa, tj.
 
\series bold
multiprogramiranje
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
multiprogramiranje
\end_layout

\end_inset

 (multiprogramming) ili 
\begin_inset Index idx
status open

\begin_layout Plain Layout
multitasking
\end_layout

\end_inset


\series bold
multitasking
\series default
.
 U opštem slučaju, isti korisnik ne može sve vreme da zauzima procesor ili
 U/I uređaje.
 Paralelnim izvršavanjem poslova povećava se iskorišćenost procesora tako
 što se poslovi (kôd i podaci) organizuju tako da procesor uvek ima šta
 da radi.
 Operativni sistem jednostavno prelazi na izvršavanje drugog posla ako ono
 što je dotad izvršavao mora da pričeka, na primer zato što se čeka da se
 oslobodi neki resurs.
 Kada preuzeti posao mora da sačeka, trenutni posao se zamenjuje novim i
 tako ukrug.
 Dogod postoji barem jedan posao koji može da se izvršava, procesor ne čeka
 neiskorišćen.
 
\end_layout

\begin_layout Standard
Sistemi sa multiprogramiranjem obezbeđuju okruženje u kome se različiti
 sistemski resursi (npr.
 procesor, memorija i periferijski uređaji) koriste efikasno, ali ne obezbeđuju
 interakciju korisnika sa operativnim sistemom.
 Vremenska raspodela je logičan nastavak multiprogramiranja.
 U 
\series bold
sistemima sa vremenskom raspodelom
\series default
 (time sharing), procesor izvršava nekoliko poslova tako što prelazi između
 njih, ali se prelazi dešavaju toliko često da korisnici mogu da komuniciraju
 sa svim programima koji se izvršavaju.
 Operativni sistemi koji podržavaju vremensku raspodelu su interaktivni.
 
\end_layout

\begin_layout Standard
Operativni sistem sa vremenskom raspodelom
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistem sa vremenskom raspodelom
\end_layout

\end_inset

 koristi raspoređivanje zadataka i multiprogramiranje da bi svakom korisniku
 dodelio mali deo računarskih resursa.
 Svaki korisnik ima barem jedan zaseban program u memoriji.
 Program koji se nalazi u memoriji i izvršava se naziva se 
\series bold
proces
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
proces
\end_layout

\end_inset

.
 Kada se proces izvršava, on se obično izvršava veoma kratko vreme pre nego
 što se završi ili zatraži neku U/I operaciju.
 Ulaz i izlaz mogu biti interaktivni, tj.
 izlaz se šalje na prikaz korisniku, a ulaz stiže sa tastature, miša ili
 nekog drugog uređaja kojim upravlja korisnik.
 Pošto interaktivni ulaz i izlaz obično radi 
\begin_inset Quotes eld
\end_inset

ljudskom brzinom
\begin_inset Quotes erd
\end_inset

, zahteva prilično vremena.
 Zbog toga operativni sistem mora za to vreme procesoru da obezbedi neki
 drugi posao.
 
\end_layout

\begin_layout Standard
Vremenska raspodela i multiprogramiranje zahtevaju da u memoriji bude istovremen
o prisutno nekoliko poslova.
 Pošto je memorija obično nedovoljno velika da bi primila sve poslove, oni
 se u početku čuvaju na disku u tzv.
 redu poslova
\begin_inset Index idx
status open

\begin_layout Plain Layout
red poslova
\end_layout

\end_inset

 (job queue).
 U njemu se nalaze svi poslovi koji čekaju da im se dodeli prostor u radnoj
 memoriji.
 Ako je nekoliko poslova spremno za učitavanje u radnu memoriju, a nema
 mesta za sve, sistem mora da izabere neke od njih.
 Donošenje takve odluke zove se
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje poslova
\end_layout

\end_inset

 
\series bold
raspoređivanje poslova
\series default
 (job scheduling).
 I na kraju, paralelno izvršavanje nekoliko poslova zahteva da njihov međusobni
 uticaj bude sveden na najmanju moguću meru, uključujući raspoređivanje
 procesa, čuvanje podataka na disku i upravljanje memorijom.
 
\end_layout

\begin_layout Standard
Operativni sistem sa vremenskom raspodelom mora da obezbedi prihvatljivo
 vreme odziva, što se najčešće postiže tehnikom 
\series bold
virtuelne memorije
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
virtuelna memorija
\end_layout

\end_inset

, koja omogućuje izvršavanje procesa koji se ne nalaze kompletno u memoriji.
 Najvažnija prednost tehnike virtuelne memorije je to što omogućuje korisnicima
 da izvršavaju programe koji su veći od postojeće fizičke memorije.
 Takođe, memorija se na apstraktan način deli na veliki, uniformni prostor
 za smeštanje podataka, čime se logička memorija koju 
\begin_inset Quotes eld
\end_inset

vidi
\begin_inset Quotes erd
\end_inset

 korisnik odvaja od fizičke memorije.
 Time se programeri oslobađaju brige oko ograničenog kapaciteta memorije.
\end_layout

\begin_layout Standard
Sistemi sa vremenskom raspodelom moraju da upravljaju i datotekama i da
 obezbede mehanizam za zaštitu resursa od neodgovarajućeg korišćenja.
 Da bi se osiguralo izvršavanje odgovarajućim redom, sistem mora da obezbedi
 mehanizme za sinhronizaciju poslova i njihovu međusobnu komunikaciju, kao
 i to da se poslovi ne "zaglave
\begin_inset Quotes erd
\end_inset

, večno čekajući jedan na drugog.
\end_layout

\begin_layout Section
Kako radi operativni sistem?
\end_layout

\begin_layout Standard
Operativni sistemi rade po principu prekida (odeljak 1.5).
 Ako nema procesa koji bi se izvršavali, U/I uređaja koje bi trebalo opslužiti
 niti korisnika kojima treba odgovoriti, operativni sistem će strpljivo
 i neprimetno čekati da se nešto desi.
 Događaji se najčešće signaliziraju putem 
\series bold
prekida
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
prekid
\end_layout

\end_inset

 (interrupt) ili 
\series bold
izuzetka
\series default
 (exception, trap).
 Izuzetak se softverski generiše, a prouzrokuje ga greška (npr.
 deljenje nulom ili pristup nepostojećoj memorijskoj adresi) ili specifični
 zahtev operativnom sistemu iz korisničkog programa da se dobije neka usluga.
 Za posebne tipove prekida posebni delovi kôda u operativnom sistemu (tzv.
 prekidne rutine) određuju koja će akcija biti preduzeta.
 
\end_layout

\begin_layout Subsection
Dvojni režim rada
\end_layout

\begin_layout Standard
Da bi se osiguralo pravilno izvršavanje operativnog sistema, mora se razlikovati
 izvršavanje kôda operativnog sistema i korisnički definisanog kôda.
 To je u mnogim računarskim sistemima obezbeđeno hardverski, da bi se znalo
 u kom režimu rada je procesor.
 
\end_layout

\begin_layout Standard
Potrebno je imati dva različita režima rada
\begin_inset Index idx
status open

\begin_layout Plain Layout
režim rada!korisnički
\end_layout

\end_inset

: 
\series bold
korisnički režim
\series default
 (user mode) i
\begin_inset Index idx
status open

\begin_layout Plain Layout
režim rada!sistemski
\end_layout

\end_inset

 
\series bold
sistemski režim
\series default
 (kernel mode, system mode, privileged mode).
 U hardver računara se dodaje bit koji se zove 
\series bold
bit režima
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
bit režima
\end_layout

\end_inset

 (mode bit) da bi se označio trenutni režim rada: sistemski(0) ili korisnički(1).
 Pomoću bita režima u stanju smo da razlikujemo zadatak koji se izvršava
 u okviru operativnog sistema od zadatka koji se izvršava za korisnika.
 Kada sistem izvršava neku korisničku aplikaciju, nalazi se u korisničkom
 režimu.
 Međutim, kada ta korisnička aplikacija zatraži uslugu od operativnog sistema
 (pomoću sistemskog poziva), sistem mora da pređe iz korisničkog u sistemski
 režim da bi udovoljio tom zahtevu.
 
\end_layout

\begin_layout Standard
Kada se sistem podiže, rad započinje u sistemskom režimu.
 Nakon toga se u memoriju učitava operativni sistem, a zatim sistem prelazi
 u korisnički režim pokretanjem korisničkih aplikacija.
 Kad god se desi prekid, hardver prelazi iz korisničkog u sistemski režim
 (tj.
 menja status bita režima u 0).
 To znači da je sistemski režim aktivan kad god operativni sistem preuzme
 kontrolu nad računarom, a pre nego što prepusti kontrolu nekoj korisničkoj
 aplikaciji, kada računar prelazi u korisnički režim (postavljanjem bita
 režima na 1).
\end_layout

\begin_layout Standard
Dvojni režim rada omogućuje zaštitu operativnog sistema od korisnika, kao
 i zaštitu korisnika jedan od drugog.
 Ta zaštita ostvaruje se tako što se neke mašinske instrukcije tretiraju
 kao privilegovane.
 Hardver omogućuje privilegovanim instrukcijama
\begin_inset Index idx
status open

\begin_layout Plain Layout
privilegovane instrukcije
\end_layout

\end_inset

 da se izvršavaju samo u sistemskom režimu.
 Ako se pokuša sa izvršavanjem privilegovane instrukcije u korisničkom režimu,
 hardver je neće izvršiti već će je tretirati kao nevažeću i poslati prekid
 operativnom sistemu da bi on preuzeo kontrolu.
\end_layout

\begin_layout Standard
Instrukcija za prelazak u korisnički režim rada je primer privilegovane
 instrukcije.
 Među drugim primerima su U/I kontrola, upravljanje tajmerom i prekidima;
 privilegovanih instrukcija zapravo ima prilično i sa njima ćemo se sretati
 u nastavku knjige.
\end_layout

\begin_layout Standard
Sada možemo da rezimiramo kako izgleda ciklus izvršavanja instrukcije u
 računarskom sistemu.
 Početna kontrola je unutar operativnog sistema, gde se instrukcije izvršavaju
 u sistemskom režimu.
 Kada se kontrola prenese u korisničku aplikaciju, sistem prelazi u korisnički
 režim.
 Na kraju se kontrola vraća u operativni sistem putem prekida, izuzetka,
 odnosno sistemskog poziva.
\end_layout

\begin_layout Standard
Sistemski poziv obično se realizuje u obliku prekida pomoću instrukcije
 
\family typewriter
trap
\family default
, iako neki sistemi imaju i posebnu instrukciju 
\family typewriter
syscall
\family default
.
 Jezgro operativnog sistema (kernel) ispituje prekidnu instrukciju da bi
 odredio o kom se sistemskom pozivu radi; parametar označava koji tip servisa
 zahteva korisnički program.
 Dodatne informacije potrebne za zahtev mogu biti prosleđene u registrima,
 na steku, ili u memoriji (preko pokazivača na memorijske lokacije prosleđene
 u registrima).
 Jezgro proverava da li su parametri ispravni, izvršava zahtev i vraća kontrolu
 instrukciji koja sledi nakon sistemskog poziva.
\end_layout

\begin_layout Standard
Neophodno je obezbediti i kontrolu operativnog sistema nad procesorom.
 Ne sme da se desi da se korisnički program "zaglavi
\begin_inset Quotes erd
\end_inset

 u beskonačnoj petlji, da ne šalje sistemske pozive i da nikad ne vrati
 kontrolu operativnom sistemu.
 Da bi se postigao taj cilj, koristi se 
\series bold
tajmer
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
tajmer
\end_layout

\end_inset

, koji se podešava tako da prekida računar nakon isteka zadatog vremenskog
 perioda.
 Taj period može da bude fiksan (npr.
 1/60 deo sekunda) ili promenljiv.
 Kad god otkuca takt, brojač se smanjuje za jedan (dekrementira).
 Kada brojač odbroji do 0, generiše se prekid.
 
\end_layout

\begin_layout Standard
Pre nego što preda kontrolu korisniku, operativni sistem proverava da li
 je tajmer podešen za prekid.
 Ako se tajmer generiše prekid, kontrola se automatski predaje operativnom
 sistemu, koji može prema prekidu da se odnosi kao da se radi o fatalnoj
 greški, ili može programu da dodeli još vremena za izvršavanje.
 Pri tom je očigledno da instrukcije koje menjaju sadržaj tajmera moraju
 da budu privilegovane.
\end_layout

\begin_layout Subsection
Upravljanje procesima
\end_layout

\begin_layout Standard
Program ne radi ništa ako procesor ne izvršava njegove instrukcije.
 Kao što smo pomenuli, program koji se izvršava zove se 
\series bold
proces
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
proces
\end_layout

\end_inset

.
 Program kome je dodeljeno vreme u sistemu sa vremenskom raspodelom, npr.
 kompajler (prevodilac) je primer procesa, isto kao i program za obradu
 teksta.
 Sistemski zadatak kao što je slanje izlaza na štampač, takođe može da bude
 proces (ili deo procesa).
 Zasad proces možemo posmatrati i kao posao ili program sa vremenskom raspodelom.
 Procesu su potrebni određeni resursi, uključujući procesorsko vreme, memoriju,
 datoteke i U/I uređaje, da bi obavio svoj zadatak.
 Ti resursi se dodeljuju procesoru kada on nastaje ili se alociraju dok
 se on izvršava.
 Kada se proces završi, operativni sistem će osloboditi sve resurse koje
 je proces koristio.
 
\end_layout

\begin_layout Standard
Treba naglasiti da program sam po sebi nije proces; program je 
\shape italic
pasivan entitet
\shape default
, npr.
 datoteka na disku, dok je proces za razliku od njega 
\shape italic
aktivan entitet
\shape default
.
 Proces u jednoj niti ima jedan programski brojač
\begin_inset Index idx
status open

\begin_layout Plain Layout
programski brojač
\end_layout

\end_inset

 (program counter) koji zadaje sledeću instrukciju koja će biti izvršena
 (o nitima će biti reči kasnije).
 Izvršavanje takvog procesa mora biti sekvencijalno.
 Procesor izvršava jednu instrukciju procesa za drugom, sve dok se proces
 ne završi.
 Štaviše, u istom trenutku može da se izvršava samo jedna instrukcija procesa.
 Na taj način, iako sa istim programom mogu da budu povezana dva procesa,
 oni se posmatraju kao dva posebna niza instrukcija za izvršavanje.
 Višenitni proces 
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!višenitni
\end_layout

\end_inset

(multithreaded process) ima nekoliko programskih brojača, a svaki od njih
 pokazuje na sledeću instrukciju koja će se izvršavati za datu nit.
\end_layout

\begin_layout Standard
Proces je jedinica rada u sistemu.
 Takav sistem sastoji se od skupa procesa, pri čemu su neki od njih procesi
 operativnog sistema (oni koji izvršavaju sistemski kôd), a ostatak čine
 korisnički procesi.
 Svi ti procesi potencijalno mogu da se izvršavaju konkurentno, tj.
 istovremeno.
 U tom smislu, operativni sistem je zadužen za kreiranje i uništavanje korisničk
ih i sistemskih procesa, suspendovanje i nastavljanje procesa, sinhronizaciju
 procesa i sl.
\end_layout

\begin_layout Subsection
Upravljanje memorijom
\end_layout

\begin_layout Standard
Glavna (radna) memorija
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija
\end_layout

\end_inset

 je veoma važna za rad modernog operativnog sistema.
 Radna memorija je (u opštem slučaju jedino) skladište podataka kojima procesor
 i U/I uređaji mogu brzo da pristupaju.
 Na primer, da bi procesor obrađivao podatke sa diska, ti podaci prvo moraju
 da se učitaju u radnu memoriju pomoću U/I poziva koje generiše procesor.
 Na isti način, instrukcije moraju da se nađu u memoriji da bi ih procesor
 izvršavao.
\end_layout

\begin_layout Standard
Da bi se poboljšalo iskorišćenje procesora, računari moraju da drže nekoliko
 procesa u memoriji, što stvara potrebu za upravljanjem memorijom.
 Postoje razne metode upravljanja memorijom, a efikasnost svake od njih
 zavisi od situacije.
 U pogledu upravljanja memorijom, operativni sistem je zadužen za praćenje
 ko i koliko koristi delove memorije, odlučivanje koje procese (ili njihove
 delove) i podatke treba smestiti u memoriju ili izbaciti iz nje, kao i
 za alociranje i dealociranje prostora u memoriji po potrebi.
\end_layout

\begin_layout Subsection
Upravljanje prostorom za čuvanje podataka
\end_layout

\begin_layout Standard
Operativni sistem kreira apstraktnu jedinicu za čuvanje podataka koja se
 zove 
\series bold
datoteka
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteka
\end_layout

\end_inset

 (file).
 Datoteke su povezane sa fizičkim uređajima kojima se pristupa preko odgovarajuć
ih kontrolera.
 Upravljanje datotekama je jedna od najvidljivijih komponenti operativnog
 sistema.
 Računari mogu da čuvaju informacije na nekoliko različitih vrsta fizičkih
 medijuma, među kojima su najčešće korišćeni magnetni diskovi, optički diskovi
 i magnetne trake.
 
\end_layout

\begin_layout Standard
Datoteka je skup povezanih informacija koje definiše njen autor.
 Datoteke najčešće predstavljaju programe i podatke.
 Datoteke sa podacima mogu biti tekstualne ili binarne.
 Pojam datoteke je izuzetno apstraktan, a operativni sistem ga implementira
 upravljanjem uređajima za čuvanje velike količine podataka.
 Datoteke se takođe najčešće organizuju u direktorijume da bi se lakše koristile.
 
\end_layout

\begin_layout Standard
Zadaci operativnog sistema u pogledu upravljanja datotekama jesu kreiranje
 i uništavanje datoteka, kreiranje i uništavanje direktorijuma, podrška
 za operacije za rad sa datotekama i direktorijumima i sl.
\end_layout

\begin_layout Standard
Pošto je radna memorija premala da bi u nju stali svi podaci i programi,
 i pošto se podaci koji se u njoj nalaze gube kada se isključi napajanje,
 računarski sistem mora da obezbedi sekundarnu memoriju
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!sekundarna
\end_layout

\end_inset

 kao rezervu za glavnu, radnu memoriju.
 Većina modernih računarskih sistema koristi diskove kao sekundarne medijume
 za čuvanje programa i podataka.
 Većina programa čuva se na disku dok se ne učita u memoriju, a zatim se
 disk koristi i kao izvor i kao odredište podataka.
 Zbog toga je pravilno upravljanje diskovima od velike važnosti za računarski
 sistem.
 U pogledu upravljanja diskovima, operativni sistem je zadužen za upravljanje
 slobodnim prostorom, alociranje mesta za čuvanje podataka i sl.
\end_layout

\begin_layout Standard
Često se koristi i prostor za čuvanje podataka koji je sporiji, veći i jeftiniji
 od sekundarne memorije.
 Magnetne trake, CD i DVD diskovi su tipični primer tercijarnih uređaja
 za čuvanje podataka.
 Iako tercijarna memorija
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!tercijarna
\end_layout

\end_inset

 nije bitna kada je reč o performansama sistema, i ona zahteva upravljanje;
 neki operativni sistemi preuzimaju i taj zadatak, dok ga drugi prepuštaju
 korisničkim aplikacijama.
\end_layout

\begin_layout Section
Tipovi operativnih sistema
\end_layout

\begin_layout Standard
U zavisnosti od namene, postoje različiti tipovi operativnih sistema čiji
 je kratak pregled dat u nastavku.
\end_layout

\begin_layout Itemize

\series bold
Distribuirani sistemi
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistemi!distribuirani
\end_layout

\end_inset

 (distributed OS): skup fizički razdvojenih, umreženih računarskih sistema
 koji omogućuju pristup različitim resursima koje sistem održava.
 Pristup zajedničkim resursima ubrzava rad, poboljšava funkcionalnost, dostupnos
t podataka i pouzdanost.
 U distribuiranim sistemima računari ne dele zajedničku memoriju i sistemski
 sat.
\end_layout

\begin_layout Itemize

\series bold
Mrežni operativni sistemi
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistemi!mrežni
\end_layout

\end_inset

 (network OS): obezbeđuju okruženja u kojima korisnici sa svojih lokalnih
 mašina mogu pristupati resursima udaljenih sistema na dva načina: procedurom
 daljinskog prijavljivanja na sistem (remote login) ili razmenom datoteka
 sa udaljenim sistemom (remote file transfer).
\end_layout

\begin_layout Itemize

\series bold
Sistemi za rad u realnom vremenu
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistemi!za rad u realnom vremenu
\end_layout

\end_inset

 (real-time embedded OS): Embedded računari su najčešće korišćen tip računara
 koji se nalazi svuda: od automobila do mikrotalasnih rerni.
 Obično obavljaju vrlo specifične poslove, a sistemi na kojima se izvršavaju
 su vrlo ograničeni.
 Za embedded uređaje razvijaju se specijalni operativni sistemi, vrlo ograničeni
h mogučnosti, bez korisničkog interfejsa, čiji je glavni zadatak da upravljaju
 hardverom uređaja.
 Embedded operativni sistemi gotovo uvek u rade u realnom vremenu, što znači
 da postavljaju vrlo stroga vremenska ograničenja za rad procesora ili tok
 podataka.
 Obrada u realnom vremenu mora da se završi u predviđenom vremenskom roku,
 jer će sistem u suprotnom zakazati.
 To je u sasvim drugačije nego u sistemima sa vremenskom raspodelom, u kojima
 je brz odziv poželjan, ali ne i neophodan.
\end_layout

\begin_layout Itemize

\series bold
Multimedijski sistemi
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistemi!multimedijski
\end_layout

\end_inset

(multimedia OS): Većina operativnih sistema predviđena je za rad sa tekstualnim
 datotekama, programima, tabelama i sl.
 Međutim, u poslednje vreme sve češće se u računarske sisteme ugrađuju multimedi
jalni podaci koje čine audio i video datoteke.
 Podaci u njima razlikuju se od 
\begin_inset Quotes eld
\end_inset

običnih
\begin_inset Quotes erd
\end_inset

 podataka po tome što se prenose unutar definisanih vremenskih prozora (npr.
 u slučaju videa, 30 slika u sekundi).
 Multimedija je opšti pojam za aplikacije koje se danas dosta koriste, npr.
 MP3 muziku, DVD filmove, video konferencije, animacije, prenos slike uživo
 preko Weba.
 Sve češće se multimedija osim na standardnim računarima sreće i u džepnim
 uređajima (PDA i 
\begin_inset Quotes eld
\end_inset

pametnim
\begin_inset Quotes erd
\end_inset

 mobilnim telefonima) za koje se projektuju specijalni operativni sistemi.
\end_layout

\begin_layout Itemize

\series bold
Operativni sistemi za džepne uređaje
\series default
 (handheld
\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistemi!džepni
\end_layout

\end_inset

 systems): Pod 
\begin_inset Quotes eld
\end_inset

džepnim
\begin_inset Quotes erd
\end_inset

 uređajima podrazumevamo lične digitalne pomoćnike (PDA, Personal Digital
 Assistant) kao što su Palm, PocketPC ili Blackberry uređaji i 
\begin_inset Quotes eld
\end_inset

pametne
\begin_inset Quotes erd
\end_inset

 mobilne telefone.
 Na njima se izvršavaju specijalno projektovani operativni sistemi koji
 moraju da vode računa o ograničenoj memoriji, ekranu i procesorskoj snazi
 ovakvih uređaja.
 Na primer, trenutno vrlo malo džepnih uređaja koristi virtuelnu memoriju,
 pa programeri aplikacija moraju da se dovijaju unutar granica postojeće
 fizičke memorije.
 Ipak, ograničenja u funkcionalnosti džepnih uređaja nadomešćuje njihova
 pogodnost i prenosivost, pa se oni sve više koriste i razvijaju.
\end_layout

\begin_layout Itemize

\series bold
Cloud operativni sistemi
\series default
 (sistemi
\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistemi!u oblaku
\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

u oblaku
\begin_inset Quotes erd
\end_inset

): Radi se o pojednostavljenim operativnim sistemima koji rade kao čitači
 Weba i obezbeđuju pristup različitim Web aplikacijama.
 Te aplikacije omogućuju korisnicima da obavljaju prostije zadatke, a da
 im pri tom nije potreban kompletan operativni sistem.
 Zbog svoje jednostavnosti, cloud operativni sistem može da se podigne veoma
 brzo.
 Ovakvi operativni sistemi projektovani su za netbook računare, mobilne
 uređaje koji se povezuju sa Internetom i za računare koji se prvenstveno
 koriste za pristup Internetu.
 Iz 
\begin_inset Quotes eld
\end_inset

oblaka
\begin_inset Quotes erd
\end_inset

 korisnik može lako da podigne glavni operativni sistem.
 Postoje i tzv.
 cloud aplikacije koje se umesto na lokalnom disku računara izvršavaju 
\begin_inset Quotes eld
\end_inset

u oblaku
\begin_inset Quotes erd
\end_inset

, odnosno na Internetu; to se zove cloud computing, a da bi se koristilo,
 potreban je samo računar sa osnovnim operativnim sistemom i čitačem Weba.
 
\end_layout

\begin_layout Section
Usluge operativnog sistema
\end_layout

\begin_layout Standard
Operativni sistem obezbeđuje okruženje za izvršavanje programa u kome programima
 i njihovim korisnicima nudi određene
\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistem!usluge
\end_layout

\end_inset

 
\series bold
usluge
\series default
 (services).
 Konkretne usluge razlikuju se od jednog do drugog operativnog sistema,
 ali ipak imaju slične osobine.
 Iz perspektive korisnika, operativni sistem nudi:
\end_layout

\begin_layout Itemize

\series bold
Korisnički interfejs
\series default
: gotovo svi operativni sistemi imaju korisnički interfejs
\begin_inset Index idx
status open

\begin_layout Plain Layout
korisnički interfejs
\end_layout

\end_inset

 (user interface, UI).
 Ovaj interfejs može imati više oblika.
 Jedan je interfejs komandne linije
\begin_inset Index idx
status open

\begin_layout Plain Layout
interfejs!komandna linija
\end_layout

\end_inset

 (command line interface, CLI) u kome korisnici unose tekstualne komande.
 Drugi je paketni interfejs (batch interface) u kome se komande i direktive
 za kontrolu tih komandi unose u datoteku koje se zatim izvršavaju.
 Međutim, najčešće se koristi grafički interfejs
\begin_inset Index idx
status open

\begin_layout Plain Layout
interfejs!grafički
\end_layout

\end_inset

 (graphical user interface, GUI) u kome postoje prozori kojima se upravlja
 U/I uređajima, meniji za izbor opcija i tastatura za unos teksta.
 Neki sistemi nude sve tri vrste interfejsa, ili samo neke od njih.
 U nekim operativnim sistemima interpreter komandi uključen je u jezgro
 (kernel).
 U drugim pak to je specijalan program koji se izvršava kada započne posao
 ili kada se korisnik prvi put prijavi (u interaktivnim sistemima).
 U sistemima u kojima postoji više interpretera komandi, oni su poznati
 i kao ljuske (shell).
 Na primer, u UNIX sistemima korisnik može da bira između 
\shape italic
Bourne shell
\shape default
, 
\shape italic
C shell
\shape default
, 
\shape italic
Bourne-Again shell
\shape default
, 
\shape italic
Korn shell
\shape default
 itd.
 Sve ljuske imaju vrlo slične funkcionalnosti pa ih korisnici biraju na
 osnovu ličnih sklonosti.
 Tradicionalno, u UNIX sistemima dominira korisnički interfejs iz komandne
 linije, iako svi oni imaju i neki GUI interfejs (Common Desktop Environment,
 CDE ili X-Windows česti su u komercijalnim verzijama).
 Grafički interfejsi su razvijani i u različitim open-source projektima
 kao što su KDE i GNOME u GNU projektu.
 Odluka da li će se koristiti grafički ili interfejs iz komandne linije
 uglavnom zavisi od ličnih sklonosti.
 Korisnici UNIX-a obično koriste komandni, a većina korisnika Windowsa grafički
 korisnički interfejs.
 Korisnički interfejs je različit u različitim sistemima i obično je odvojen
 od sâme strukture operativnog sistema.
 Dizajn korisnog i prijateljskog korisničkog interfejsa stoga nije direktno
 povezan sa projektovanjem operativnog sistema.
 
\end_layout

\begin_layout Itemize

\series bold
Izvršavanje programa
\series default
: Sistem mora da bude u stanju da učita program u memoriju i da ga izvrši.
 Program mora da bude u stanju da završi svoje izvršavanje, bilo na uobičajen
 ili neuobičajen način (kada se desi greška).
\end_layout

\begin_layout Itemize

\series bold
U/I operacije
\series default
: Program koji se izvršava može da zahteva ulaz/izlaz iz datoteke ili U/I
 uređaja.
 Zbog efikasnosti i zaštite, korisnici obično ne mogu da kontrolišu U/I
 uređaje direktno, već to mora da uradi operativni sistem.
 
\end_layout

\begin_layout Itemize

\series bold
Rad sa sistemom datoteka
\series default
.
 Sistem datoteka je posebno važan.
 Programi moraju da čitaju i pišu datoteke, da ih kreiraju i brišu, traže
 i prikazuju informacije o njima.
 Nekim programima potrebno je da upravljaju dozvolama da bi omogućili ili
 zabranili pristup datotekama.
\end_layout

\begin_layout Itemize

\series bold
Komunikacije
\series default
.
 Česte su situacije u kojima jedan proces treba da razmenjuje informacije
 sa drugim.
 Takva komunikacija na primer može da se odvija između procesa koji se izvršavaj
u u istom računaru ili između procesa koji se izvršavaju na različitim računarsk
im sistemima u mreži.
 
\end_layout

\begin_layout Itemize

\series bold
Otkrivanje grešaka
\series default
.
 Operativni sistem mora stalno da bude na oprezu od grešaka koje mogu da
 se dese u procesoru i memorijskom hardveru, U/I uređajima ili korisničkim
 programima.
 Za sve vrste grešaka operativni sistem treba da preduzme odgovarajuću akciju
 da bi obezbedio efikasan i neometan rad.
\end_layout

\begin_layout Standard
Iz ugla računarskog sistema, operativni sistem obezbeđuje sledeće usluge:
\end_layout

\begin_layout Itemize

\series bold
Alokacija resursa
\series default
.
 Kada postoji više korisnika ili poslova koji se izvršavaju paralelno, za
 svaki od njih moraju da se odvoje (alociraju) resursi.
 Operativni sistem upravlja velikim brojem različitih tipova resursa.
 Za neke (kao što su taktovi procesora, radna memorija i prostor za čuvanje
 podataka) mora da postoji specijalan kod za alokaciju, dok drugi (kao što
 su U/I uređaji) imaju mnogo opštiji način zauzimanja i oslobađanja.
 
\end_layout

\begin_layout Itemize

\series bold
Praćenje rada
\series default
.
 Želimo da znamo koji korisnici koriste koje resurse i u kojoj meri.
 Praćenje zauzetosti resursa može da se iskoristi za statistike o iskorišćenosti
 sistema, koje nam mogu poslužiti za podešavanje sistema da bi mu se poboljšale
 performanse.
\end_layout

\begin_layout Itemize

\series bold
Zaštita i bezbednost
\series default
.
 Vlasnici informacija koje se čuvaju u višekorisničkom ili umreženom operativnom
 sistemu mogu da požele da upotrebe te informacije.
 Kada se nekoliko procesa izvršava paralelno, treba onemogućiti da jedan
 proces ometa drugi ili da proces ometa operativni sistem.
 Zaštita podrazumeva kontrolu pristupa svim resursima sistema, a bezbednost
 zaštitu sistema od spoljašnjih pretnji.
\end_layout

\begin_layout Section
Sistemski pozivi
\end_layout

\begin_layout Standard

\series bold
Sistemski pozivi
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski poziv
\end_layout

\end_inset

 (system calls) obezbeđuju interfejs za usluge koje nudi operativni sistem.
 Ovi pozivi su u opštem slučaju dostupni kao rutine u jezicima C i C++,
 iako neki zadaci niskog nivoa (npr.
 direktan pristup hardveru) ponekad moraju da se pišu u asemblerskom jeziku.
\end_layout

\begin_layout Standard
Većina programera međutim ne vidi detalje implementacije sistemskih poziva.
 Projektanti aplikacija prave programe u skladu sa interfejsom za programiranje
 aplikacija 
\begin_inset Index idx
status open

\begin_layout Plain Layout
interfejs za programiranje aplikacija (API) 
\end_layout

\end_inset

(Application Programming Interface, API).
 On određuje skup funkcija koje su na raspolaganju programeru aplikacija,
 uključujući i parametre koji se prosleđuju svim funkcijama i povratne vrednosti
 koje programer može da očekuje.
 Tri najčešća korišćena API interfejsa sistemskih poziva su Win32 za Windows
 sisteme, POSIX za sve varijante UNIX-a, Linuxa i MAC OS-a i Java API za
 projektovanje programa koji se izvršavaju u Javinoj virtuelnoj mašini.
\end_layout

\begin_layout Standard
U pozadini, funkcije koje čine API pozivaju operativni sistem umesto programera
 aplikacije.
 Postoji više razloga za to što programeri koriste API umesto da direktno
 pozivaju operativni sistem.
 Jedna od prednosti API programiranja jeste prenosivost: programer koji
 projektuje aplikaciju pomoću API interfejsa očekuje da će ta aplikacija
 raditi na bilo kom sistemu koji podržava taj API (iako su razlike između
 sistema često tolike da je to nemoguće).
 Takođe, stvarni sistemski pozivi često su mnogo detaljniji i sa njima se
 teže radi nego sa interfejsom.
 
\end_layout

\begin_layout Standard
Sistem za podršku izvršavanju većine programskih jezika (tj.
 skup funkcija ugrađenih u biblioteke kompajlera) obezbeđuje 
\series bold
interfejs za sistemske pozive
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski poziv!interfejs
\end_layout

\end_inset

 (system call interface) koji služi kao veza sa sistemskim pozivima koje
 nudi operativni sistem.
 Interfejs za sistemske pozive presreće pozive funkcija u API interfejsu
 i poziva odgovarajući sistemski poziv unutar operativnog sistema.
 Obično je svakom sistemskom pozivu pridružen broj, a interfejs za sistemske
 pozive održava tabelu indeksiranu u skladu sa tim brojevima.
 Interfejs za sistemske pozive zatim obavlja odgovarajući sistemski poziv
 u jezgru operativnog sistema, a zatim vraća status sistemskog poziva i
 povratne vrednosti (ako ih ima).
\end_layout

\begin_layout Standard
Za prosleđivanje parametara sistemskog poziva operativnom sistemu koriste
 se tri metode.
 Najjednostavniji način jeste da se parametri proslede u registrima.
 Međutim, ponekad se dešava da ima više parametara nego što ima registara.
 U takvim slučajevima parametri se čuvaju u blokovima, ili u tabeli u memoriji,
 a adresa bloka se prosleđuje kao parametar u registru.
 Ovakav pristup koriste operativni sistemi Linux i Solaris.
 Parametri takođe mogu biti stavljeni na stek operacijom 
\family typewriter
push
\family default
 iz programa, a operativni sistem će ih 
\begin_inset Quotes eld
\end_inset

skinuti
\begin_inset Quotes erd
\end_inset

 sa steka operacijom 
\family typewriter
pop
\family default
.
 U nekim operativnim sistemima koriste se metode bloka ili steka zato što
 ne ograničavaju broj niti dužinu parametara koji se prosleđuju.
\end_layout

\begin_layout Subsection
Tipovi sistemskih poziva
\end_layout

\begin_layout Standard
Sistemski pozivi mogu se grubo podeliti u pet kategorija: 
\end_layout

\begin_layout Itemize
upravljanje procesima
\end_layout

\begin_layout Itemize
rad sa datotekama
\end_layout

\begin_layout Itemize
upravljanje uređajima
\end_layout

\begin_layout Itemize
održavanje informacija
\end_layout

\begin_layout Itemize
komunikacija
\end_layout

\begin_layout Standard
Postoje različite kategorije sistemskih poziva (za upravljanje procesima,
 rad sa datotekama, upravljanje uređajima itd).
 Radi ilustracije opisaćemo sistemske pozive za upravljanje procesima.
 
\end_layout

\begin_layout Standard
Program koji se izvršava mora da bude u stanju da zaustavi izvršavanje bilo
 na standardan način (sistemskim pozivom 
\family typewriter
end
\family default
), bilo na nestandardan način (sistemskim pozivom 
\family typewriter
abort
\family default
).
 Ako se sistemski poziv obavlja u slučaju nestandardnog završetka rada,
 ili program ima problema i generiše izuzetak (trap), pravi se slika trenutnog
 stanja memorije (memory dump) i generiše se poruka o grešci.
 Sadržaj memorije upisuje se u datoteku i ispituje pomoću 
\series bold
debagera
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
debager
\end_layout

\end_inset

 (debugger); to je sistemski program koji programerima olakšava pronalaženje
 i ispravljanje grešaka u aplikacijama.
 Proces koji izvršava neki program može da zatraži učitavanje (
\family typewriter
load
\family default
) ili izvršavanje (
\family typewriter
execute
\family default
) nekog drugog programa.
 Ako se kontrola vrati u postojeći program kada se nov program završi, mora
 da se sačuva memorijska slika postojećeg programa; na taj način smo efikasno
 napravili mehanizam pomoću koga jedan program može da poziva drugi.
 Ako oba programa nastave da se izvršavaju konkurentno, napravili smo nov
 proces u multiprogramiranju.
 Često postoji poseban sistemski poziv specijalno za tu namenu (
\family typewriter
create process
\family default
 ili 
\family typewriter
submit job
\family default
).
\end_layout

\begin_layout Standard
Ako kreiramo nov posao (proces), ili čak i skup procesa, trebalo bi da budemo
 u stanju da kontrolišemo njihovo izvršavanje.
 Ta kontrola podrazumeva mogućnost određivanja i resetovanja atributa procesa,
 uključujući njegov prioritet, maksimalno dozvoljeno vreme za izvršavanje
 itd.
 (sistemski pozivi 
\family typewriter
get process attributes
\family default
 i 
\family typewriter
set process attributes
\family default
).
 Možda ćemo takođe želeti da okončamo proces koji smo pokrenuli (
\family typewriter
terminate process
\family default
) ako više nije potreban.
\end_layout

\begin_layout Standard
Pošto smo napravili nove procese, možda ćemo čekati dok se ne završe.
 Možda ćemo želeti da prođe određeno vreme (
\family typewriter
wait time
\family default
), ili, što je verovatnije, da se desi neki određeni događaj (
\family typewriter
wait event
\family default
).
 Procesi bi trebalo da signaliziraju kada se desi taj događaj (
\family typewriter
signal event
\family default
).
 
\end_layout

\begin_layout Standard
Postoji i skup sistemskih poziva koristan za debagovanje programa.
 Mnogi sistemi podržavaju poziv za prikaz sadržaja memorije (
\family typewriter
dump
\family default
).
 Sistemski poziv 
\family typewriter
trace
\family default
 prikazuje sve izvršene instrukcije, ali ga podržava manji broj sistema.
\end_layout

\begin_layout Section
Struktura operativnog sistema
\end_layout

\begin_layout Standard
Složen i veliki softver kao što je moderan operativni sistem mora pažljivo
 da se projektuje da bi radio pravilno i bio lak za menjanje.
 Uobičajen pristup ovom problemu je da se taj zadatak izdeli na manje, jasno
 definisane celine.
 Već smo ukratko pominjali sastavne delove operativnog sistema; u ovom odeljku
 pozabavićemo se time kako se one međusobno povezuju u jezgro operativnog
 sistema.
 
\end_layout

\begin_layout Subsection
Prosta struktura
\end_layout

\begin_layout Standard
Većina komercijalnih sistema nema dobro definisanu strukturu.
 Često su oni razvijani tako što su mali, ograničeni sistemi prerasli svoju
 prvobitnu namenu; primer takvog operativnog sistema je MS-DOS.
 Kada je nastao, njegovi autori nisu pretpostavili da će postati toliko
 popularan, pa nije pažljivo izdeljen u module.
 Drugi primer ograničenog strukturiranja je prvobitni UNIX koga je u početku
 ograničavao hardver.
 Ovaj operativni sistem sastojao se od dva odvojena dela: jezgra i sistemskih
 programa.
 Jezgro je zatim izdeljeno u niz interfejsa i upravljačkih programa za uređaje,
 koji su se tokom godina razvijali.
 Na taj u način jezgro je ugrađeno previše funkcija, pa se takva struktura
 teško implementirala i održavala.
 
\end_layout

\begin_layout Subsection
Slojevit pristup 
\end_layout

\begin_layout Standard
Uz odgovarajuću hardversku podršku, operativni sistem
\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistem!slojevi
\end_layout

\end_inset

 može se podeliti u manje delove; takvim pristupom omogućuje mu se da zadrži
 veću kontrolu nad računarom i aplikacijama koje ga koriste.
 Sve funkcionalnosti su podeljene u komponente, pri čemu je važno i skrivanje
 informacija, jer je programerima ostavljena sloboda da implementiraju rutine
 niskog nivoa onako kako smatraju da treba, pod uslovom da interfejs rutine
 ostane isti i da ona obavlja ono što treba.
\end_layout

\begin_layout Standard
Sistem se može podeliti u module na različite načine.
 Jedan način je slojevit pristup, u kome se operativni sistem deli u brojne
 slojeve (layer), osnosno nivoe.
 Najniži sloj (sloj 0) je hardver, a najviši (sloj N) je korisnički interfejs.
 Slojevita struktura prikazana je na Slici 2.1.
\end_layout

\begin_layout Standard
Sloj operativnog sistema je implementacija apstraktnog objekta koji čine
 podaci i operacije nad njima.
 Tipičan sloj operativnog sistema sastoji se od struktura podataka i skupa
 rutina koje mogu da pozivaju slojevi višeg nivoa.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/SlojeviOS.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 2.1: Slojevit operativni sistem.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Najvažnija prednost slojevitog pristupa jeste jednostavnost konstruisanja
 i debagovanja.
 Slojevi se prave tako da svaki od njih koristi isključivo funkcije i usluge
 nivoa ispod.
 Prvi sloj može da se debaguje nezavisno od ostatka sistema, jer u implementacij
i funkcija koristi samo hadrver (za koji se pretpostavlja da je ispravan).
 Kada se prvi sloj debaguje, može se pretpostaviti da radi ispravno i preći
 na debagovanje drugog sloja, i tako redom.
 Svaki sledeći sloj implementira se isključivo korišćenjem operacija prethodnih
 slojeva.
 Pri tom, sloj ne mora da zna kako su te operacije implementirane, već samo
 šta one rade.
 Na taj način svaki sledeći sloj skriva postojanje određnih struktura podataka,
 operacija i hardvera.
 
\end_layout

\begin_layout Standard
Najveći problem slojevitog pristupa jeste pravilno definisanje različitih
 slojeva.
 Pošto sloj može da koristi samo slojeve nižeg nivoa, pažljivo planiranje
 je neophodno.
 Na primer, upravljački program za prostor na disku koji koriste algoritmi
 za virtuelnu memoriju mora da se nalazi na nižem nivou od rutina za upravljanje
 memorijom, jer će ga ono koristiti.
\end_layout

\begin_layout Standard
Problem kod slojevitog pristupa je i to što je obično manje efikasan od
 drugih.
 Na primer, kada korisnički program izvrši U/I operaciju, izvršava se sistemski
 poziv koji se 
\begin_inset Quotes eld
\end_inset

hvata
\begin_inset Quotes erd
\end_inset

 u U/I sloju, koji zatim poziva sloj za upravljanje memorijom, a ovaj zatim
 zove sloj za CPU raspoređivanje, da bi se na kraju stiglo do hadrvera.
 U svakom sloju menjaju se parametri, prosleđuju podaci itd.
 Svaki sloj je dodatno usporavanje sistemskog poziva, a ukupan rezultat
 je to da poziv traje duže nego u sistemima bez slojeva.
 Zbog toga se poslednjih godina u projektovanju operativnih sistema teži
 tome da on ima manje slojeva sa više funkcija; na taj način zadržavaju
 se prednosti modularnog kôda, a izbegavaju problemi sa definisanjem slojeva
 i interakcijom između njih.
\end_layout

\begin_layout Subsection
Mikrokerneli
\end_layout

\begin_layout Standard
Već smo na primeru operativnog sistema UNIX videli da se sa njegovim razvojem
 jezgro povećavalo što je otežavalo njegovo održavanje.
 Sredinom osamdesetih godina razvijen je operativni sistem Mach u kome je
 jezgro podeljeno u module (microkernel).
 Operativni sistem je strukturiran tako da su iz jezgra uklonjene sve komponente
 koje nisu presudno bitne za rad; one su zatim implementirane kao sistemski
 i korisnički programi.
 Iako nema čvrstog pravila, mikrokernel
\begin_inset Index idx
status open

\begin_layout Plain Layout
mikrokernel
\end_layout

\end_inset

 obično obuhvata samo minimalno upravljanje procesima i memorijom, kao i
 komuniciranje.
\end_layout

\begin_layout Standard
Najvažnija funkcija mikrokernela je da obezbedi komunikaciju između klijentskog
 programa i različitih servisa koji se takođe izvršavaju u korisničkom prostoru.
 
\end_layout

\begin_layout Standard
Prednost mikrokernela je lako proširivanje operativnog sistema.
 Svi novi servisi dodaju se u korisnički prostor, pa ne zahtevaju menjanje
 jezgra.
 Kada jezgro ne mora da se menja, i izmena ima manje jer je i mikrokernel
 mali.
 Takav operativni sistem lakše se prenosi sa jedne hardverske platforme
 na drugu.
 Mikrokernel je takođe bezbedniji i pouzdaniji, jer se većina servisa izvršava
 kao korisnički, a ne sistemski proces.
 
\end_layout

\begin_layout Standard
Nažalost, mikrokerneli nemaju tako dobre performanse zbog opterećenja sistemskim
 funkcijama.
 
\end_layout

\begin_layout Subsection
Moduli
\end_layout

\begin_layout Standard
Možda najbolja postojeća tehnika projektovanja operativnih sistema podrazumeva
 korišćenje objektno orijentisanih tehnika za pravljenje modularnog jezgra.
 U takvom pristupu jezgro ima skup osnovnih komponenata s kojima se tokom
 podizanja ili rada dinamički povezuju dodatni servisi.
 Ovakva strategija koristi module koji se dinamički učitavaju i sreće se
 u modernim implementacijama UNIX-a (kao što su Solaris, Linux i Mac OS).
 
\end_layout

\begin_layout Subsection
Virtuelne mašine
\end_layout

\begin_layout Standard
Slojevit pristup opisan u odeljku 2.9.2 logično je nastavljen uvođenjem 
\series bold
virtuelnih mašina
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
virtuelna mašina
\end_layout

\end_inset

.
 Ideja virtuelne mašine jeste da se apstrahuje hardver računara (procesor,
 memorija, diskovi, mrežne kartice itd.) u nekoliko različitih okruženja
 za rad, stvarajući na taj način privid da se svako od tih okruženja izvršava
 u sopstvenom, privatnom računaru.
\end_layout

\begin_layout Standard
Korišćenjem raspoređivanja procesa i tehnika virtuelne memorije, o kojima
 će biti reči kasnije, operativni sistem može da stvori privid da proces
 ima sopstveni procesor sa sopstvenom (virtuelnom) memorijom.
 Proces obično ima i dodatne osobine koje ne obezbeđuje sâm hardver, kao
 što su sistemski pozivi i sistem datoteka.
 Pristup virtuelne mašine ne obezbeđuje nijednu od tih dodatnih funkcionalnosti,
 već interfejs koji je identičan postojećem hardveru.
 Svakom procesu na raspolaganju je (virtuelna) kopija računara na kome se
 izvršava.
\end_layout

\begin_layout Standard
Postoji nekoliko razloga za pravljenje virtuelne mašine, a svi su povezani
 sa mogućnošću da se deli isti hardver, a da se konkurentno izvršavaju različita
 okruženja (tj.
 različiti operativni sistemi).
 Iako je zamisao virtuelnih mašina korisna, veoma ih je teško implementirati.
 Najveći problem zapravo je napraviti precizan duplikat fizičke mašine.
 Prisetimo se da stvarni računar može da radi u dva režima: korisničkom
 i sistemskom.
 Softver za virtuelnu mašinu može da radi u sistemskom režimu, pošto je
 on i operativni sistem.
 Međutim, sâma virtuelna mašina mora da se izvršava u korisničkom režimu.
 Međutim, baš kao i fizička mašina, i virtuelna mašina ima dva režima rada.
 Zbog toga mora da postoji virtuelni korisnički režim i vituelni sistemski
 režim, koji se izvršavaju u korisničkom režimu stvarne mašine.
 Operacije koje prouzrokuju prelazak iz korisničkog u sistemski režim na
 stvarnoj mašini (kao što je sistemski poziv ili pokušaj izvršavanja privilegova
ne instrukcije) moraju da prouzrokuju prelaz iz virtuelnog korisničkog režima
 u virtuelni sistemski režim na virtuelnoj mašini.
\end_layout

\begin_layout Standard
Taj prelaz može da se ostvari na sledeći način: kada program koji radi u
 virtuelnom korisničkom okruženju na virtuelnoj mašini obavi sistemski poziv,
 time pouzrokuje prelazak u monitor virtuelne mašine na stvarnom računaru.
 Kada se kontrola dodeli monitoru virtuelne mašine, on menja sadržaj registra
 i brojača instrukcija virtuelne mašine radi simuliranja efekta sistemskog
 poziva.
 Zatim vraća kontrolu virtuelnoj mašini, koja je tada u virtuelnom sistemskom
 režimu.
\end_layout

\begin_layout Standard
Najveća razlika u osnosu na normalno izvršavanje operativnog sistema je
 u brzini.
 Osim usporenog pristupa U/I uređajima, procesor mora da se multiprogramira
 između različitih virtuelnih mašina.
 Prednost virtuelnih mašina s druge strane jeste u tome što su različiti
 sistemski resursi potpuno zaštićeni: svaka virtuelna mašina je potpuno
 izolovana od drugih.
 U trećem delu knjige dati su praktični primeri primene virtuelnih mašina
 (VMware).
\end_layout

\begin_layout Section
Pokretanje operativnog sistema
\end_layout

\begin_layout Standard
Operativni sistem se obično distribuira na disku; za generisanje sistema
 koristi se specijalan program (SYSGEN) koji čita parametre iz datoteke,
 od operatera sistema traži informacije o konfiguraciji hardvera, ili pokušava
 sam da odredi koje su komponente prisutne u sistemu.
 
\end_layout

\begin_layout Standard
Da bi računar počeo da radi, na primer kada se upali ili ugasi i ponovo
 pokrene, mora da postoji početni program koji će se izvršavati.
 Taj početni program, koji se zove 
\series bold
bootstrap
\series default
 program
\begin_inset Index idx
status open

\begin_layout Plain Layout
bootstrap program
\end_layout

\end_inset

, obično je vrlo jednostavan i čuva se u ROM
\begin_inset Index idx
status open

\begin_layout Plain Layout
ROM
\end_layout

\end_inset

 (read-only memory) ili EEPROM (electrically erasable ROM) memoriji.
 Poznat je i pod nazivom 
\series bold
firmver
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
firmver
\end_layout

\end_inset

 (firmware).
 Ovaj program inicijalizuje sve aspekte sistema, od registara procesora,
 preko kontrolera uređaja do sadržaja memorije.
 Bootstrap program mora da zna kako da učita operativni sistem tako da on
 počne da se izvršava.
 Da bi to postigao, bootstrap program mora da pronađe operativni sistem
 i da u radnu memoriju učita jezgro (kernel) operativnog sistema.
 Nakon toga operativni sistem počinje da izvršava prvi proces i čeka da
 se desi neki događaj.
 Međutim, kako će hardver znati gde je jezgro operativnog sistema i kako
 da ga učita? Procedura pokretanja računara učitavanjem jezgra operativnog
 sistema zove se podizanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistem!podizanje
\end_layout

\end_inset

 (booting).
 Na većini računara postoji programčič koji se zove bootstrap loader, a
 služi za lociranje jezgra, njegovo učitavanje u radnu memoriju i pokretanje
 operativnog sistema.
 U nekim sistemima, kao što su PC računari, koristi se postupak u dva koraka
 gde jedan prostiji bootstrap program pronalazi složeniji bootstrap loader
 na disku, a ovaj zatim učitava jezgro.
\end_layout

\begin_layout Standard
Bootstrap program može da obavlja razne zadatke.
 Jedan od zadataka obično je da pokrene dijagnostiku da bi odredio status
 mašine.
 Ako je mašina u redu, program može da nastavi sa koracima za podizanje
 sistema.
 Ovaj program takođe inicijalizuje sve aspekte sistema, od procesorskih
 registara preko kontrolera uređaja do sadržaja radne memorije.
 Na kraju, pokreće i operativni sistem.
\end_layout

\begin_layout Standard
U nekim uređajima, kao što su mobilni telefoni, lični digitalni pomoćnici
 (PDA) i konzole za igru, čitav operativni sistem nalazi se u ROM memoriji.
 Čuvanje operativnog sistema u memoriji je pogodno za male operativne sisteme,
 ali je problem kod ovakvog pristupa to što menjanje kôda bootstrap programa
 zahteva menjanje hardverskih ROM čipova.
 U nekim sistemima taj problem se rešava tako što se koristi EEPROM memorija
 (electrically erasable programmable read-only memory); ova memorija služi
 samo za čitanje, osim kada joj se eksplicitno ne uputi komanda kojom se
 omogućuje upis.
 U opštem slučaju, problem sa ROM memorijom jeste to što je izvršavanje
 kôda sporije nego izvršavanje kôda u RAM memoriji.
 Neki sistemi čuvaju operativni sistem u ROM memoriji i kopiraju ga u RAM
 da bi se brže izvršavao.
\end_layout

\begin_layout Standard
U velikim operativnim sistemima (uključujući i većinu operativnih sistema
 opšte namene kao što su Windows, MAC OS X i UNIX) ili u sistemima koji
 se često menjaju, bootstrap program se čuva u ROM memoriji, a operativni
 sistem na disku.
 U tom slučaju, bootstrap obavlja dijagnostiku i sadrži malo kôda kojim
 se učitava blok podataka sa fiksne lokacije na disku u memoriju i izvršava
 se od tog bloka za podizanje (boot block).
 Program koji se čuva u bloku za podizanje obično sadrži jednostavan kôd
 koji zna samo adresu na disku i dužinu ostatka bootstrap programa.
 Na taj način bootstrap program na disku i sâm operativni sistem mogu se
 lako menjati upisom novih verzija na disk.
 Disk koji ima particiju za podizanje (a o tome će biti reči u nastavku
 knjige) zove se 
\series bold
disk za podizanje sistema
\series default
 ili sistemski disk
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski disk
\end_layout

\end_inset

 (boot disk, system disk).
\end_layout

\begin_layout Chapter
Procesi i niti
\end_layout

\begin_layout Section
Šta je proces?
\end_layout

\begin_layout Standard
Rani računarski sistemi omogućavali su da se u određenom trenutku izvršava
 samo jedan program.
 On je imao potpunu kontrolu nad sistemom i pristup svim resursima.
 Nasuprot tome, današnji računarski sistemi omogućuju da se u memoriji istovreme
no nalazi više programa koji se izvršavaju konkurentno.
 Takav razvoj zahtevao je čvršću kontrolu i modularnost programa, što je
 dovelo do pojma proces
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces
\end_layout

\end_inset

a.
 
\series bold
Proces
\series default
 (process) je program koji se izvršava, a istovremeno i osnovna jedinica
 rada u modernim sistemima sa vremenskom raspodelom.
\end_layout

\begin_layout Standard
Sistem se dakle sastoji od skupa procesa: postoje procesi operativnog sistema
 koji izvršavaju sistemski kôd, kao i korisnički procesi koji izvršavaju
 korisnički kôd.
 Obe vrste procesa mogu da se izvršavaju konkurentno, pri čemu se procesorsko
 vreme deli između njih.
 Dodeljivanjem procesora različitim procesima operativni sistem može da
 poveća produktivnost računara.
\end_layout

\begin_layout Standard
Postavlja se pitanje šta su to aktivnosti procesora.
 Sistem sa paketnom obradom (batch) izvršava poslove (jobs), dok sistem
 sa vremenskom raspodelom ima korisničke programe ili zadatke (task).
 Čak je i u sistemima sa jednim korisnikom kao što je Microsoft Windows,
 korisnik u stanju da izvršava nekoliko programa istovremeno (npr.
 program za obradu teksta, čitač Weba i klijent za e-poštu).
 Čak i kada korisnik može da pokrene samo jedan program, operativni sistem
 mora da podrži svoje interne aktivnosti, kao što je na primer upravljanje
 memorijom.
 Po mnogo čemu sve te aktivnosti su slične, i zovemo ih 
\shape italic
procesi
\shape default
.
\end_layout

\begin_layout Standard
Proces je više od kôda; on sadrži i trenutnu aktivnost koju predstavljaju
 vrednosti programskog brojača
\begin_inset Index idx
status open

\begin_layout Plain Layout
programski brojač
\end_layout

\end_inset

 i sadržaj registara procesora.
 Proces u opštem slučaju ima stek na kome se nalaze privremeni podaci (parametri
 funkcija, povratne adrese i lokalne promenljive), segment kôda (text segment)
 i segment podataka (data section) koji sadrži globalne promenljive.
 Proces može da sadrži i dinamičku memoriju ili hrpu
\begin_inset Index idx
status open

\begin_layout Plain Layout
hrpa
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!hrpa
\end_layout

\end_inset

 (heap), tj.
 memoriju koja je alocirana tokom izvršavanja procesa.
 Struktura procesa u memoriji prikazana je na Slici 3.1.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika3.1.PNG
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 3.1: Proces u memoriji.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Naglasimo da program sam po sebi nije proces.
 Program je pasivan entitet, npr.
 datoteka sa spiskom instrukcija koja se čuva na disku (i često se zove
 
\series bold
izvršna datoteka
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
izvršna datoteka
\end_layout

\end_inset

 ili executable file), dok je proces aktivan entitet, sa programskim brojačem
 koji ukazuje na sledeću instrukciju koja treba da se završi i sa pridruženim
 skupom resursa.
 
\shape italic
Program postaje proces kada se njegova izvršna datoteka učita u memoriju
\shape default
.
 
\end_layout

\begin_layout Standard
Iako sa istim programom mogu biti povezana dva procesa, ti procesi se posmatraju
 kao nezavisni skupovi instrukcija za izvršavanje.
 Na primer, nekoliko korisnika može da pokrene različitu kopiju istog programa
 za e-poštu, ili isti korisnik može da pokrene nekoliko kopija čitača Weba.
 Svi oni su posebni procesi, pa iako im je segment kôda (odnosno tekstualni
 deo) isti, podaci, hrpa i stek im se razlikuju.
 Često se sreće i proces koji tokom izvršavanja obuhvata druge procese;
 o tome će biti reči kasnije.
\end_layout

\begin_layout Subsection
Stanja procesa
\end_layout

\begin_layout Standard
Tokom izvršavanja, proces
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!stanja
\end_layout

\end_inset

 menja stanja.
 Stanje procesa delimično je određeno njegovim trenutnim aktivnostima.
 Svaki proces može da bude u nekom od sledećih stanja:
\end_layout

\begin_layout Itemize

\series bold
New
\series default
: proces se kreira.
\end_layout

\begin_layout Itemize

\series bold
Running
\series default
: instrukcije se izvršavaju.
\end_layout

\begin_layout Itemize

\series bold
Waiting
\series default
: proces čeka da se desi neki događaj (npr.
 završetak U/I operacije ili dolazak signala).
\end_layout

\begin_layout Itemize

\series bold
Ready
\series default
: proces čeka da bude dodeljen procesoru.
\end_layout

\begin_layout Itemize

\series bold
Terminated
\series default
: izvršavanje procesa je završeno.
\end_layout

\begin_layout Standard
Nazivi stanja su proizvoljni i menjaju se od sistema do sistema, ali se
 stanja koja predstavljaju sreću u svim operativnim sistemima.
 Postoje i operativni sistemi u kojima su stanja procesa još detaljnije
 razrađena.
 
\shape italic
Važno je razumeti da u bilo kom trenutku jedan procesor može da izvršava
 samo jedan proces
\shape default
 (tj.
 samo jedan od svih procesa može da bude u stanju 
\shape italic
Running
\shape default
).
 Međutim, može da postoji mnogo procesa u stanju 
\shape italic
Ready
\shape default
 i 
\shape italic
Waiting
\shape default
.
 Dijagram stanja procesa prikazan je na Slici 3.2.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/StanjaProcesa.png
	scale 85

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 3.2: Dijagram stanja procesa.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Stanje 
\shape italic
New
\shape default
 odgovara procesu koji je upravo definisan.
 To znači da je operativni sistem obavio sve neophodne operacije za njegovo
 kreiranje (npr.
 dodelio mu je identifikator), ali još nije počeo da ga izvršava, tj.
 proces još uvek nije u radnoj memoriji već se još uvek nalazi u sekundarnoj
 memoriji (obično na disku).
 
\end_layout

\begin_layout Standard
Proces se nalazi u fazi 
\shape italic
Terminated
\shape default
 kada se izvrši njegova poslednja instrukcija, kada se izvršavanje prekine
 zbog fatalne greške ili kada neki drugi proces sa odgovarajućim ovlašćenjem
 zatraži da se on završi.
 Proces u stanju 
\shape italic
Terminated
\shape default
 više nije kandidat za izvršavanje; operativni sistem još izvesno vreme
 čuva podatke povezane sa njim da bi pomoćnim programima omogućio da dobiju
 neophodne informacije, a zatim briše sve podatke o njemu iz sistema.
\end_layout

\begin_layout Standard
Dijagram procesa na Slici 3.2 pokazuje da su mogući sledeći prelazi
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!prelazi
\end_layout

\end_inset

 između stanja:
\end_layout

\begin_layout Itemize

\shape italic
New 
\shape default
-
\shape italic
 Ready
\shape default
: Procesor je spreman da počne sa izvršavanjem procesa.
 U većini sistema postoji ograničenje broja procesa koji se izvršavaju,
 odnosno količine memorije dodeljene procesima, da prevelik broj procesa
 ne bi ugrozio performanse sistema.
\end_layout

\begin_layout Itemize

\shape italic
Ready 
\shape default
-
\shape italic
 Running
\shape default
: Kada dođe trenutak za izbor novog procesa koji će se izvršavati, operativni
 sistem (odnosno raspoređivač) će izabrati neki od procesa u stanju 
\shape italic
Ready
\shape default
.
\end_layout

\begin_layout Itemize

\shape italic
Running 
\shape default
-
\shape italic
 Terminated
\shape default
: Proces koji se trenutno izvršava okončava se ako je izvršena njegova poslednja
 instrukcija ili ako iz nekog drugog razloga njegovo izvršavanje treba da
 se završi.
\end_layout

\begin_layout Itemize

\shape italic
Running 
\shape default
-
\shape italic
 Ready
\shape default
: Najčešći razlog za ovaj prelaz je to što je proces koji se trenutno izvršava
 potrošio svo vreme koje mu je dodeljeno za izvršavanje; gotovo svi operativni
 sistemi sa vremenskom raspodelom podržavaju ovakav pristup.
 Postoje i sistemi u kojima je primenjen prioritet procesa, pa se prelaz
 između ova dva stanja dešava ako se za izvršavanje prijavi proces sa višim
 prioritetom.
\end_layout

\begin_layout Itemize

\shape italic
Running 
\shape default
-
\shape italic
 Waiting
\shape default
: Proces se šalje u stanje 
\shape italic
Waiting
\shape default
 ako zahteva nešto na šta mora da sačeka, npr.
 uslugu koju operativni sistem ne može trenutno da mu pruži, neki resurs
 ili U/I operaciju koja mora da se obavi da bi se izvršavanje nastavilo.
\end_layout

\begin_layout Itemize

\shape italic
Waiting 
\shape default
-
\shape italic
 Ready
\shape default
: Ovaj prelaz se dešava kada se desi događaj na koji je proces čekao.
\end_layout

\begin_layout Standard
Slika 3.3 ilustruje jedan primer prelazaka tri procesa između različitih
 stanja tokom izvršavanja.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Procesi.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 3.3: Primer prelaska procesa između različitih stanja tokom izvršavanja.
\end_layout

\begin_layout Section
Blok za kontrolu procesa (PCB)
\end_layout

\begin_layout Standard
Svaki proces je u operativnom sistemu predstavljen blokom za kontrolu procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!blok za kontrolu
\end_layout

\end_inset

 (PCB, Process Control Block), prikazanom na Slici 3.4.
 
\series bold
Blok za kontrolu procesa
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
blok za kontrolu procesa (PCB)
\end_layout

\end_inset

 sadrži sledeće informacije povezane sa procesom:
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/PCB.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 3.4: Pojednostavljen blok za kontrolu procesa (PCB).
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Identifikator procesa
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
identifikator procesa (PID)
\end_layout

\end_inset

 (process ID, PID): Jedinstveni identifikator
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!identifikator
\end_layout

\end_inset

 koji se pridružuje svakom procesu da bi se on razlikovao od ostalih.
\end_layout

\begin_layout Itemize

\series bold
Stanje procesa
\series default
 (stanje može da bude 
\shape italic
New
\shape default
, 
\shape italic
Ready
\shape default
, 
\shape italic
Running
\shape default
, 
\shape italic
Waiting
\shape default
 itd.)
\end_layout

\begin_layout Itemize

\series bold
Programski brojač
\series default
 (brojač
\begin_inset Index idx
status open

\begin_layout Plain Layout
programski brojač
\end_layout

\end_inset

 sadrži adresu sledeće instrukcije koju proces treba da izvrši)
\end_layout

\begin_layout Itemize

\series bold
Sadržaj registara procesora
\series default
 (Tokom izvršavanja procesa u registrima procesora nalaze se podaci koji
 se u slučaju prekida moraju sačuvati da bi se izvršavanje procesa kasnije
 pravilno nastavilo)
\end_layout

\begin_layout Itemize

\series bold
Informacije o raspoređivanju
\series default
 (prioritet procesa, pokazivači na redove za raspoređivanje i svi drugi
 parametri bitni za raspoređivanje procesa)
\end_layout

\begin_layout Itemize

\series bold
Informacije o upravljanju memorijom
\series default
 (vrednost osnovnih i graničnih registara steka, sadržaj tabela bitnih za
 upravljanje memorijom, o čemu će biti reči u Poglavlju 6).
 
\end_layout

\begin_layout Itemize

\series bold
Informacije za praćenje
\series default
 (utrošeno procesorsko i ukupno vreme, vremenska ograničenja, brojevi korisnički
h naloga, brojevi procesa i sl.)
\end_layout

\begin_layout Itemize

\series bold
Informacije o U/I statusu
\series default
 (spisak U/I uređaja dodeljenih procesu, spisak otvorenih datoteka itd.)
\end_layout

\begin_layout Standard
Blok za kontrolu procesa (PCB) je najvažnija struktura podataka u operativnom
 sistemu.
 Svaki PCB sadrži sve informacije o procesu koje su potrebne operativnom
 sistemu; ove blokove čitaju i menjaju gotovo svi moduli operativnog sistema,
 uključujući one za raspoređivanje, alokaciju resursa, obradu prekida itd.
\end_layout

\begin_layout Standard
Model procesa koji smo dosad opisivali podrazumeva da je proces program
 koji se izvršava u jednoj 
\series bold
niti
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
nit
\end_layout

\end_inset

 (thread).
 Na primer, ako proces izvršava program za obradu teksta, izvršava se jedinstven
a nit instrukcija.
 Ova jedinstvena nit kontrole omogućuje procesu da izvršava samo jedan zadatak
 u isto vreme.
 Korisnik ne može istovremeno da kuca i da pokrene modul za proveru pravopisa
 u istom procesu.
 Mnogi moderni operativni sistemi proširili su pojam procesa tako da se
 on izvršava u više niti čime je omogućeno istovremeno izvršavanje nekoliko
 zadataka.
 O tome će biti više reči u nastavku poglavlja.
\end_layout

\begin_layout Section
Raspoređivanje procesa
\end_layout

\begin_layout Standard
Cilj multiprogramiranja je da se u svakom trenutku izvršava neki proces,
 da bi se procesor maksimalno iskoristio.
 Cilj vremenske raspodele je da procesor prelazi između procesa toliko često
 da korisnici mogu da komuniciraju sa svakim programom dok se izvršava.
 Da bi se ostvarili ti ciljevi, 
\series bold
raspoređivač procesa
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivač
\end_layout

\end_inset

 (process scheduler) bira neki proces u stanju 
\shape italic
Ready
\shape default
 (između svih procesa dostupnih za izvršavanje) i šalje ga procesoru na
 izvršavanje.
 U jednoprocesorskom sistemu nikada se u određenom trenutku ne izvršava
 više od jednog procesa.
 Ako ima više procesa, svi ostali moraju da čekaju da se procesor oslobodi.
\end_layout

\begin_layout Subsection
Redovi za raspoređivanje
\end_layout

\begin_layout Standard
Kako procesi ulaze u sistem, smeštaju se u 
\series bold
red poslova
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
red poslova 
\end_layout

\end_inset

(job queue).
 Procesi koji se nalaze u radnoj memoriji u stanjima 
\shape italic
Ready
\shape default
 i 
\shape italic
Waiting
\shape default
 čuvaju se u listi koja se zove 
\series bold
red spremnih poslova
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
red spremnih poslova
\end_layout

\end_inset

 (ready queue).
 Ovaj red se u opštem slučaju čuva kao ulančana lista.
 Zaglavlje reda spremnih poslova sadrži pokazivače na prvi i poslednji PCB
 u listi.
 Svaki PCB sadrži polje za pokazivač na sledeći PCB u redu spremnih poslova.
\end_layout

\begin_layout Standard
Sistem sadrži i druge redove.
 Kada se procesu dodeli procesor, on se izvesno vreme izvršava i na kraju
 završava izvršavanje, desi se prekid ili čeka na određeni događaj, npr.
 ispunjavanje U/I zahteva.
 Pretpostavimo da proces zahteva neki deljeni U/I uređaj, kao što je disk.
 Pošto u sistemu ima mnogo procesa, disk može da bude zauzet U/I zahtevom
 nekog drugog procesa.
 U tom slučaju proces mora da čeka da se disk oslobodi.
 Spisak procesa koji čekaju na određeni U/I uređaj zove se 
\series bold
red uređaja
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
red uređaja
\end_layout

\end_inset

 (device queue).
 Za svaki uređaj postoji poseban red uređaja.
\end_layout

\begin_layout Standard
Nov proces se u početku stavlja u red spremnih poslova gde čeka dok ne bude
 izabran za izvršavanje.
 Kada se proces dodeli procesoru i započne izvršavanje, može da se desi
 neki od sledećih događaja:
\end_layout

\begin_layout Itemize
proces može da zatraži U/I i u tom slučaju se smešta u U/I red
\end_layout

\begin_layout Itemize
proces može da napravi nov potproces i da sačeka da se on završi
\end_layout

\begin_layout Itemize
proces može prinudno da bude uklonjen iz procesora, usled prekida, i da
 bude vraćen u red spremnih poslova.
\end_layout

\begin_layout Standard
U prva dva slučaja proces na kraju prelazi iz stanja 
\shape italic
Waiting
\shape default
 u stanje 
\shape italic
Ready
\shape default
 i vraća se u red spremnih poslova.
 Proces nastavlja taj ciklus dok se ne završi; tada se uklanja iz svih redova,
 a PCB i resursi koje je zauzimao se oslobađaju.
 
\end_layout

\begin_layout Subsection
Raspoređivači
\end_layout

\begin_layout Standard
Proces se tokom svog životnog veka kreće kroz različite redove za raspoređivanje.
 Operativni sistem mora na neki način da bira procese iz tih redova.
 Biranje procesa za izvršavanje obavlja se pomoću 
\series bold
raspoređivača
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivač
\end_layout

\end_inset

 (scheduler).
 
\end_layout

\begin_layout Standard
Često se kreira više procesa nego što trenutno može da se izvršava.
 Ti procesi se smeštaju u uređaj za čuvanje podataka (obično je to disk)
 radi kasnijeg izvršavanja.
 
\series bold
Dugoročni raspoređivač
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivač!dugoročni
\end_layout

\end_inset

 (long-term scheduler ili job scheduler) bira procese sa diska i učitava
 ih u memoriju.
 
\series bold
Kratkoročni
\series default
 
\series bold
raspoređivač
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivač!kratkoročni
\end_layout

\end_inset

 (short-term scheduler) bira između procesa koji su u stanju 
\shape italic
Ready
\shape default
 i nekom od njih dodeljuje procesor.
 
\end_layout

\begin_layout Standard
Najvažnija razlika između ova dva raspoređivača jeste u frekvenciji izvršavanja.
 Kratkoročni raspoređivač mora često da bira nov proces za procesor.
 Proces se ponekad izvršava samo nekoliko milisekundi pre nego što biva
 prinuđen da sačeka na ispunjenje U/I zahteva.
 Često se kratkoročni raspoređivač pokreće na svakih sto milisekundi, i
 zbog toga mora da bude brz.
 Dugoročni raspoređivač se izvršava mnogo ređe; između kreiranja dva procesa
 može ponekad da prođe i nekoliko minuta.
 Dugoročni raspoređivač upravlja brojem procesa u memoriji.
 Pošto prosečna brzina kreiranja mora biti jednaka prosečnoj brzini procesa
 koji napuštaju sistem, dugoročni raspoređivač treba da se poziva samo kada
 neki proces napusti sistem.
 Zbog dužeg intervala između izvršavanja, dugoročni raspoređivač ima na
 raspolaganju više vremena da odluči koji će proces izabrati za izvršavanje.
 
\end_layout

\begin_layout Standard
Veoma je važno da dugoročni raspoređivač pažljivo bira procese.
 Postoje procesi koji troše više vremena na U/I operacije, kao i procesi
 koji ih ređe generišu i većinu vremena provode u izračunavanjima.
 Važno je da dugoročni raspoređivač izabere dobru kombinaciju ove dve vrste
 procesa.
 
\end_layout

\begin_layout Subsection
Promena konteksta
\end_layout

\begin_layout Standard
Prekidi prouzrokuju prestanak rada procesora na trenutnom zadatku i prelazak
 u prekidnu rutinu jezgra.
 Takve operacije često se dešavaju u sistemima opšte namene.
 Kada se desi prekid, sistem mora da sačuva 
\series bold
kontekst
\series default
 procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!kontekst
\end_layout

\end_inset

 koji se izvršava u procesoru da bi mogao da ga povrati kada se završi obrada
 prekida, što u suštini znači da procesor treba da suspenduje izvršavanje
 tekućeg procesa i da ga kasnije nastavi.
 Kontekst je zapravo PCB procesa; on obuhvata vrednosti procesorskih registara,
 stanje procesa i informacije o upravljanju memorijom.
 U opštem slučaju, čuva se stanje trenutnog procesa, a zatim se ono rekonstruiše
 da bi se nastavio rad.
 Ovaj postupak se zove 
\series bold
promena konteksta
\series default
 (context switch).
 Kada se promeni kontekst, jezgro operativnog sistema čuva kontekst starog
 procesa u bloku za obradu procesa (PCB) i učitava kontekst novog procesa
 koji treba da se izvrši.
 Vreme utrošeno na promenu konteksta je čist gubitak, jer sistem u tom periodu
 ne radi ništa korisno.
 Tipično vreme promene konteksta je nekoliko milisekundi, a zavisi od brzine
 memorije, broja registara čija vrednost mora da se kopira i podržanih instrukci
ja.
\end_layout

\begin_layout Subsection
Kreiranje procesa
\end_layout

\begin_layout Standard
Većina operativnih sistema proces
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!kreiranje
\end_layout

\end_inset

e razlikuje na osnovu celobrojnog identifikatora (PID).
 U opštem slučaju, novom procesu će biti potrebni određeni resursi za izvršavanj
e zadatka.
 Kada operativni sistem iz bilo kog razloga odluči da kreira nov proces,
 postupiće po sledećoj šemi:
\end_layout

\begin_layout Itemize
Novom procesoru dodeliće jedinstveni identifikator (PID)
\end_layout

\begin_layout Itemize
Alociraće procesor u memoriji za nov proces
\end_layout

\begin_layout Itemize
Inicijalizovaće PCB novog procesa
\end_layout

\begin_layout Itemize
Staviće nov proces u odgovarajući red (npr.
 red procesa spremnih za izvršavanje)
\end_layout

\begin_layout Itemize
Napraviće ili ažurirati sve potrebne strukture podataka
\end_layout

\begin_layout Standard
Postojeći proces može da kreira nekoliko novih procesa pomoću odgovarajućeg
 sistemskog poziva.
 Proces koji pravi nove procese zove se 
\shape italic
proces roditelj
\shape default
, a novi proces zove se potproces
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!dete
\end_layout

\end_inset

 ili 
\shape italic
proces dete
\shape default
.
 Postupak kreiranja novih procesa može se nastaviti tako da se kao rezultat
 dobije stablo procesa.
\end_layout

\begin_layout Standard
Kada proces
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!roditelj
\end_layout

\end_inset

 roditelj napravi potproces, proces dete će resurse moći da dobije direktno
 od operativnog sistema, ili da bude ograničen da koristi resurse koji su
 već dodeljeni procesu roditelju.
 Ograničavanje procesa deteta da koristi resurse procesa roditelja onemogućava
 situacije u kojima bi neki proces mogao da preoptereti sistem kreiranjem
 prevelikog broja potprocesa.
 Kada je reč o izvršavanju procesa, postoje dve mogućnosti: proces roditelj
 može da nastavi da se izvršava konkurentno s procesima decom, a može i
 da sačeka dok se neki od procesa dece ne završi.
 U pogledu adresnog prostora takođe postoje dve mogućnosti: segment kôda
 procesa deteta može da bude kopija procesa roditelja, a može i da izvršava
 neki drugi kôd.
\end_layout

\begin_layout Standard
Kao primer, proučićemo kako se kreiraju procesi deca u UNIX sistemima.
 Proces dete se pravi pomoću sistemskog poziva 
\family typewriter
fork()
\family default
.
 Nov proces sadrži kopiju adresnog prostora procesa roditelja, što olakšava
 komunikaciju između procesa roditelja i njegovih potprocesa.
 Oba procesa (roditelj i dete) nastavljaju da se izvršavaju od instrukcije
 iza sistemskog poziva 
\family typewriter
fork()
\family default
, uz jednu razliku: vrednost koju poziv 
\family typewriter
fork()
\family default
 vraća nakon izvršavanja za proces dete je 0, dok je povratna istog sistemskog
 poziva u procesu roditelju PID procesa deteta.
\end_layout

\begin_layout Standard
Nakon sistemskog poziva
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski poziv!fork()
\end_layout

\end_inset

 
\family typewriter
fork()
\family default
, jedan od dva procesa koristi sistemski poziv
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski poziv!exec()
\end_layout

\end_inset

 
\family typewriter
exec()
\family default
 da bi zamenio memorijski prostor dodeljen procesu novim programom.
 Sistemski poziv 
\family typewriter
exec()
\family default
 učitava binarnu datoteku u memoriju (pri tom uništavajući sliku programa
 koji je pozvao 
\family typewriter
exec()
\family default
 u memoriji) i počinje da je izvršava.
 Na taj način dva procesa su u stanju da u početku komuniciraju, a zatim
 pođu svaki svojim putem.
 Proces roditelj nakon toga može da kreira nove procese decu, a ako nema
 šta da radi dok se proces dete izvršava, može da iskoristi sistemski poziv
 
\family typewriter
wait()
\family default
 da bi izašao iz reda spremnih poslova dok se izvršavanje procesa deteta
 ne završi.
 
\end_layout

\begin_layout Subsection
Završavanje procesa
\end_layout

\begin_layout Standard
Proces se završava kada se izvrši njegova poslednja naredba, nakon čega
 on zahteva od operativnog sistema da ga obriše sistemskim pozivom 
\family typewriter
exit()
\family default
.
 Tada proces obično vraća procesu roditelju neku celobrojnu vrednost pomoću
 sistemskog poziva
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski poziv!wait()
\end_layout

\end_inset

 
\family typewriter
wait()
\family default
.
 Operativni sistem oslobađa sve resurse koje je proces koristio (memoriju,
 datoteke, U/I bafere i sl.)
\end_layout

\begin_layout Standard
Proces može da zahteva da se neki drugi proces okonča pomoću odgovarajućeg
 sistemskog poziva.
 Takav poziv obično može da uputi samo roditelj procesa koji treba da se
 završi, jer bi u suprotnom korisnici mogli namerno da prekidaju procese
 drugih korisnika sistema.
 Proces roditelj mora da zna koji su procesi njegova deca; to je i razlog
 zbog koga sistemski poziv za kreiranje procesa deteta vraća njegov PID
 procesu roditelju.
\end_layout

\begin_layout Standard
U UNIX sistemima poziv za okončanje izvršavanja je 
\family typewriter
exit()
\family default
.
 Dešava se da proces roditelj čeka da se izvršavanje procesa deteta završi
 pomoću poziva 
\family typewriter
wait()
\family default
.
 Kada se to desi, poziv 
\family typewriter
wait()
\family default
 vraća PID okončanog procesa deteta.
 Ako se u međuvremenu završi proces roditelj, njegovoj deci se kao roditelj
 dodeljuje proces 
\family typewriter
init
\family default
.
\end_layout

\begin_layout Section
Komunikacija između procesa
\end_layout

\begin_layout Standard
Najčešće se koriste dva modela komunikacije između procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!komunikacija prosleđivanjem poruka
\end_layout

\end_inset

: prosleđivanje poruka i deljenje memorije.
 U 
\series bold
modelu prosleđivanja poruka
\series default
 (message passing), procesi razmenjuju poruke, direktno ili indirektno,
 preko zajedničkog poštanskog sandučeta.
 Pre nego što komunikacija započne, mora da se uspostavi veza; svaki proces
 ima ime, koje se prevodi u identifikator (PID) po kome ga operativni sistem
 prati.
 To prevođenje obavljaju sistemski pozivi 
\family typewriter
get hostid
\family default
 i 
\family typewriter
get processid
\family default
.
 Identifikatori se zatim prosleđuju opštim pozivima 
\family typewriter
open
\family default
 i 
\family typewriter
close
\family default
 za sistem datoteka.
 Proces sa druge strane obično mora da dâ dozvolu za uspostavljanje komunikacije
 pozivom 
\family typewriter
accept communication
\family default
.
 Većina procesa koji prihvataju komuniciranje su 
\shape italic
demoni
\shape default
 (daemons), tj.
 sistemski programi napravljeni za tu specijalnu namenu.
 Oni izvršavaju poziv 
\family typewriter
wait for connection
\family default
 i 
\begin_inset Quotes eld
\end_inset

bude se
\begin_inset Quotes erd
\end_inset

 kada se uspostavi veza.
 Izvor komunikacije, poznat i kao 
\shape italic
klijent
\shape default
, i demon koji prihvata komunikaciju, poznat kao 
\shape italic
server
\shape default
, nakon toga razmenjuju poruke pomoću poziva 
\family typewriter
read message
\family default
 i 
\family typewriter
write message
\family default
.
 Poziv 
\family typewriter
close connection
\family default
 završava komunikaciju.
\end_layout

\begin_layout Standard
U modelu 
\series bold
deljene memorije
\series default
 (shared memory), procesi
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!komunikacija deljenjem memorije
\end_layout

\end_inset

 koriste sistemske pozive 
\family typewriter
shared memory create
\family default
 i 
\family typewriter
shared memory attach
\family default
 da bi napravili zajedničku memoriju i dobili pristup delovima memorije
 koje koriste drugi procesi.
 Prietimo se da u opštem slučaju operativni sistem sprečava jedan proces
 da pristupi memoriji dodeljenoj drugom procesu.
 Model deljene memorije zahteva da se dva procesa (ili više njih) slože
 da se to ograničenje ukloni.
 Nakon toga oni mogu da razmenjuju informacije čitanjem i upisivanjem u
 deljenu (zajedničku) oblast memorije.
 Oblik i lokaciju podataka određuju sâmi procesi, tj.
 to nije pod kontrolom operativnog sistema.
 Procesi su takođe odgovorni za to da u istu oblast memorije ne upisuju
 istovremeno.
\end_layout

\begin_layout Standard
Oba pomenuta modela često se sreću u operativnim sistemima, a u većini sistema
 implementirana su oba.
 Razmenjivanje poruka je pogodno za manju količinu podataka, pošto nema
 opasnosti od konflikta, Takođe, lakše se implementira nego deljena memorija.
 S druge strane, deljena memorija omogućuje brže komuniciranje, ali zahteva
 da se obrati posebna pažnja na zaštitu i sinhronizaciju procesa koji je
 koriste.
 
\end_layout

\begin_layout Section
Niti
\end_layout

\begin_layout Standard
Dosad smo razmatrali model u kome se svaki proces izvršava u jedinstvenoj
 niti.
 Većina modernih operativnih sistema podržava i izvršavanje istog procesa
 u više niti
\begin_inset Index idx
status open

\begin_layout Plain Layout
nit
\end_layout

\end_inset

 (multithreading).
 Pre nego što je uveden pojam niti, za istu svrhu primenjivana je tehnika
 kreiranja procesa-dece opisana u prethodnim odeljcima.
 Međutim, kreiranje procesa zahteva dosta vremena i resursa; rad sa nitima
 je neuporedivo efikasniji.
\end_layout

\begin_layout Standard
Niti se ponekad zovu i 
\series bold

\begin_inset Quotes eld
\end_inset

laki
\begin_inset Quotes erd
\end_inset

 procesi
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!laki (nit)
\end_layout

\end_inset

 (lightweight processes), za razliku od standardnih procesa koji se nazivaju
 "teški
\begin_inset Quotes erd
\end_inset

 procesi
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!teški
\end_layout

\end_inset

 (heavyweight processes).
 Nit je mehanizam kojim se obezbeđuje nezavisno izvršavanje jednog zadatka
 unutar procesa.
 Više niti se u multiprocesorskom sistemu može izvršavati paralelno, dok
 se u jednoprocesorskom sistemu može stvoriti privid njihovog istovremenog
 izvršavanja.
 Veći broj niti doprinosi većoj interaktivnosti procesa.
 Na primer, programi za unos teksta omogućuju da se određeni dokument snima
 na disk dok se istovremeno kuca na tastaturi, jer se sastoji od posebnih
 niti za snimanje na disk i učitavanje znakova sa tastature.
\end_layout

\begin_layout Standard
Nit
\begin_inset Index idx
status open

\begin_layout Plain Layout
nit
\end_layout

\end_inset

 (thread) je osnovna jedinica korišćenja procesora.
 Višenitni proces sadrži nekoliko tokova kontrole (tj.
 niti) unutar istog adresnog prostora.
 Sve niti istog procesa sa njim dele stanje i resurse, nalaze se u istom
 adresnom prostoru i pristupaju istim podacima.
 Svaka nit unutar procesa međutim ima sopstveni identifikator, stanje (
\shape italic
Ready
\shape default
, 
\shape italic
Running
\shape default
, 
\shape italic
Waiting
\shape default
 itd.), programski brojač, sadržaj registara i stek.
 Slika 3.5 ilustruje razliku između standardnog procesa koji se izvršava
 u jednoj niti i višenitnog procesa.
\end_layout

\begin_layout Standard
I sâma jezgra modernih operativnih sistema podržavaju višenitni rad.
 U jezgru je aktivno nekoliko niti, od kojih svaka obavlja specifičan zadatak
 (npr.
 obradu prekida ili upravljanje uređajima).
 Prednosti korišćenja niti nad kreiranjem novih procesa su višestruke:
\end_layout

\begin_layout Itemize
Nova nit se kreira i uništava mnogo brže nego nov proces, što čini programe
 interaktivnijim
\end_layout

\begin_layout Itemize
Niti omogućuju efikasnije korišćenje resursa 
\end_layout

\begin_layout Itemize
Prelazak između niti istog procesa je mnogo brži nego prelazak između različitih
 procesa
\end_layout

\begin_layout Itemize
Niti omogućuju efikasniju komunikaciju između programa koji se izvršavaju,
 jer niti unutar istog procesa dele memoriju i datoteke pa mogu da komuniciraju
 bez posredstva jezgra operativnog sistema.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika4.1.PNG
	scale 35

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 3.5: Proces koji se izvršava u jednoj niti nasuprot višenitnom procesu.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/VisenitniRad.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 3.6: Primer višenitnog rada na jednom procesoru.
\end_layout

\begin_layout Standard
Kao što smo već pomenuli, u sistemu sa jednim procesorom multiprogramiranje
 omogućuje preplitanje niti u više procesa.
 U primeru sa Slike 3.6 u procesu se prepliće tri niti u dva procesa.
 Izvršavanje prelazi sa jedne niti u drugu kada se nit koja se trenutno
 izvršava blokira ili istekne vremenska jedinica (kvantum vremena) dodeljen
 procesoru.
 U ovom primeru, nit C počinje da se izvršava kada istekne vremeski kvantum
 niti A, iako je u tom trenutku i nit B spremna za izvršavanje.
 Izbor između niti B i niti C je odluka raspoređivača, o čemu ćemo saznati
 u sledećem poglavlju knjige.
\end_layout

\begin_layout Standard
Pošto niti procesa dele isti adresni prostor i druge resurse, npr.
 otvorene datoteke, ako jedna nit izmeni resurs, to će uticati na sve druge
 niti istog procesa.
 Zbog toga je neophodno sinhronizovati aktivnosti različitih niti da ne
 bi ometale jedna drugu ili narušavale strukturu podataka.
 Na primer, ako jedna nit pokuša da doda element u dvostruko ulančanu listu,
 taj element može da bude izgubljen ili struktura liste može da bude narušena.
 Problemi sinhronizacije niti u suštini su isti kao problemi sinhronizacije
 procesa i o njima će biti reči u nastavku knjige.
\end_layout

\begin_layout Subsection
Korisničke i sistemske niti
\end_layout

\begin_layout Standard
Operativni sistem može da podržava niti na nivou korisnika ili u jezgru.
 Korisničkim nitima
\begin_inset Index idx
status open

\begin_layout Plain Layout
nit!korisnička
\end_layout

\end_inset

 upravlja se bez podrške jezgra, dok nitima jezgra direktno upravlja operativni
 sistem.
 Skoro svi operativni sistemi podržavaju niti jezgra
\begin_inset Index idx
status open

\begin_layout Plain Layout
nit!jezgra
\end_layout

\end_inset

 (kernel threads).
 
\end_layout

\begin_layout Standard
U slučaju korisničkih niti, posao upravljanja nitima obavlja aplikacija,
 a jezgro uopšte ne zna za postojanje niti.
 Svaka aplikacija može da bude programirana tako da bude višenitna uz pomoć
 odgovarajuće biblioteke.
 
\series bold
Biblioteka niti
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
nit!biblioteke
\end_layout

\end_inset

 (thread library) je interfejs (API) za kreiranje i uništavanje niti, razmenu
 podataka i poruka između njih, raspoređivanje izvršavanja niti, čuvanje
 i rekonstruisanje konteksta niti.
 
\end_layout

\begin_layout Standard
Aplikacija standardno počinje izvršavanje u jednoj niti; aplikacija i njena
 nit dodeljene su jedinstvenom procesu kojim upravlja jezgro operativnog
 sistema.
 U svakom trenutku tokom izvršavanja aplikacija može da kreira novu nit
 koja će se izvršavati u istom procesu, što se postiže pomoću odgovarajuće
 funkcije u biblioteci niti.
 Biblioteka pravi novu strukturu podataka za nit, a zatim prepušta kontrolu
 nekoj od niti procesa koja se nalazi u stanju 
\shape italic
Ready
\shape default
, pridržavajući se utvrđenog algoritma raspoređivanja niti.
 
\end_layout

\begin_layout Standard
Jezgro operativnog sistema uopšte ne zna za te aktivnosti, i nastavlja da
 radi sa višenitnim procesom na standardan način, raspoređujući ga u redove
 u zavisnosti od stanja.
 Na Slici 3.7 koja ilustruje način rada korisničkih i sistemskih niti, slučaj
 (b) prikazuje "čiste
\begin_inset Quotes erd
\end_inset

 niti jezgra.
 Jezgro održava informacije o kontekstu procesa u celini, kao i informacije
 o kontekstu pojedinačnih niti unutar procesa.
 Raspoređivanje unutar jezgra obavlja se na nivou niti, čime se prevazilaze
 dva važna ograničenja pristupa sa Slike 3.7 (a) kada se koriste samo korisničke
 niti.
 Prvo, jezgro može istovremeno da raspoređuje više niti istog procesa na
 nekoliko procesora.
 Drugo, ako je jedna nit u procesu blokirana, jezgro može da pošalje drugu
 nit istog procesa na izvršavanje.
 Takođe, sâme rutine jezgra mogu da budu višenitne.
 S druge strane, korišćenje niti jezgra zahteva prenos kontrole sa jedne
 niti na drugu unutar istog procesa, a to zahteva promenu režima rada jezgra.
 Neki operativni sistemi koriste kombinovan pristup, prikazan na Slici 3.7
 (c), koji primenjuje i korisničke i niti jezgra.
 U takvom pristupu, niti se kreiraju u korisničkom prostoru, gde se obavlja
 i najveći deo posla sinhronizacije i raspoređivanja niti u aplikaciji.
 Više korisničkih niti iste aplikacije mapiraju se na (manji ili jednak)
 broj korisničkih niti.
 Programer može da podešava broj korisničkih niti za određenu aplikaciju
 i mašinu da bi postigao najbolje rezultate.
 Ovakav pristup je primenjen u operativnom sistemu Solaris i omogućuje da
 se više niti unutar iste aplikacije paralelno izvršava na više procesora
 (Slika 3.7).
\end_layout

\begin_layout Standard
Dakle, u zaključku, nabrajamo prednosti korišćenja korisničkih niti:
\end_layout

\begin_layout Itemize
Menjanje niti ne zahteva privilegije izvršavanja u sistemskom režimu jer
 se sve strukture podataka za upravljanje nitima nalaze u adresnom prostoru
 jednog procesa.
\end_layout

\begin_layout Itemize
Raspoređivanje se može implementirati za svaku aplikaciju posebno.
 U zavisnosti od toga o kom programu se radi, u nekim slučajevima biće pogodnije
 kružno raspoređivanje, a u drugim princip prioriteta (Poglavlje 4).
\end_layout

\begin_layout Itemize
Korisničke niti mogu da se izvršavaju na bilo kom operativnom sistemu i
 ne zahtevaju nikakve izmene jezgra.
\end_layout

\begin_layout Standard
Ipak, korisničke niti imaju i dva velika nedostatka:
\end_layout

\begin_layout Itemize
Mnogi sistemski pozivi su blokirajući; ako korisnička nit obavi sistemski
 poziv, biće blokirane sve niti procesa.
\end_layout

\begin_layout Itemize
Višenitna aplikacija ne može da iskoristi prednosti multiprocesiranja.
 Jezgro dodeljuje jednom procesu samo jedan procesor, što znači da se unutar
 procesa može izvršavati samo jedna nit.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/UserKernelNiti.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 3.7: Korisničke i sistemske niti.
\end_layout

\begin_layout Chapter
Raspoređivanje procesa
\end_layout

\begin_layout Standard
U jednoprocesorskim sistemima, procesor
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!raspoređivanje
\end_layout

\end_inset

 u određenom trenutku može da izvršava samo jedan proces; svi drugi procesi
 moraju da čekaju dok ne dođu na red.
 U multiprocesorskim sistemima, više procesa može da se izvršava istovremeno
 (paralelno).
 Da procesor ne bi bio besposlen ako proces koji trenutno izvršava čeka
 na neki događaj, uvedena je tehnika multiprogramiranja u kojoj se procesor
 naizmenično dodeljuje aktivnim procesima.
 U multiprogramiranju, proces se izvršava dok ne istekne vreme koje mu je
 dodeljeno za izvršavanje, ili dok ne dođe u situaciju da mora da čeka na
 neki događaj.
 
\end_layout

\begin_layout Standard
Dodela procesora po nekom algoritmu je jedna od najvažnijih funkcija operativnog
 sistema.
 U ovom poglavlju proučićemo najčešće korišćene tehnike za raspoređivanje
 procesa, tj.
 algoritme za dodelu procesa procesoru.
 
\end_layout

\begin_layout Section
Kriterijumi za algoritme raspoređivanja
\end_layout

\begin_layout Standard
Različiti algoritmi za raspoređivanje procesa imaju različite osobine i
 o tome treba voditi računa prilikom izbora.
 Postoji više kriterijuma po kojima se oni mogu porediti, a najvažniji su
 sledeći: 
\end_layout

\begin_layout Itemize

\series bold
Iskorišćenje procesora
\series default
 (CPU utilization): Procesor treba da bude što je moguće više iskorišćen;
 u realnim okolnostima, opterećenje se kreće između 40 i 90 procenata.
\end_layout

\begin_layout Itemize

\series bold
Propusnost sistema 
\series default
(throughput): Podrazumeva
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistem!propusnost
\end_layout

\end_inset

 broj procesa koji se izvršavaju u jedinici vremena.
 Za dugačke procese, može biti jedan proces na sat, a za brze operacije
 i po deset procesa u sekundu.
\end_layout

\begin_layout Itemize

\series bold
Ukupno vreme potrebno za izvršavanje procesa
\series default
 (turnaround time): Sa tačke gledišta određenog procesa, važno je koliko
 ukupno traje njegovo izvršavanje.
 Ukupno vreme izvršavanja procesa je zbir perioda provedenih u čekanju da
 proces uđe u radnu memoriju, čekanja u redu spremnih poslova, izvršavanja
 u procesoru i obavljanja U/I operacija.
\end_layout

\begin_layout Itemize

\series bold
Ukupno vreme u redu čekanja 
\series default
(waiting time): Algoritam za raspoređivanje procesa ne utiče na vreme u
 kome proces obavlja U/I operacije, već samo na vreme koje proces provodi
 u redu čekanja.
 Vreme čekanja je zbir vremenskih perioda provedenih u redu čekanja na procesor.
\end_layout

\begin_layout Itemize

\series bold
Vreme odziva
\series default
 (response time): U interaktivnom sistemu
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistem!vreme odziva
\end_layout

\end_inset

 ukupno vreme izvršavanja nije najbolji kriterijum.
 Često proces može da prikaže korisniku neke rezultate relativno brzo, a
 da zatim nastavi rad.
 Zbog toga vreme od slanja zahteva do prvog odziva može da bude korisna
 mera.
\end_layout

\begin_layout Section
Raspoređivanje sa prinudnom suspenzijom procesa
\end_layout

\begin_layout Standard
Kad god procesor postane besposlen, operativni sistem mora da izabere neki
 od procesa iz reda spremnih procesa i da ga pošalje na izvršavanje.
 Taj posao obavlja 
\series bold
kratkoročni raspoređivač
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivač!kratkoročni
\end_layout

\end_inset

 (short-term scheduler).
 Red spremnih poslova u opštem slučaju ne mora da bude realizovan kao FIFO
 (first-in, first-out) red; on može da bude i stablo ili neuređena ulančana
 lista.
 Međutim, bez obzira kako je implementiran, svaki red spremnih poslova kao
 elemente ima blokove za kontrolu procesa (PCB).
\end_layout

\begin_layout Standard
Stanja u kojima se aktivira kratkoročni raspoređivač su sledeća:
\end_layout

\begin_layout Enumerate
Prelaz procesa iz stanja 
\shape italic
Running
\shape default
 u stanje 
\shape italic
Waiting
\shape default
 (na primer, zato što je proces zatražio U/I operaciju ili čeka da se izvrši
 proces-dete)
\end_layout

\begin_layout Enumerate
Prelaz iz stanja 
\shape italic
Running
\shape default
 u stanje 
\shape italic
Ready
\shape default
 (na primer, kada se desi prekid)
\end_layout

\begin_layout Enumerate
Prelaz iz stanja 
\shape italic
Waiting
\shape default
 u stanje 
\shape italic
Ready
\shape default
 (na primer, zato što je obavljena U/I operacija)
\end_layout

\begin_layout Enumerate
Prelaz u stanje 
\shape italic
Terminated
\shape default
 (kada se izvršavanje procesa završi)
\end_layout

\begin_layout Standard
Kada se raspoređivanje dešava samo u situacijama 1 i 4, kažemo da se radi
 o 
\series bold
raspoređivanju bez prinudne suspenzije procesa
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!bez prinudne suspenzije procesa (nonpreemptive)
\end_layout

\end_inset

 (nonpreemptive ili cooperative scheduling).
 Kod ovakvog tipa raspoređivanja, kada se proces dodeli procesoru na izvršavanje
, on zadržava procesor sve dok se ne završi njegovo izvršavanje ili dok
 ne pređe u stanje 
\shape italic
Waiting
\shape default
 (tj.
 desi se situacija 1 ili 4).
\end_layout

\begin_layout Standard
Kod 
\series bold
raspoređivanja sa prinudnom suspenzijom procesa
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!sa prinudnom suspenzijom procesa (preemptive)
\end_layout

\end_inset

 (preemptive scheduling), raspoređivač u bilo kom trenutku može da prekine
 izvršavanje tekućeg procesa i da dodeli procesoru na izvršavanje neki drugi
 proces koji čeka u stanju 
\shape italic
Ready
\shape default
.
\end_layout

\begin_layout Section
Raspoređivanje tipa 
\begin_inset Quotes eld
\end_inset

prvi došao, prvi uslužen
\begin_inset Quotes erd
\end_inset

 (FCFS)
\end_layout

\begin_layout Standard
Algoritam tipa 
\begin_inset Quotes eld
\end_inset

prvi došao, prvi uslužen
\begin_inset Quotes erd
\end_inset

 (FCFS
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!FCFS
\end_layout

\end_inset

, First Come First Served) je najprostiji algoritam za raspoređivanje, u
 kome se procesi dodeljuju procesoru onim redom kojim pristižu u red čekanja.
 Red čekanja je standardni FIFO (First In, First Out) red u kome se PCB
 procesa koji je upravo stigao u red čekanja stavlja na kraj reda (liste),
 a procesor se dodeljuje procesu koji se nalazi na početku liste.
\end_layout

\begin_layout Standard
Ovaj algoritam se vrlo lako implementira, ali je srednje vreme čekanja u
 redu vrlo dugačko.
 Ono zavisi i od trajanja pojedinačnih procesa, ali i od trenutka njihovog
 ulaska u sistem.
 Kod algoritma FCFS moguća je i pojava konvoj efekta, kada svi procesi u
 redu čekaju da se završi jedan proces koji dugo traje.
 Ovaj algoritam obično se implementira bez prinudnog suspendovanja procesa
 jer ne poštuje prioritete procesa već samo vreme dolaska u red čekanja.
 To znači da se proces koji je dodeljen procesoru izvršava do kraja, ili
 do trenutka dok ne pređe u stanje 
\shape italic
Waiting
\shape default
 zbog čekanja na U/I operaciju.
 Zbog toga je FCFS raspoređivanje izrazito nepovoljno za sisteme sa vremenskom
 raspodelom (time-sharing) u kojima je važno da se svakom korisniku dodeljuje
 procesor u regularnim intervalima.
\end_layout

\begin_layout Section
Raspoređivanje tipa 
\begin_inset Quotes eld
\end_inset

prvo najkraći posao
\begin_inset Quotes erd
\end_inset

 (SJF)
\end_layout

\begin_layout Standard
U algoritmu tipa 
\begin_inset Quotes eld
\end_inset

prvo najkraći posao
\begin_inset Quotes erd
\end_inset

 (SJF
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!SJF
\end_layout

\end_inset

, Shortest Job First) za sve procese u redu čekanja procenjuje se vreme
 potrebno za izvršavanje, a procesor se dodeljuje onom procesu kome treba
 najmanje vremena za izvršavanje.
 Na one procese iz reda koji imaju ista procenjena vremena izvršavanja primenjuj
e se algoritam FCFS.
\end_layout

\begin_layout Standard
Osnovni nedostatak ovog algoritma je to što sistem ne može unapred da zna
 koliko će procesi trajati, tj.
 ne može da proceni ukupno trajanje procesa.
 Procena koliko će proces trajati zasniva se na činjenici da se proces sastoji
 od više ciklusa korišćenja procesora (CPU burst) koji se prekidaju U/I
 operacijama.
 Trajanje sledećeg ciklusa korišćenja procesora procenjuje se na osnovu
 trajanja prethodnih ciklusa korišćenja procesora.
\end_layout

\begin_layout Standard
SJF je optimalno raspoređivanje ako je kriterijum srednje vreme čekanja,
 zato što daje minimalno srednje vreme čekanja za dati skup procesa.
 
\end_layout

\begin_layout Standard
Razlikuju se dve vrste SJF algoritma, u zavisnosti od toga da li su implementira
ni sa prinudnim suspendovanjem procesa ili bez njega.
 Ove dve varijante se ponašaju različito kada se nov proces pojavi u redu
 čekanja dok se tekući proces izvršava.
 Varijanta SJF bez prinudnog suspendovanja uvek će završiti tekući proces,
 bez obzira da li se u redu pojavio nov proces.
 U varijanti SJF sa prinudnim suspendovanjem, ukoliko je vreme potrebno
 za izvršenje novog procesa kraće od vremena potrebnog za završetak aktivnosti
 tekućeg procesa, procesor će biti dodeljen novom procesu.
 SJF bez prinudnog suspendovanja naziva se raspoređivanje po najmanjem preostalo
m vremenu (Shortest Remaining Time, SRT
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!SRT
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Section
Raspoređivanje po prioritetu
\end_layout

\begin_layout Standard
U prioritetnim
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!po prioritetu
\end_layout

\end_inset

 algoritmima svakom procesu se dodeljuje prioritet, a nakon toga algoritam
 dodeljuje procesor onom procesu čiji je prioritet najveći.
 Prioritet je celobrojna vrednost, pri čemu je usvojeno da manji broj znači
 veći prioritet (tj.
 vrednost 0 predstavlja maksimalan prioritet).
 Ako su procesi istog prioriteta, onda se odluka donosi po principu FCFS.
\end_layout

\begin_layout Standard
Raspoređivanje tipa 
\begin_inset Quotes eld
\end_inset

prvi došao, prvi uslužen
\begin_inset Quotes erd
\end_inset

 (FCFS) je specijalan slučaj prioritetnog algoritma u kome je prioritet
 obrnuto proporcionalan trajanju sledećeg procesorskog ciklusa procesa.
 To znači da duži procesi imaju manji prioritet i obrnuto.
\end_layout

\begin_layout Standard
Prioritetni algoritmi mogu biti implementirani sa prinudnim suspendovanjem
 procesa ili bez njega.
 U slučaju implementacije sa suspendovanjem, izvršavanje tekućeg procesa
 se prekida ako se pojavi proces višeg prioriteta (a provera se obavlja
 kad god se pojavi nov proces).
 Ako je algoritam implementiran bez suspendovanja, nov proces će biti postavljen
 na početak reda.
\end_layout

\begin_layout Standard
Najveći problem prioritetnih algoritama je mogućnost neograničenog blokiranja
 ili "izgladnjivanja
\begin_inset Quotes erd
\end_inset

 (starvation).
 U prioritetnom algoritmu može se desiti da neki procesi niskog prioriteta
 večno čekaju, tj.
 da im nikad ne bude dodeljen procesor.
 To se dešava u opterećenom sistemu u kome se stalno pojavljuju novi procesi
 visokog prioriteta.
 Rešenje za problem neograničenog blokiranja je 
\begin_inset Quotes eld
\end_inset

starenje
\begin_inset Quotes erd
\end_inset

 procesa (aging); to je tehnika kojom se postupno povećava prioritet procesa
 koji dugo čekaju u sistemu.
 
\end_layout

\begin_layout Section
Kružno raspoređivanje (RR)
\end_layout

\begin_layout Standard
Kružni algoritam (Round Robin, RR
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!kružno (RR)
\end_layout

\end_inset

) je posebno projektovan za sisteme sa vremenskom raspodelom.
 Ovaj algoritam podseća na FCFS, ali se za prelaz između procesa koristi
 prinudno suspendovanje (preemption).
 Prvo se zadaje vremenska jedinica (time quantum ili time slice) koja ima
 vrednost između 10 i 100 milisekundi.
 Red spremnih poslova implementira se kao kružni red; kratkoročni raspoređivač
 prolazi kroz red spremnih poslova i redom dodeljuje procesor svakom od
 njih u trajanju od jedne vremenske jedinice.
\end_layout

\begin_layout Standard
Red spremnih poslova u ovom slučaju je FIFO red u kome se novi procesi dodaju
 na kraj reda; kratkoročni raspoređivač bira prvi proces iz reda spremnih
 procesa, podešava tajmer tako da generiše prekid nakon isteka vremenske
 jedinice i šalje proces na izvršavanje.
\end_layout

\begin_layout Standard
Ako izvršavanje procesa traje manje od vremenske jedinice, sâm proces će
 osloboditi procesor i raspoređivač će izabrati sledeći proces iz reda.
 U suprotnom, tajmer će generisati prekid, procesor će promeniti kontekst,
 a proces će biti poslat na kraj reda spremnih poslova.
 Raspoređivač će nakon toga dodeliti procesor prvom procesu iz reda.
 
\end_layout

\begin_layout Standard
Kružno raspoređivanje ima najbolje vreme odziva (response time), a veće
 srednje vreme završetka procesa (turnaround time) u odnosu na algoritam
 SJF.
 Takođe, performanse ovog algoritma veoma zavise od toga kolika je vremenska
 jedinica.
 Ako je ona veoma dugačka, onda se kružni algoritam svodi na FCFS, a ako
 je jako kratka, algoritam se zove i deljenje procesora
\begin_inset Index idx
status open

\begin_layout Plain Layout
procesor!deljenje
\end_layout

\end_inset

 (processor sharing).
 U praktičnim primenama vremenska jedinica se definiše tako da približno
 80% procesorskih operacija (CPU burst) bude kraće od nje.
\end_layout

\begin_layout Section
Raspoređivanje redovima u više nivoa
\end_layout

\begin_layout Standard
Ova klasa algoritama za raspoređivanje razvijena je za slučajeve kada se
 procesi mogu lako klasifikovati u grupe.
 Na primer, često se procesi
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!interaktivni
\end_layout

\end_inset

 dele u interaktivne (foreground) i pozadinske
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!pozadinski
\end_layout

\end_inset

 (backround, batch).
 Ove dve klase procesa imaju različite zahteve u pogledu vremena odziva,
 pa im odgovaraju različiti algoritmi za raspoređivanje.
\end_layout

\begin_layout Standard
U raspoređivanju
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!redovima u više nivoa
\end_layout

\end_inset

 pomoću redova u više nivoa (multilevel queue scheduling), red spremnih
 poslova deli se u nekoliko zasebnih redova, pri čemu se procesi trajno
 pridružuju nekom od njih prema različitim kriterijumima (zauzetoj memoriji,
 prioritetu i sl.).
 Na svaki od redova primenjuje se poseban algoritam za raspoređivanje.
 Na primer, sistem sa interaktivnim i pozadinskm poslovima imao bi dva reda
 u koje bi se procesi delili po tipu; red interaktivnih poslova bio bi raspoređi
van kružnim algoritmom, a red pozadinskih poslova FCFS algoritmom.
\end_layout

\begin_layout Standard
Ovakav način raspoređivanja zahteva i dodatno raspoređivanje između redova,
 koje se po pravilu realizuje kao prioritetno raspoređivanje sa prinudnom
 suspenzijom procesa.
 Na primer, red interaktivnih poslova mogao bi da ima apsolutni prioritet
 nad redom pozadinskih poslova.
 
\end_layout

\begin_layout Section
Raspoređivanje u multiprocesorskim sistemima
\end_layout

\begin_layout Standard
Dosad smo razmatrali samo raspoređivanje u sistemima sa jednim procesorom.
 Kada je na raspolaganju više procesora, pojavljuje se i mogućnost deljenja
 opterećenja
\begin_inset Index idx
status open

\begin_layout Plain Layout
deljenje opterećenja procesora
\end_layout

\end_inset

 (load sharing), ali se usložnjava i problem raspoređivanja procesa.
 Kao i u slučaju raspoređivanja u jednoprocesorskim sistemima, postoji više
 mogućnosti, a koji algoritam je najbolji često zavisi od okolnosti.
\end_layout

\begin_layout Standard
Jedan od mogućih pristupa problemu raspoređivanja u multiprocesorskim sistemima
 je da se ceo posao donošenja odluka, U/I obrade i drugih sistemskih aktivnosti
 dodeli glavnom (master) procesoru.
 Drugi, podređeni (slave) procesori izvršavaju samo korisnički kôd.
 To je tzv.
 asimetrično multiprocesiranje
\begin_inset Index idx
status open

\begin_layout Plain Layout
multiprocesiranje!asimetrično
\end_layout

\end_inset

 (asymmetric multiprocessing) i ono je prilično jednostavno jer samo jedan
 procesor pristupa sistemskim strukturama podataka, te nema potrebe za razmenom
 podataka.
\end_layout

\begin_layout Standard
Drugi pristup je simetrično multiprocesiranje
\begin_inset Index idx
status open

\begin_layout Plain Layout
multiprocesiranje!simetrično
\end_layout

\end_inset

 (symmetric multiprocessing), u kome svaki procesor vodi računa o raspoređivanju.
 Svi procesi mogu da se nalaze u zajedničkom redu spemnih poslova, a može
 da postoji i poseban red za svaki procesor.
 Međutim, ako svi procesori pokušavaju da pristupaju istoj strukturi podataka
 i ažuriraju je, raspoređivač mora da bude pažljivo napravljen.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Rasporedjivanje.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 4.1: Grafički dijagram različitih metoda raspoređivanja procesa.
\end_layout

\begin_layout Chapter
Sinhronizacija procesa
\end_layout

\begin_layout Standard
U jednoprocesorskom sistemu sa multiprogramiranjem, procesi
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!sinhronizacija
\end_layout

\end_inset

 se prepliću u vremenu da bi se stvorio privid istovremenog izvršavanja.
 Iako to zapravo nije stvarno paralelno izvršavanje, i mada se gubi vreme
 na menjanje procesa koji se izvršavaju, multiprogramiranjem se povećava
 efikasnost rada.
 U sistemu sa više procesora, osim što je izvršavanje procesa moguće preplitati,
 oni se mogu i preklapati tokom izvršavanja.
 Na prvi pogled, čini se da su preplitanje i preklapanje potpuno različiti
 tipovi izvršavanja i da zbog toga prouzrokuju drugačije probleme.
 Međutim, obe tehnike se mogu posmatrati kao primeri konkurentne obrade,
 što znači da su problemi isti.
 U slučaju sistema sa jednim procesorom, problemi proističu iz toga što
 se relativna brzina izvršavanja procesa ne može predvideti jer zavisi od
 aktivnosti drugih procesa, od načina na koji operativni sistem radi sa
 prekidima i od politike raspoređivanja procesa.
 Kako budemo objašnjavali probleme koji proističu iz istovremenog izvršavanja
 procesa u sistemima sa jednim procesorom, postaće jasno da se isti problemi
 pojavljuju i u multiprocesorskim sistemima.
\end_layout

\begin_layout Standard
U prethodnim poglavljima razvili smo model sistema u kome se izvršava nekoliko
 procesa ili niti koji mogu i da dele podatke i resurse.
 Posledica mogućnosti konkurentnog pristupa zajedničkim podacima može da
 bude nekonzistentnost tih podataka.
 Na primer, zamislimo slučaj u kome dva procesa žele da sačuvaju neku vrednost
 u istoj memorijskoj lokaciji.
 Operativni sistem mora da obezbedi mehanizme kojima će sprečiti konkurentan
 pristup procesa istoj lokaciji.
 To je problem sinhronizacije procesa.
 
\end_layout

\begin_layout Section
Stanje trke
\end_layout

\begin_layout Standard
Stanje trke
\begin_inset Index idx
status open

\begin_layout Plain Layout
stanje trke
\end_layout

\end_inset

 (race condition) se dešava kada nekoliko procesa ili niti upisuju i čitaju
 podatke na taj način da konačan rezultat zavisi od redosleda izvršavanja
 instrukcija u različitim procesima.
 Objasnićemo ovu pojavu na primerima.
\end_layout

\begin_layout Standard
Pretpostavimo da dva procesa, 
\family typewriter
\size small
P1
\family default
\size default
 i 
\family typewriter
\size small
P2
\family default
\size default
, dele globalnu promenljivu 
\family typewriter
\size small
a
\family default
\size default
.
 U nekom trenutku izvršavanja, proces 
\family typewriter
\size small
P1
\family default
\size default
 ažurira vrednost promenljive
\family typewriter
\size small
 a 
\family default
\size default
na 1, a isto tako u nekom trenutku svog izvršavanja proces 
\family typewriter
\size small
P2
\family default
\size default
 ažurira 
\family typewriter
\size small
a
\family default
\size default
 na 2.
 To znači da su ova dva procesa 
\begin_inset Quotes eld
\end_inset

u trci
\begin_inset Quotes erd
\end_inset

 za upis u promenljivu 
\family typewriter
\size small
a
\family default
\size default
.
 U ovom primeru, vrednost promenljive 
\family typewriter
\size small
a
\family default
\size default
 odrediće proces koji ju je poslednji ažurirao.
\end_layout

\begin_layout Standard
Sada zamislimo dva procesa, 
\family typewriter
\size small
P1
\family default
\size default
 i 
\family typewriter
\size small
P2
\family default
\size default
 koji dele globalne promenljive 
\family typewriter
\size small
b
\family default
\size default
 i 
\family typewriter
\size small
c
\family default
\size default
 sa početnim vrednostima 
\family typewriter
\size small
b=1
\family default
\size default
 i 
\family typewriter
\size small
c=2
\family default
\size default
.
 U nekom trenutku izvršavanja proces 
\family typewriter
\size small
P1
\family default
\size default
 izvršava naredbu 
\family typewriter
\size small
b=b+c
\family default
\size default
, a isto tako u nekom trenutku izvršavanja proces 
\family typewriter
\size small
P2
\family default
\size default
 izvršava naredbu 
\family typewriter
\size small
c=b+c
\family default
\size default
.
 Uočite da dva procesa ažuriraju različite promenljive.
 Međutim, konačne vrednost promenljivih zavisiće od redosleda u kome se
 izvršavaju naredbe dodele.
 Ako 
\family typewriter
\size small
P1
\family default
\size default
 prvi izvrši naredbu dodele, konačne vrednosti promenljivih biće 
\family typewriter
\size small
b=3
\family default
\size default
 i 
\family typewriter
\size small
c=5
\family default
\size default
.
 Ako 
\family typewriter
\size small
P2
\family default
\size default
 prvi izvrši dodelu, konačne vrednosti promenljivih biće 
\family typewriter
\size small
b=4
\family default
\size default
 i 
\family typewriter
\size small
c=3
\family default
\size default
.
 
\end_layout

\begin_layout Standard
Situacije kao što su ove upravo opisane često se dešavaju u operativnim
 sistemima kada njegovi različiti delovi rade sa resursima.
 Zbog toga je važno proučiti tehnike sinhronizacije procesa.
\end_layout

\begin_layout Section
Problem kritične sekcije
\end_layout

\begin_layout Standard
Zamislimo sistem koji se sastoji od više procesa.
 Svaki od tih procesa ima deo kôda koji se zove
\begin_inset Index idx
status open

\begin_layout Plain Layout
kritična sekcija
\end_layout

\end_inset

 
\series bold
kritična sekcija
\series default
 (critical section) u kome procesi menjaju zajedničke promenljive, ažuriraju
 tabelu, upisuju u datoteku i sl.
 Kada jedan proces izvršava kritičnu sekciju kôda, nijednom drugom procesu
 ne bi smelo da bude dozvoljeno da izvršava istu kritičnu sekciju, odnosno
 ne sme se dozvoliti da dva procesa istovremeno izvršavaju kritičnu sekciju.
 Problem kritične sekcije je kako projektovati protokol koji će procesi
 koristiti za saradnju.
 Svaki proces mora da zatraži dozvolu da uđe u svoju kritičnu sekciju.
 Deo kôda u kome se implementira taj zahtev zove se ulazna
\begin_inset Index idx
status open

\begin_layout Plain Layout
sekcija!kritična
\end_layout

\end_inset

 sekcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
sekcija!ulazna
\end_layout

\end_inset

 (entry section).
 Iza kritične sekcije nalazi se izlazna sekcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
sekcija!izlazna
\end_layout

\end_inset

 (exit section), a ostatak je preostala sekcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
sekcija!preostala
\end_layout

\end_inset

 (remainder section).
 Opšta struktura tipičnog procesa izgleda ovako:
\end_layout

\begin_layout LyX-Code

\size small
do {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
ulazna sekcija
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
\size small
kritična sekcija
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
izlazna sekcija
\end_layout

\begin_layout LyX-Code

\size small
preostala sekcija
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} while (true);
\end_layout

\begin_layout Standard
Rešenja za problem kritične sekcije moraju da zadovolje tri važna zahteva:
\end_layout

\begin_layout Standard
1.
 Međusobno isključivanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
međusobno isključivanje
\end_layout

\end_inset

: Ako jedan proces izvršava svoju kritičnu sekciju, onda nijedan drugi proces
 ne sme da izvršava svoju kritičnu sekciju.
\end_layout

\begin_layout Standard
2.
 Ako nijedan proces ne izvršava kritičnu sekciju, a neki procesi žele da
 uđu u nju, onda samo oni procesi koji ne izvršavaju svoje preostale sekcije
 mogu da učestvuju u odlučivanju koji će biti sledeći proces koji će ući
 u kritičnu sekciju, i ta odluka ne sme da se odlaže beskonačno.
\end_layout

\begin_layout Standard
3.
 Procesi kojima se dozvoljava da uđu u kritične sekcije mogu da uđu u njih
 ograničen broj puta nakon što drugi proces podnese zahtev za ulazak u kritičnu
 sekciju, a pre nego što se taj zahtev odobri.
\end_layout

\begin_layout Standard
Pretpostavićemo da se svaki proces izvršava nekom brzinom većom od nule,
 ali ne možemo pretpostaviti ništa u vezi relativne brzine svih procesa
 koji se izvršavaju.
\end_layout

\begin_layout Standard
U određenom trenutku u sistemu može da bude aktivno mnogo procesa u jezgru.
 Usled toga kôd jezgra operativnog sistema može da se nađe u stanju trke.
 Kao primer, zamislimo strukturu jezgra koja održava listu svih otvorenih
 datoteka u sistemu.
 Ta lista mora da se ažurira kada se nova datoteka otvori ili zatvori, i
 to dodavanjem elemenata u listu ili uklanjanjem elemenata iz nje.
 Ako bi se desilo da dva procesa istovremeno otvaraju datoteku, posebna
 ažuriranja liste prouzrokovala bi stanje trke.
 Zbog toga projektanti operativnog sistema moraju da obezbede da se to ne
 desi.
\end_layout

\begin_layout Standard
Obratite pažnju da se u operativnim sistemima koji ne primenjuju prinudnu
 suspenziju procesa (non preemptive) stanje trke ne može da se pojavi, jer
 se svaki proces izvršava do kraja, kada dobrovoljno predaje kontrolu procesoru.
 Stanje trke aktuelno je samo u operativnim sistemima sa prinudnom suspenzijom
 procesa (prremptive), koji se moraju pažljivo projektovati.
 Jezgra sa prinudnom suspenzijom procesa omogućuju programiranje u realnom
 vremenu i odziv im je mnogo kraći jer procesi jezgra po pravilu ne mogu
 da se izvršavaju toliko dugo da bi drugi procesi dugo čekali.
 Na primer, Windows XP koristi jezgro bez prinudne suspenzije, dok Solaris
 i Linux (od verzije jezgra 2.6) primenjuju prinudnu suspenziju procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!prinudna suspenzija
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Petersonovo rešenje problema kritične sekcije
\end_layout

\begin_layout Standard
Ovo klasično rešenje
\begin_inset Index idx
status open

\begin_layout Plain Layout
kritična sekcija!Petersonovo rešenje
\end_layout

\end_inset

 je dobro za razumevanje složenosti problema i ograničeno je na dva procesa
 koji naizmenično izvršavaju svoje kritične sekcije i preostale sekcije.
 Rešenje zahteva korišćenje dve promenljive:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int red;
\end_layout

\begin_layout Standard

\family typewriter
\size small
bool fleg[2];
\end_layout

\begin_layout Standard
Promenljiva 
\family typewriter
red
\family default
 označava čiji je red da uđe u kritičnu sekciju, odnosno 
\family typewriter
\size small
red == i
\family default
\size default
 znači da proces 
\family typewriter
\size small
Pi
\family default
\size default
 ulazi u svoju kritičnu sekciju.
 Niz 
\family typewriter
\size small
fleg
\family default
\size default
 koristi se za označavanje da je proces preman da uđe u kritičnu sekciju,
 odnosno ako je 
\family typewriter
\size small
fleg[i]==true
\family default
\size default
, to znači da je proces 
\family typewriter
\size small
Pi
\family default
\size default
 spreman da uđe u kritičnu sekciju.
 Petersonovo rešenje se može predstaviti sledećim pseudokodom:
\end_layout

\begin_layout LyX-Code

\size small
do {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
fleg[i] = true;
\end_layout

\begin_layout LyX-Code

\size small
red = j;
\end_layout

\begin_layout LyX-Code

\size small
while(fleg[i] && red == j);
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
\size small
kritična sekcija
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
fleg[i] = false;
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
\size small
preostala sekcija
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
} while(true);
\end_layout

\begin_layout Standard
Da bi ušao u kritičnu sekciju, proces 
\family typewriter
\size small
Pi
\family default
\size default
 prvo postavlja 
\family typewriter
\size small
fleg[i]
\family default
\size default
 na 
\family typewriter
\size small
true
\family default
\size default
, a zatim postavlja red na 
\family typewriter
\size small
j
\family default
\size default
, čime stavlja do znanja drugim procesima da mogu da zahtevaju ulazak u
 kritičnu sekciju.
 Ako dva procesa Pi i Pj pokušaju da uđu u kritičnu sekciju približno u
 isto vreme, onda će promenljiva 
\family typewriter
red
\family default
 biti postavljena na 
\family typewriter
i
\family default
 i na
\family typewriter
 j
\family default
 približno istovremeno.
 Samo jedna od te dve dodele će potrajati, dok će druga biti odmah pprepisana.
 Konačna vrednost promenljive 
\family typewriter
red
\family default
 odrediće kojem će od ta dva procesa biti dozvoljeno da uđe u kritičnu sekciju.
\end_layout

\begin_layout Standard
Proces Pi može da uđe u svoju kritičnu sekciju samo ako je 
\family typewriter
\size small
fleg[j]==false
\family default
\size default
 ili je 
\family typewriter
\size small
red==i
\family default
\size default
.
 Takođe, ako dva procesa istovremeno izvršavaju svoje kritične sekcije,
 onda je 
\family typewriter
\size small
fleg[i]==fleg[j]==true
\family default
\size default
.
 Iz prethodnog sledi da oba procesa nisu mogla uspešno da izvrše 
\family typewriter
while
\family default
 naredbu približno istovremeno jer vrednost promenljive 
\family typewriter
red
\family default
 može da bude ili 
\family typewriter
\size small
i
\family default
\size default
, ili 
\family typewriter
\size small
j
\family default
\size default
.
 Dakle, jedan od procesa (na primer 
\family typewriter
\size small
Pj
\family default
\size default
) je uspešno izvršio naredbu 
\family typewriter
while
\family default
, a 
\family typewriter
\size small
Pi
\family default
\size default
 je morao da izvrši barem još jednu naredbu (
\family typewriter
\size small
red=j
\family default
\size default
).
 Pošto su u tom trenutku 
\family typewriter
\size small
fleg[j]==true
\family default
\size default
 i 
\family typewriter
\size small
red==j
\family default
\size default
, ovaj uslov će važiti sve dok je 
\family typewriter
\size small
Pj
\family default
\size default
 u svojoj kritičnoj sekciji.
 To znači da važi međusobno isključenje.
\end_layout

\begin_layout Standard
Razmotrimo sada druga dva uslova koja mora da zadovolji rešenje za problem
 kritične sekcije.
 Proces 
\family typewriter
\size small
Pi
\family default
\size default
 može da se spreči da uđe u kritičnu sekciju samo ako je 
\begin_inset Quotes eld
\end_inset

zaglavljen
\begin_inset Quotes erd
\end_inset

 u 
\family typewriter
while
\family default
 petlji sa uslovima f
\family typewriter
\size small
leg[j]==true
\family default
\size default
 i 
\family typewriter
\size small
red==j
\family default
\size default
.
 Ako 
\family typewriter
\size small
Pj
\family default
\size default
 nije spreman da uđe u kritičnu sekciju, onda je 
\family typewriter
\size small
fleg[j]==false
\family default
\size default
, pa 
\family typewriter
\size small
Pi
\family default
\size default
 ulazi u kritičnu sekciju.
 Ako je 
\family typewriter
\size small
Pj
\family default
\size default
 postavio 
\family typewriter
\size small
fleg[j]
\family default
\size default
 na 
\family typewriter
true
\family default
 i izvršava se u svojoj 
\family typewriter
while
\family default
 petlji, onda je 
\family typewriter
\size small
red==i
\family default
\size default
 ili 
\family typewriter
\size small
red==j
\family default
\size default
.
 Ako je 
\family typewriter
\size small
red==i
\family default
\size default
, onda će 
\family typewriter
\size small
Pi
\family default
\size default
 ući u kritičnu sekciju.
 Međutim, kada 
\family typewriter
\size small
Pj
\family default
\size default
 izađe iz svoje kritične sekcije, postaviće 
\family typewriter
\size small
fleg[j]
\family default
\size default
 na 
\family typewriter
\size small
false
\family default
\size default
, što će procesu 
\family typewriter
\size small
Pi
\family default
\size default
 omogućiti da uđe u kritičnu sekciju.
 Ako 
\family typewriter
\size small
Pj
\family default
\size default
 resetuje 
\family typewriter
\size small
fleg[j]
\family default
\size default
 na 
\family typewriter
\size small
true
\family default
\size default
, mora i da postavi 
\family typewriter
\size small
red
\family default
\size default
 na 
\family typewriter
\size small
i
\family default
\size default
.
 Tako, pošto 
\family typewriter
\size small
Pi
\family default
\size default
 ne menja vrednost promenljive
\family typewriter
\size small
 red
\family default
\size default
 dok izvršava naredbu while, 
\family typewriter
\size small
Pi
\family default
\size default
 će ući u kritičnu sekciju nakon najviše jednog prolaska 
\family typewriter
\size small
Pj
\family default
\size default
 kroz kritičnu sekciju.
\end_layout

\begin_layout Section
Zaključavanje
\end_layout

\begin_layout Standard
Bilo koje rešenje problema kritične sekcije zahteva jednostavnu alatku koja
 se zove
\begin_inset Index idx
status open

\begin_layout Plain Layout
brava
\end_layout

\end_inset

 
\series bold
brava
\series default
 (lock).
 Stanje trke se sprečava tako što se zahteva da kritične sekcije budu zaštićene
 bravom.
 Proces mora da dobije bravu pre ulaska u kritičnu sekciju da bi je zaključao
\begin_inset Index idx
status open

\begin_layout Plain Layout
kritična sekcija!zaključavanje
\end_layout

\end_inset

, a oslobađa bravu kada izađe iz nje.
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
do {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
zaključavanje brave
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
\size small
kritična sekcija
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
otključavanje brave 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
\size small
preostala sekcija
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
} while(true);
\end_layout

\begin_layout Standard
Postoje različita rešenja za problem kritične sekcije koja koriste zaključavanje
; neka su softverska, a neka hardverska.
 U nastavku ćemo proučiti neka od njih.
\end_layout

\begin_layout Standard
Mnogi moderni računarski sistemi imaju specijalne hardverske instrukcije
 koje omogućuju korisnicima da promene jednu reč ili da zamene dve reči
 na nedeljiv
\begin_inset Index idx
status open

\begin_layout Plain Layout
nedeljivo izvršavanje instrukcija
\end_layout

\end_inset

 (atomic) način, odnosno u jednom nedeljivom koraku.
 Te specijalne instrukcije mogu se koristiti za rešavanje problema kritične
 sekcije na relativno jednostavan način.
 Kao primer, razmotrimo instrukciju 
\family typewriter
\size small
swap()
\family default
\size default
 koja nedeljivo zamenjuje sadržaj dve reči:
\end_layout

\begin_layout LyX-Code

\size small
do {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
ključ = true;
\end_layout

\begin_layout LyX-Code

\size small
while(ključ == true)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
swap(brava, ključ);
\end_layout

\begin_layout LyX-Code

\series bold
\size small
kriticna sekcija
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
brava = false;
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
\size small
preostala sekcija
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
} while(true);
\end_layout

\begin_layout Standard
Ako računar podržava instrukciju 
\family typewriter
\size small
swap()
\family default
\size default
, onda se međusobno isključenje procesa može postići na sledeći način.
 Deklariše se globalna logička promenljiva 
\family typewriter
\size small
brava
\family default
\size default
 koja se inicijalizuje na 
\family typewriter
\size small
false
\family default
\size default
.
 Osim toga, svaki proces ima lokalnu logičku promenljivu 
\family typewriter
\size small
ključ
\family default
\size default
.
 Treba ipak obratiti pažnju da ovo rešenje zadovoljava uslov međusobnog
 isključenja, ali ne zadovoljava uslov ograničenog čekanja na ulazak u kritičnu
 sekciju.
\end_layout

\begin_layout Section
Semafori
\end_layout

\begin_layout Standard
Hardverska rešenja problema kritične sekcije kao što su nedeljive instrukcije
 programerima su prilično teška za korišćenje.
 Da bi se taj problem prevazišao, koristi se tehnika
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori
\end_layout

\end_inset

 
\series bold
semafora
\series default
 (semaphore).
\end_layout

\begin_layout Standard
Semafor 
\family typewriter
\size small
S
\family default
\size default
 je celobrojna promenljiva kojoj se, osim inicijalizacije, pristupa samo
 preko dve nedeljive (atomic) operacije: 
\family typewriter
\size small
wait()
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori!operacija wait()
\end_layout

\end_inset


\family default
\size default
 i 
\family typewriter
\size small
signal()
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori!operacija signal()
\end_layout

\end_inset


\family default
\size default
.
 Operacija 
\family typewriter
\size small
wait()
\family default
\size default
 se definiše kao:
\end_layout

\begin_layout LyX-Code

\size small
wait(S) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
while S <= 0; //ne radi ništa
\end_layout

\begin_layout LyX-Code

\size small
S--;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
a operacija 
\family typewriter
\size small
signal()
\family default
\size default
 kao:
\end_layout

\begin_layout LyX-Code

\size small
signal(S) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
S++;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Svaka promena celobrojne vrednosti semafora mora da se obavi nedeljivo,
 odnosno kada jedan proces menja vrednost semafora, nijedan drugi proces
 ne sme istovremeno da je menja.
 Takođe, testiranje celobrojne vrednosti semafora u operaciji 
\family typewriter
\size small
wait() 
\family default
\size default
i njegovo eventualno menjanje (
\family typewriter
\size small
S--
\family default
\size default
) moraju da se obave nedeljivo.
 
\end_layout

\begin_layout Standard
Operativni sistemi razlikuju 
\series bold
brojačke semafore
\series default
 (counting semaphores
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori!brojački
\end_layout

\end_inset

) i 
\series bold
binarne semafore
\series default
 (binary semaphore
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori!binarni
\end_layout

\end_inset

).
 Vrednost brojačkog semafora može da bude proizvoljna pozitivna vrednost,
 dok vrednost binarnog semafora može da bude 0 ili 1.
 U nekim sistemima binarni semafori se zovu 
\series bold
muteksi
\series default
 (mutex
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori!muteks
\end_layout

\end_inset

), jer omogućuju međusobno isključivanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
međusobno isključivanje!muteks
\end_layout

\end_inset

 (
\series bold
mut
\series default
ual 
\series bold
ex
\series default
clusion).
\end_layout

\begin_layout Standard
Binarni semafori mogu se iskoristiti za rešavanje problema kritične sekcije
 za više procesa.
 Pretpostavimo da n procesa deli semafor, 
\family typewriter
mutex
\family default
, inicijalizovan na 1; rešenje problema je sledeće:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
do{
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
wait(mutex);
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
kritična sekcija
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
signal(mutex);
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
preostala sekcija;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
} while(true);
\end_layout

\begin_layout Standard
Semafore možemo da iskoristimo i za rešavanje drugih problema sinhronizacije.
 Na primer, pretpostavimo da proces 
\family typewriter
\size small
P1
\family default
\size default
 izvršava naredbu 
\family typewriter
\size small
S1
\family default
\size default
, a proces 
\family typewriter
\size small
P2
\family default
\size default
 naredbu 
\family typewriter
\size small
S2
\family default
\size default
, i da je zahtev da se naredba 
\family typewriter
\size small
S2
\family default
\size default
 izvrši tek pošto se izvrši naredba 
\family typewriter
\size small
S1
\family default
\size default
.
 Problem se može rešiti tako što će 
\family typewriter
\size small
P1
\family default
\size default
 i 
\family typewriter
\size small
P2
\family default
\size default
 deliti semafor
\family typewriter
\size small
 synch
\family default
\size default
 koji će biti inicijalizovan na nula.
 U proces 
\family typewriter
\size small
P1
\family default
\size default
 će biti dodata naredba:
\end_layout

\begin_layout Standard

\family typewriter
\size small
S1;
\end_layout

\begin_layout Standard

\family typewriter
\size small
signal(synch);
\end_layout

\begin_layout Standard
a u proces 
\family typewriter
\size small
P2
\family default
\size default
:
\end_layout

\begin_layout Standard

\family typewriter
\size small
wait(synch);
\end_layout

\begin_layout Standard

\family typewriter
\size small
S2;
\end_layout

\begin_layout Standard
Pošto je 
\family typewriter
\size small
synch
\family default
\size default
 inicijalizovan na 0, 
\family typewriter
\size small
P2
\family default
\size default
 će izvršiti naredbu 
\family typewriter
\size small
S2
\family default
\size default
 tek nakon što 
\family typewriter
\size small
P1
\family default
\size default
 pozove 
\family typewriter
\size small
signal(synch)
\family default
\size default
, a to će se desiti tek pošto se izvrši naredba 
\family typewriter
\size small
S1
\family default
\size default
.
\end_layout

\begin_layout Standard
Najvažniji nedostatak implementacije semafora koju smo upravo opisali jeste
 to što zahteva 
\begin_inset Quotes eld
\end_inset

uposleno čekanje
\begin_inset Quotes erd
\end_inset

 (busy waiting).
 Dok je proces u svojoj kritičnoj sekciji, drugi procesi koji pokušavaju
 da uđu u kritičnu sekciju moraju da se 
\begin_inset Quotes eld
\end_inset

vrte
\begin_inset Quotes erd
\end_inset

 u svojim ulaznim sekcijama.
 Očigledno je da to može prouzrokovati problem u stvarnim multiprogramskim
 sistemima u kojima se procesor deli između brojnih procesa.
 Zaposleno čekanje troši procesorske cikluse koje bi neki drugi procesi
 mogli efikasno da iskoriste.
 Vrsta semafora
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori!spinlok
\end_layout

\end_inset

 koju smo upravo opisali zove se 
\series bold
spinlok
\series default
 jer se proces 
\begin_inset Quotes eld
\end_inset

vrti
\begin_inset Quotes erd
\end_inset

 (spins) dok čeka da dobije bravu (lock).
 Spinlok semafori su korisni kada se očekuje da će zaključavanje kritične
 sekcije trajati kratko i često se primenjuju u multiprocesorskim sistemima
 u kojima jedna nit može da se 
\begin_inset Quotes eld
\end_inset

vrti
\begin_inset Quotes erd
\end_inset

 na jednom procesoru, dok druga nit izvršava kritičnu sekciju na drugom
 procesoru.
\end_layout

\begin_layout Standard
Da bi se prevazišla potreba za 
\begin_inset Quotes eld
\end_inset

uposlenim čekanjem
\begin_inset Quotes erd
\end_inset

, može se promeniti definicija semaforskih operacija 
\family typewriter
\size small
wait()
\family default
\size default
 i 
\family typewriter
\size small
signal()
\family default
\size default
.
 Kada proces izvrši operaciju 
\family typewriter
\size small
wait()
\family default
\size default
 i ustanovi da vrednost semafora nije pozitivna, mora da čeka.
 Međutim, umesto da 
\begin_inset Quotes eld
\end_inset

uposleno čeka
\begin_inset Quotes erd
\end_inset

, može sam sebe da blokira i da se premesti u red čekanja povezan sa semaforom,
 pri čemu stanje procesa postaje 
\shape italic
Waiting
\shape default
.
 Kontrola se zatim prepušta raspoređivaču procesa, koji bira sledeći proces
 koji će biti izvršen.
\end_layout

\begin_layout Standard
Proces koji je blokiran u čekanju na semafor 
\family typewriter
\size small
S
\family default
\size default
 treba da se vrati na izvršavanje kada neki drugi proces obavi operaciju
 
\family typewriter
\size small
signal()
\family default
\size default
.
 Proces se 
\begin_inset Quotes eld
\end_inset

budi
\begin_inset Quotes erd
\end_inset

 operacijom 
\family typewriter
\size small
wakeup()
\family default
\size default
 koja menja stanje procesa iz 
\shape italic
Waiting
\shape default
 u 
\shape italic
Ready
\shape default
.
 Nakon toga proces se premešta u red spremnih poslova.
 Pri tom procesor može ali i ne mora da prekine izvršavanje tekućeg procesa,
 u zavisnosti od toga kako je implementirano raspoređivanje procesa.
\end_layout

\begin_layout Standard
Da bismo impelementirali semafore
\begin_inset Index idx
status open

\begin_layout Plain Layout
spinlok
\end_layout

\end_inset

 po ovoj definiciji, definisaćemo ih kao C strukturu (Dodatak A):
\end_layout

\begin_layout LyX-Code

\size small
typedef struct {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int value;
\end_layout

\begin_layout LyX-Code

\size small
struct process *list;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} semaphore;
\end_layout

\begin_layout Standard
Svaki semafor ima celobrojnu vrednost 
\family typewriter
\size small
value
\family default
\size default
 i listu procesa 
\family typewriter
\size small
list
\family default
\size default
.
 Kada proces mora da čeka na semafor, on se dodaje u listu procesa.
 Operacija 
\family typewriter
\size small
signal()
\family default
\size default
 uklanja jedan proces iz liste procesa koji čekaju na semafor i 
\begin_inset Quotes eld
\end_inset

budi
\begin_inset Quotes erd
\end_inset

 ga.
\end_layout

\begin_layout Standard
Semaforska operacija 
\family typewriter
\size small
wait()
\family default
\size default
 sada se može definisati kao:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
wait(semaphore *s) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
s->value--;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
if(s->value < 0) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
dodaj ovaj proces u s->list;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
block();
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
}
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
}
\end_layout

\begin_layout Standard
Operacija 
\family typewriter
\size small
signal()
\family default
\size default
 definiše se kao:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
signal(semaphore *s) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
s->value++;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
if(s->value <=0) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
ukloni proces iz s->list;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
wakeup(proces);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
}
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
}
\end_layout

\begin_layout Standard
Operacija 
\family typewriter
\size small
block()
\family default
\size default
 suspenduje proces koji je poziva, a operacija 
\family typewriter
\size small
wakeup(p)
\family default
\size default
 nastavlja izvršavanje blokiranog procesa p.
 Ove dve funkcije operativni sistem obezbeđuje u vidu sistemskih poziva.
\end_layout

\begin_layout Standard
Postavlja se pitanje po kom redosledu se procesi uklanjaju iz reda čekanja
 na semafor.
 Najpravednija je FIFO (first-in-first-out) politika, u kojoj se proces
 koji je najduže bio blokiran prvi oslobađa iz reda.
 Semafori koji primenjuju takvu politiku zovu se 
\series bold
jaki semafori
\series default
 (strong semaphore
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori!jaki
\end_layout

\end_inset

), za razliku od 
\series bold
slabih semafora
\series default
 (weak semaphore
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori!jaki
\end_layout

\end_inset

) koji ne zadaju redosled kojim se procesi uklanjaju iz reda.
 Slika 5.1 ilustruje način rada jakog semafora.
 Procesi A, B i C zavise od rezultata procesa D.
 U početku se izvršava proces A, procesi B, C i D su u stanju 
\shape italic
Ready
\shape default
, a semafor ima vrednost 1, što znači da je dostupan jedan rezultat semafora
 D.
 Kada proces A izvrši operaciju 
\family typewriter
\size small
wait()
\family default
\size default
 na semaforu
\family typewriter
 s
\family default
, on se dekrementira tako da mu je vrednost 0, pa proces A može da nastavi
 da se izvršava, da bi na kraju ponovo stigao u red spremnih procesa.
 Zatim se izvršava proces B koji izdaje naredbu 
\family typewriter
\size small
wait()
\family default
\size default
 i blokira se, dozvoljavajući izvršavanje procesa D.
 Kada D izda nov rezultat, izvršava operaciju 
\family typewriter
\size small
signal()
\family default
\size default
 koja omogućuje procesu B da se premesti u red spremnih poslova.
 D ponovo stiže u red spremnih poslova i proces C počinje da se izvršava,
 ali se blokira kada obavi operaciju 
\family typewriter
\size small
wait()
\family default
\size default
.
 Slično, procesi A i B čekaju na semafor, dozvoljavajući procesu D da nastavi
 izvršavanje.
 Kada D izda rezultat, obavlja operaciju 
\family typewriter
\size small
signal()
\family default
\size default
 koja prevodi proces C u red spremnih poslova.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Semafori.PNG
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 5.1: Primer mehanizma semafora.
\end_layout

\begin_layout Section
Monitori
\end_layout

\begin_layout Standard
Iako su semafori
\begin_inset Index idx
status open

\begin_layout Plain Layout
monitori
\end_layout

\end_inset

 efikasan i koristan način za sinhronizaciju procesa, njihovo neispravno
 korišćenje može da prouzrokuje greške u vremenu izvršavanja koje se teško
 otkrivaju jer se dešavaju samo u slučajevima tačno određene sekvence izvršavanj
a instrukcija.
 Ponovo ćemo se vratiti na problem kritične sekcije, u kome svi procesi
 dele semafor 
\family typewriter
\size small
mutex
\family default
\size default
 inicijalizovan na 1.
 Svaki proces mora da izvrši operaciju 
\family typewriter
\size small
wait(mutex)
\family default
\size default
 pre nego što uđe u kritičnu sekciju
\begin_inset Index idx
status open

\begin_layout Plain Layout
kritična sekcija!monitori
\end_layout

\end_inset

, odnosno 
\family typewriter
\size small
signal(mutex)
\family default
\size default
 kada izađe iz nje.
 Ako se taj sled pozivanja ne poštuje, može se desiti da se dva procesa
 istovremeno nađu u kritičnoj sekciji.
 Na primer, pretpostavimo da proces izmeni redosled pozivanja operacija
 
\family typewriter
\size small
wait()
\family default
\size default
 i 
\family typewriter
\size small
signal()
\family default
\size default
 za semafor 
\family typewriter
\size small
mutex()
\family default
\size default
, na sledeći način:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
signal(mutex);
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
kritična sekcija
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
wait(mutex);
\end_layout

\begin_layout Standard
U ovom slučaju nekoliko procesa može da se nađe istovremeno u kritičnoj
 sekciji, čime je narušen princip međusobnog isključenja.
 Ova greška se može otkriti jedino ako je nekoliko procesa istovremeno aktivno
 u kritičnoj sekciji, ali takva situacija ponekad se ne može lako izazvati.
\end_layout

\begin_layout Standard
Zatim, pretpostavimo da proces zameni 
\family typewriter
\size small
signal(mutex)
\family default
\size default
 sa 
\family typewriter
\size small
wait(mutex)
\family default
\size default
, odnosno:
\end_layout

\begin_layout LyX-Code

\size small
wait(mutex);
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
kritična sekcija
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
wait(mutex);
\end_layout

\begin_layout Standard
U ovom slučaju, desiće se potpuni zastoj, odnosno nijedan proces neće moći
 da uđe u kritičnu sekciju.
\end_layout

\begin_layout Standard
Treće, pretpostavimo da proces 
\begin_inset Quotes eld
\end_inset

zaboravi
\begin_inset Quotes erd
\end_inset

 da pozove 
\family typewriter
\size small
wait(mutex)
\family default
\size default
 ili 
\family typewriter
\size small
signal(mutex)
\family default
\size default
, ili obe funkcije.
 U tom slučaju može biti narušen princip međusobnog isključenja, a može
 se pojaviti i potpuni zastoj.
\end_layout

\begin_layout Standard
Prethodni primeri ilustruju da je veoma lako pogrešno upotrebiti semafore,
 što prouzrokuje greške u sinhronizaciji.
 Zbog toga su u višim programskim jezicima razvijene konstrukcije poput
 
\series bold
monitora
\series default
 čija je sintaksa:
\end_layout

\begin_layout LyX-Code

\size small
monitor ime_monitora {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//deklaracije deljenih promenljivih
\end_layout

\begin_layout LyX-Code

\size small
procedura P1(...) { ...}
\end_layout

\begin_layout LyX-Code

\size small
procedura P2(...) {...}
\end_layout

\begin_layout LyX-Code

\size small
.
\end_layout

\begin_layout LyX-Code

\size small
.
\end_layout

\begin_layout LyX-Code

\size small
.
\end_layout

\begin_layout LyX-Code

\size small
procedura Pn(...) {...}
\end_layout

\begin_layout LyX-Code

\size small
inicijalizacioni kôd(...) {...}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Konstrukcija monitora obezbeđuje da unutar monitora u određenom trenutku
 bude aktivan samo jedan proces.
 Procedura definisana unutar monitora može da pristupi samo promenljivama
 koje su deklarisane lokalno, unutar monitora, kao i svojim parametrima.
 Da bi se rešio problem sinhronizacije, monitoru se moraju dodati definicije
 promenljivih tipa uslova:
\end_layout

\begin_layout Standard

\family typewriter
\size small
uslov x, y;
\end_layout

\begin_layout Standard
Jedine operacije koje se mogu primenjivati na uslovne promenljive su 
\family typewriter
\size small
wait()
\family default
\size default
 i 
\family typewriter
\size small
signal()
\family default
\size default
.
 Operacija 
\family typewriter
\size small
x.wait()
\family default
\size default
 znači da će proces koji je poziva biti suspendovan dok neki drugi proces
 ne pozove 
\family typewriter
\size small
x.signal()
\family default
\size default
.
 Operacija 
\family typewriter
\size small
signal()
\family default
\size default
 nastavlja izvršavanje samo jednog procesa.
 Ako nijedan proces nije suspendovan, onda pozivanje operacije 
\family typewriter
\size small
signal()
\family default
\size default
 nema nikakvog efekta, odnosno stanje uslovne promenljive 
\family typewriter
\size small
x
\family default
\size default
 je isto kao da operacija nikada nije bila izvršena.
 Primetite razliku u odnosu na operaciju 
\family typewriter
\size small
signal()
\family default
\size default
 za semafore, koja uvek utiče na stanje semafora.
\end_layout

\begin_layout Standard
Pretpostavimo sada da je operaciju 
\family typewriter
\size small
x.signal()
\family default
\size default
 pozvao proces P1, i da postoji suspendovan proces P2 povezan sa uslovom
 
\family typewriter
\size small
x
\family default
\size default
.
 Ako se suspendovanom procesu P2 dozvoli da nastavi izvršavanje, proces
 P1 koji šalje signal mora da čeka.
 U suprotnom bi procesi P1 i P2 bili istovremeno aktivni unutar monitora.
 Međutim, oba procesa nastavljaju da se izvršavaju, pri čemu postoje dve
 mogućnosti:
\end_layout

\begin_layout Standard
1.
 
\shape italic
Signaliziraj i čekaj.

\shape default
 P1 ili čeka dok P2 izađe iz monitora ili čeka neki drugi uslov.
\end_layout

\begin_layout Standard
2.
 
\shape italic
Signaliziraj i nastavi.

\shape default
 P2 čeka dok P1 ne izađe iz monitora ili čeka drugi uslov.
\end_layout

\begin_layout Subsection
Implementacija monitora pomoću semafora
\end_layout

\begin_layout Standard
Za svaki monitor
\begin_inset Index idx
status open

\begin_layout Plain Layout
monitori!implementacija pomoću semafora
\end_layout

\end_inset

 uvodi se semafor 
\family typewriter
\size small
mutex
\family default
\size default
 i inicijalizuje na 1.
 Proces mora da izvrši 
\family typewriter
\size small
wait(mutex)
\family default
\size default
 pre nego što uđe u monitor, a kada izađe iz njega, mora da izvrši 
\family typewriter
\size small
signal(mutex)
\family default
\size default
.
\end_layout

\begin_layout Standard
Pošto proces koji signalizira mora da čeka da proces koji se nastavlja završi
 izvršavanje ili se blokira, uvodi se dodatni semafor 
\family typewriter
next
\family default
 i inicijalizuje na 0; njega će koristiti procesi koji signaliziraju da
 bi sami sebe suspendovali.
 Celobrojna promenljiva 
\family typewriter
\size small
next_count
\family default
\size default
 broji suspendovane procese za 
\family typewriter
next
\family default
.
 Svaka spoljašnja procedura P se zamenjuje sa:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
wait(mutex);
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
telo P
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
if(next_count > 0)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
signal(next);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
else
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
signal(mutex);
\end_layout

\end_deeper
\begin_layout Standard
Međusobno isključenje unutar monitora je obezbeđeno.
\end_layout

\begin_layout Standard
Sada ćemo opisati kako se implementiraju uslovne promenljive.
 Za svaki uslov 
\family typewriter
\size small
x
\family default
\size default
 uvode se semafor 
\family typewriter
\size small
x_sem
\family default
\size default
 i celobrojna promenljiva 
\family typewriter
\size small
x_count
\family default
\size default
 i inicijalizuju se na 0.
 Operacija 
\family typewriter
\size small
x.wait()
\family default
\size default
 se implementira kao:
\end_layout

\begin_layout LyX-Code

\size small
x_count++;
\end_layout

\begin_layout LyX-Code

\size small
if(next_count > 0)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
signal(next);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
signal(mutex);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
wait(x_sem);
\end_layout

\begin_layout LyX-Code

\size small
x_count--;
\end_layout

\begin_layout Standard
Operacija 
\family typewriter
\size small
x.signal() 
\family default
\size default
se implementira kao:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
if(x_count > 0) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
next_count++;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
signal(x_sem);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
wait(next);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
next_count--;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
}
\end_layout

\begin_layout Section
Klasični problemi sinhronizacije
\end_layout

\begin_layout Standard
U ovom odeljku predstavićemo nekoliko problema koji se koriste za proveru
 gotovo svih novih algoritama za sinhronizaciju
\begin_inset Index idx
status open

\begin_layout Plain Layout
sinhronizacija!klasični problemi
\end_layout

\end_inset

.
 U rešenjima za opisane probleme koristićemo semafore za sinhronizaciju.
\end_layout

\begin_layout Subsection
Problem proizvođača i potrošača
\end_layout

\begin_layout Standard
Jedan od najčešćih problema u konkurentnoj obradi je problem proizvođača
 i potrošača
\begin_inset Index idx
status open

\begin_layout Plain Layout
sinhronizacija!problem proizvođača i potrošača
\end_layout

\end_inset

 (producer/consumer).
 Ovaj problem se javlja kada ima nekoliko proizvođača koji smeštaju neku
 vrstu podataka (zapise, znakove) u bafer.
 Sa druge strane postoji jedan potrošač koji podatke čita iz bafera redom,
 jedan po jedan.
 Sistem mora da obezbedi preklapanje operacija sa baferom, odnosno u istom
 trenutku baferu može da pristupi ili proizvođač, ili potrošač.
 
\end_layout

\begin_layout Standard
Za početak, pretpostavimo da je bafer neograničen i da se sastoji od linearnog
 niza elemenata.
 Funkcije proizvođača i potrošača možemo da definišemo na sledeći način:
\end_layout

\begin_layout Standard
proizvođač:
\end_layout

\begin_layout LyX-Code

\size small
while(true) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//proizvodi stavku v
\end_layout

\begin_layout LyX-Code

\size small
b[in]=v;
\end_layout

\begin_layout LyX-Code

\size small
in++;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
potrošač:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
while(true) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
while(in < out) ne radi ništa;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
w = b[out];
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
out++;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
//troši stavku w
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
}
\end_layout

\begin_layout Standard
Proizvođač generiše podatke i smešta ih u bafer 
\family typewriter
\size small
b
\family default
\size default
 svojim tempom.
 Kad god doda stavku, inkrementira se indeks 
\family typewriter
\size small
in
\family default
\size default
 bafera.
 Potrošač slično tome čita podatke iz bafera, ali mora da proveri da bafer
 slučajno nije prazan (
\family typewriter
\size small
in > out
\family default
\size default
).
 
\end_layout

\begin_layout Standard
Implementiraćemo ovaj sistem pomoću binarnih semafora.
 Semafor 
\family typewriter
\size small
mutex
\family default
\size default
 se koristi za međusobno isključivanje (tj.
 onemogućavanje istovremenog pristupa baferu), semafor 
\family typewriter
\size small
empty
\family default
\size default
 primorava potrošača da stane kada je bafer prazan, a semafor 
\family typewriter
\size small
full
\family default
\size default
 označava da je bafer pun.
\end_layout

\begin_layout Standard
proizvođač:
\end_layout

\begin_layout LyX-Code

\size small
do {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
produce();
\end_layout

\begin_layout LyX-Code

\size small
wait(empty);
\end_layout

\begin_layout LyX-Code

\size small
wait(mutex);
\end_layout

\begin_layout LyX-Code

\size small
...
\end_layout

\begin_layout LyX-Code

\size small
signal(mutex);
\end_layout

\begin_layout LyX-Code

\size small
signal(full);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} while(true);
\end_layout

\begin_layout Standard
potrošač:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
do {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
wait(full);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
wait(mutex);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
signal(mutex);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
signal(empty);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
consume();
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
} while(true);
\end_layout

\begin_layout Subsection
Problem čitača i pisača
\end_layout

\begin_layout Standard
Podaci se mogu deliti između nekoliko konkurentnih procesa.
 Neki od tih procesa će ih samo čitati, a neki će ih i čitati i menjati
 (upisivati).
 Te dve vrste procesa zvaćemo čitači i pisači.
 Ako dva čitača istovremeno pristupaju istom podatku, očigledno je da se
 neće desiti ništa; međutim, ako pisač
\begin_inset Index idx
status open

\begin_layout Plain Layout
sinhronizacija!problem čitača i pisača
\end_layout

\end_inset

 i neki drugi proces (čitač ili pisač) istovremeno pristupaju podatku, može
 nastati problem.
\end_layout

\begin_layout Standard
Da bi se problem izbegao, zahteva se da pisači imaju isključiv pristup deljenim
 podacima.
 Postoji nekoliko varijacija na temu problema čitača i pisača; ovde ćemo
 predstaviti rešenje za problem u kome se zahteva da nijedan čitač ne čeka
 osim ako neki pisač nije već dobio dozvolu da koristi deljene podatke.
 
\end_layout

\begin_layout Standard
Za čitače se uvode semafori 
\family typewriter
mutex
\family default
 i 
\family typewriter
write
\family default
 koji se inicijalizuju na 1, kao i celobrojna promenljiva 
\family typewriter
readcount
\family default
 koja se inicijalizuje na 0.
 Semafor 
\family typewriter
write
\family default
 je zajednički za čitače i pisače, a semafor 
\family typewriter
mutex
\family default
 se koristi da bi obezbedio međusobno isključenje prilikom ažuriranja promenljiv
e 
\family typewriter
readcount
\family default
.
 Promenljiva 
\family typewriter
readcount
\family default
 prati koliko ima procesa koji trenutno čitaju objekat.
 Semafor 
\family typewriter
write
\family default
 služi za međusobno isključenje pisača, a koriste ga i prvi ili poslednji
 čitač koji ulaze ili izlaze iz kritične sekcije.
 Ovaj semafor ne koriste čitači koji ulaze ili izlaze iz kritične sekcije
 dok se drugi čitači nalaze u kritičnim sekcijama.
\end_layout

\begin_layout Standard
pisač:
\end_layout

\begin_layout LyX-Code

\size small
do {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
wait(write);
\end_layout

\begin_layout LyX-Code

\size small
pisanje
\end_layout

\begin_layout LyX-Code

\size small
signal(write);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} while(true);
\end_layout

\begin_layout Standard
čitač:
\end_layout

\begin_layout LyX-Code

\size small
do {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
wait(mutex);
\end_layout

\begin_layout LyX-Code

\size small
readcount++;
\end_layout

\begin_layout LyX-Code

\size small
if(readcount == 1)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
wait(write);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
signal(mutex);
\end_layout

\begin_layout LyX-Code

\size small
citanje
\end_layout

\begin_layout LyX-Code

\size small
wait(mutex);
\end_layout

\begin_layout LyX-Code

\size small
readcount--;
\end_layout

\begin_layout LyX-Code

\size small
if(readcount == 0)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
signal(write);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
signal(mutex);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} while(true);
\end_layout

\begin_layout Standard
Primetite da ako je pisač u kritičnoj sekciji, a n čitača čeka, onda je
 jedan čitač u redu za 
\family typewriter
\size small
write
\family default
\size default
, a n-1 čitača su u redu za 
\family typewriter
\size small
mutex
\family default
\size default
.
 Takođe, kada pisač pozove 
\family typewriter
\size small
signal(write)
\family default
\size default
, može se nastaviti izvršavanje čitača koji čekaju, ili jednog pisača koji
 čeka.
 Ovaj izbor obavlja raspoređivač procesa.
\end_layout

\begin_layout Subsection
Problem filozofa za večerom
\end_layout

\begin_layout Standard
Zamislimo pet filozofa koji život provode razmišljajući i jedući.
 Oni sede za okruglim stolom sa pet stolica, po jedna za svakog filozofa
\begin_inset Index idx
status open

\begin_layout Plain Layout
sinhronizacija!problem filozofa za večerom
\end_layout

\end_inset

 (Slika 5.2).
 Na sredini stola nalazi se činija sa špagetama, a na stolu ima pet viljuški.
 Kada filozof misli, on ne komunicira sa svojim kolegama.
 S vremena na vreme filozof ogladni i pokušava da uhvati jednu od dve viljuške
 koje su mu najbliže.
 U svakom trenutku filozof može da podigne samo jednu viljušku.
 Kada gladan filozof ima obe viljuške istovremeno, on jede bez ispuštanja
 viljušaka.
 Kada završi sa jelom, filozof spušta viljuške i počinje ponovo da razmišlja.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Filozofi.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 5.2: Filozofi za večerom.
\end_layout

\begin_layout Standard
Predstavićemo rešenje za problem sinhronizacije filozofa koji večeraju pomoću
 semafora.
\end_layout

\begin_layout Standard
U rešenju sa semaforima svaka viljuška se predstavlja posebnim semaforom.
 Filozof pokušava da uzme viljušku tako što poziva operaciju 
\family typewriter
wait()
\family default
 za viljušku; kada spušta viljušku, poziva operaciju 
\family typewriter
signal()
\family default
 za odgovarajuće semafore.
 Prema tome, deljeni podaci su semafori 
\family typewriter
viljuška[0]
\family default
, 
\family typewriter
...
 viljuška[4]
\family default
 koji se inicijalizuju na 1.
 Struktura rešenja je sledeća:
\end_layout

\begin_layout LyX-Code

\size small
do {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
wait(viljuška[i];
\end_layout

\begin_layout LyX-Code

\size small
wait(viljuška[(i+1) % 5]);
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
jede();
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
signal(viljuška[i]);
\end_layout

\begin_layout LyX-Code

\size small
signal(viljuška[(i+1) % 5]);
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
misli();
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
} while(true);
\end_layout

\begin_layout Standard
Iako ovo rešenje garantuje da dva susedna filozofa neće jesti istovremeno,
 može da prouzrokuje potpuni zastoj.
 Pretpostavimo da svih pet filozofa ogladne u istom trenutku i da se svaki
 uhvati za levu viljušku.
 Tada će svi semafori imati vrednost 0.
 Ako svaki filozof pokuša da uzme desnu viljušku, to će biti odlagano unedogled.
 Problem potpunog zastoja rešava se primenom monitora.
 
\end_layout

\begin_layout Section
Potpuni zastoj
\end_layout

\begin_layout Standard
Potpuni zastoj
\begin_inset Index idx
status open

\begin_layout Plain Layout
potpuni zastoj
\end_layout

\end_inset

 (deadlock) dešava se kada se skup procesa takmiči za sistemske resurse
 ili međusobno komunicira.
 Procesi mogu da se nađu u potpunom zastoju (ili mrtvoj petlji) kada svakog
 od njih blokira neki događaj (npr.
 čekaju da se oslobodi neki sistemski resurs), a taj događaj zavisi od drugih
 blokiranih procesa u potpunom zastoju.
 Zastoj je potpun zato što nijedan od tih događaja ne može nikako da se
 desi.
 Za razliku od drugih problema upravljanja konkurentnim procesima, u opštem
 slučaju ne postoji efikasno rešenje za izbegavanje potpunog zastoja.
\end_layout

\begin_layout Standard
U svim slučajevima potpunog zastoja postoji nekoliko procesa čiji su zahtevi
 u sukobu.
 Uobičajen primer kojim se ilustruje potpuni zastoj je primer raskrsnice.
 Na Slici 5.3 je prikazan primer potpunog zastoja u saobraćaju, kada četiri
 automobila pristižu u raskrsnicu približno u isto vreme.
 Četiri kvadranta raskrsnice predstavljaju resurse nad kojima je potrebno
 ostvariti kontrolu.
 Praktično pravilo koje se primenjuje u raskrsnicama je da prednost ima
 vozilo koje se nalazi sa desne strane, ali ovo pravilo važi samo ako na
 raskrsnici ima maksimalno tri vozila.
 Međutim, ako četiri vozila pristignu u raskrsnicu približno u isto vreme,
 nijedno neće ući u raskrsnicu zato što ima vozilo sa desne strane, čime
 će se prouzrokovati potpuni zastoj.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Deadlock.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 5.3: Potpuni zastoj (deadlock) u saobraćaju.
\end_layout

\begin_layout Standard
U uobičajenom režimu korišćenja resursa, proces može da bude u nekoj od
 tri faze:
\end_layout

\begin_layout Itemize
Zahtev (request): proces zahteva resurs, a ako ne može da ga dobije, čeka
 da se on oslobodi.
\end_layout

\begin_layout Itemize
Korišćenje (use): proces je dobio resurs i koristi ga.
\end_layout

\begin_layout Itemize
Oslobađanje (release): proces oslobađa resurs pošto je završio sa korišćenjem.
\end_layout

\begin_layout Standard
Zamislimo situaciju sistema koji ima tri CD uređaja, koje su zauzela tri
 procesa.
 Ako bilo koji od tih procesa pokuša da dobije drugi CD uređaj, sva tri
 procesa će biti u stanju potpunog zastoja, jer svi čekaju da se ispuni
 uslov oslobađanja uređaja, koji može da ispuni samo neki od preostalih
 procesa koji čekaju.
 Potpuni zastoj se često javlja u višenitnim aplikacijama jer se više niti
 takmiči za iste resurse; zbog toga se višenitne aplikacije moraju pažljivo
 programirati.
\end_layout

\begin_layout Standard
Potpuni zastoj
\begin_inset Index idx
status open

\begin_layout Plain Layout
potpuni zastoj!uslovi
\end_layout

\end_inset

 se može definisati kao trajno blokiranje skupa procesa koji se takmiče
 za sistemske resurse.
 Zastoj nastupa ako su istovremeno ispunjeni sledeći uslovi:
\end_layout

\begin_layout Enumerate
međusobno isključenje (mutual exclusion): barem jedan resurs mora da bude
 u stanju u kome se ne može deliti, odnosno samo jedan proces može da koristi
 određeni resurs.
 Ako drugi proces zatraži isti resurs, dodela mora biti odložena sve dok
 se resurs ne oslobodi.
\end_layout

\begin_layout Enumerate
dobrovoljno oslobađanje resursa (no preemption): resurs može biti oslobođen
 samo ako ga dobrovoljno oslobodi proces kome je dodeljen.
\end_layout

\begin_layout Enumerate
zadržavanje resursa tokom čekanja (hold and wait): proces mora da ima barem
 jedan resurs dok čeka da mu se dodeli neki drugi resurs koji je trenutno
 dodeljen nekom drugom procesu
\end_layout

\begin_layout Enumerate
kružno čekanje (circular wait): postoji skup procesa P1, P2, ..., Pn takvih
 da proces P1 čeka na resurs koji drži proces P2, proces P2 čeka na resurs
 koji drži P3, i tako redom do procesa Pn koji čeka na resurs koji drži
 proces P0.
\end_layout

\begin_layout Subsection
Sprečavanje potpunog zastoja
\end_layout

\begin_layout Standard
Da bi se sprečio potpuni zastoj
\begin_inset Index idx
status open

\begin_layout Plain Layout
potpuni zastoj!sprečavanje
\end_layout

\end_inset

, dovoljno je da samo jedan od prethodno pomenuta četiri uslova ne važi.
 Razmotrićemo ih pojedinačno.
\end_layout

\begin_layout Enumerate
Međusobno isključenje: ovo je uslov koji se obično ne može izbeći.
 Ako je zahtev za resursima isključiv, onda on mora biti podržan u operativnom
 sistemu.
 Neki resursi, npr.
 datoteke, omogućuju neisključiv pristup tokom čitanja, ali isključiv tokom
 upisivanja.
 I u takvim slučajevima može se desiti potpuni zastoj ako više procesa traži
 dozvolu za upis u datoteku.
\end_layout

\begin_layout Enumerate
Zadržavanje resursa tokom čekanja: ovaj uslov može da se spreči tako što
 se zahteva da proces sve potrebne resurse zatraži u istom trenutku, tako
 da se drži blokiran sve do momenta kada svi resursi mogu da mu se dodele
 istovremeno.
 Ovakav prstup nije efikasan iz dva razloga.
 Prvo, može se desiti da proces dugo čeka da se oslobode svi potrebni resursi,
 kada bi možda mogao da obavi deo posla sa delom dostupnih resursa.
 Drugo, resursi dodeljeni procesu mogli bi dugo da ostanu neiskorišćeni,
 a za to vreme su uskraćeni drugim procesima.
 Takođe, ponekad proces ne može da zna unapred koji će mu resursi biti potrebni.
\end_layout

\begin_layout Enumerate
Zadržavanje resursa tokom čekanja: ovaj uslov se može sprečiti na više načina.
 Prvo, ako se procesu koji drži određene resurse uskrati mogućnost za daljim
 zahtevima, taj proces će morati da oslobodi resurse koje drži i, ako je
 potrebno, da ih ponovo zahteva.
 Druga mogućnost je da operativni sistem prinudno suspenduje proces koji
 drži resurse koje zahteva drugi proces; ovaav pristup deluje samo ako procesi
 koji su u potpunom zastoji nisu istog prioriteta.
\end_layout

\begin_layout Enumerate
Kružno čekanje: ovaj uslov se može izbeći ako se definiše linearan redosled
 tipova resursa.
 Ako neki proces drži resurse tipa R, onda ubuduće može da zahteva samo
 resurse koji su iza tipa R u redosledu.
 Iako rešava problem, ovaj pristup usporava procese i nepotrebno uskraćuje
 resurse.
\end_layout

\begin_layout Subsection
Otkrivanje i oporavak od zastoja
\end_layout

\begin_layout Standard
Operativni sistemi mogu biti projektovani tako da predviđaju mogućnost pojave
 potpunog zastoja
\begin_inset Index idx
status open

\begin_layout Plain Layout
potpuni zastoj!otkrivanje
\end_layout

\end_inset

 i sprečavaju ga.
 To zahteva da se u trenutku zahteva za resursom predvidi da li taj zahtev
 potencijalno može da izazove potpuni zastoj, odnosno da se predvidi kakvi
 će biti budući zahtevi za resursima.
 
\end_layout

\begin_layout Standard
Neki operativni sistemi (kao što su Windows i UNIX) uopšte ne razmatraju
 mogućnost da dođe do potpunog zastoja.
 Drugi pak ne sprečavaju pojavu zastoja, ali koriste algoritme koji ga otkrivaju.
 Tada su na raspolaganju su dve mogućnosti.
 Prva je da se jedan ili nekoliko procesa napuste da bi se sprečilo kružno
 čekanje.
 Druga je da se određeni resursi nasilno preuzmu od procesa u potpunom zastoju.
 Detaljan opis algoritama za otkrivanje i oporavak od zastoja prevazilazi
 okvire ovog kursa, pa se čitaoci upućuju na nekoliko odličnih knjiga u
 odeljku literature.
\end_layout

\begin_layout Chapter
Upravljanje memorijom
\end_layout

\begin_layout Standard
U sistemima koji rade sa jednim programom, glavna memorija se deli na dva
 dela: jedan deo je za jezgro (kernel) operativnog sistema, a drugi za program
 koji se trenutno izvršava.
 U sistemima koji rade sa više programa korisnički deo memorije mora se
 dalje deliti i prilagoditi radu sa više procesa.
 Zadatak operativnog sistema je da upravlja memorijom.
 Efikasno upravljanje memorijom veoma je važno za sisteme koji rade sa više
 programa (tzv.
 multiprogramski sistemi).
 Ako se samo nekoliko procesa nalazi u memoriji, onda će najveći deo vremena
 svi procesi čekati na U/I operacije i procesor će biti besposlen.
 Dakle, memorija treba da se alocira, tj.
 dodeli da bi se korisno procesorsko vreme dodelilo spremnim procesima.
 
\end_layout

\begin_layout Standard
Upravljanje memorijom je jedan od najvažnijih i najsloženijih zadataka operativn
og sistema.
 Ono posmatra memoriju
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!upravljanje
\end_layout

\end_inset

 kao resurs koji treba da se dodeli i da se deli između više aktivnih procesa.
 Da bi se efikasno koristili procesor i U/I resursi, poželjno je u glavnoj
 memoriji održavati što više procesa.
 Pored toga, poželjno je osloboditi programere ograničenja vezanih za veličinu
 memorije.
 Osnovne tehnike upravljanja memorijom su straničenje i segmentacija.
 Kod straničenja, svaki proces se deli na relativno male stranice fiksne
 dužine.
 Segmentacija omogućava upotrebu delova procesa različitih veličina.
 Moguće je kombinovati segmentaciju i straničenje u prostoj šemi za upravljanje
 memorijom.
 
\end_layout

\begin_layout Section
Zahtevi u upravljanju memorijom 
\end_layout

\begin_layout Standard
Upravljanje memorijom treba da zadovolji sledeće zahteve: 
\end_layout

\begin_layout Enumerate
relokacija
\end_layout

\begin_layout Enumerate
zaštita
\end_layout

\begin_layout Enumerate
deljenje
\end_layout

\begin_layout Enumerate
logička organizacija
\end_layout

\begin_layout Enumerate
fizička organizacija
\end_layout

\begin_layout Standard
U nastavku ćemo detaljnije objasniti svaki od pomenutih zahteva.
\end_layout

\begin_layout Subsection
Relokacija 
\end_layout

\begin_layout Standard
U sistemu sa više programa raspoloživa glavna memorija
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!relokacija
\end_layout

\end_inset

 se obično deli između više procesa.
 Programer ne može da zna unapred koji drugi programi će biti u glavnoj
 memoriji tokom izvršavanja njegovog programa.
 Takođe, programeri bi trebalo da imaju mogućnost da zamenjuju aktivne procese
 u glavnoj memoriji, tj.
 da obezbeđuju procese spremne za izvršavanje da bi se maksimiziralo iskorišćenj
e procesora.
 Program koji se prebacuje na disk treba da se premesti u neko drugo područje
 u memoriji.
 Procesor mora da se bavi memorijskim referencama unutar programa.
 Procesor i operativni sistem treba da budu sposobni da prevedu memorijske
 reference iz kôda programa u stvarne fizičke adrese memorije, tj.
 tekuće lokacije programa u glavnoj memoriji.
 Prvi korak u kreiranju aktivnog procesa je učitavanje programa u glavnu
 memoriju i kreiranje “slike” procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!slika u memoriji
\end_layout

\end_inset

 (process image).
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.1.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.1: Adresni zahtevi procesa.
\end_layout

\begin_layout Standard
Aplikacija se sastoji od određenog broja kompajliranih i asembliranih modula
 u obliku objektnog kôda.
 Oni su povezani da bi se razrešila međusobna referenciranja modula.
 U isto vreme se razrešavaju reference prema biblioteci rutina.
 Same bibliotečke rutine mogu biti ugrađene u program ili referencirane
 kao deljeni kôd koji mora da obezbedi operativni sistem tokom izvršavanja
 (run time).
 
\end_layout

\begin_layout Subsection
Zaštita 
\end_layout

\begin_layout Standard
Svaki proces trebalo bi da bude zaštićen od slučajnih ili namernih neželjenih
 uticaja drugih procesa.
 Drugi procesi ne bi smeli bez dozvole da referenciraju memorijske lokacije
 koje tekući proces čita ili upisuje.
 Korisnički proces ne može da pristupi bilo kom delu operativnog sistema,
 ni programu ni podacima.
 Uslovi zaštite memorije prvenstveno se ostvaruju hardverski, a ne softverski
 (preko operativnog sistema).
 
\end_layout

\begin_layout Subsection
Deljenje 
\end_layout

\begin_layout Standard
Svaki zaštitni mehanizam mora da bude prilagodljiv i da dozvoli da više
 procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!deljenje
\end_layout

\end_inset

 pristupi istom delu glavne memorije.
 Ako više procesa izvršava isti program, treba dozvoliti svakom procesu
 da pristupi istoj kopiji programa, a ne da ima sopstvenu kopiju.
 Procesi koji sarađuju na istom zadatku mogu istovremeno da pristupaju struktura
ma podataka.
 Sistem za upravljanje memorijom mora da omogući kontrolisani pristup deljenim
 oblastima memorije bez ugrožavanja osnovne zaštite.
 
\end_layout

\begin_layout Subsection
Logička organizacija 
\end_layout

\begin_layout Standard
Glavna memorija
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!logička organizacija
\end_layout

\end_inset

 u računarskom sistemu je organizovana kao linearni ili jednodimenzionalni
 adresni prostor sastavljen od nizova bajtova ili reči.
 Slično je organizovana i sekundarna memorija na fizičkom nivou.
 Većina programa je organizovana u modulima, od kojih se neki ne mogu menjati
 (samo se čitaju ili izvršavaju), a neki sadrže podatke koji mogu da se
 menjaju.
 Ako operativni sistem i računarski hardver mogu efikasno da rade sa korisničkim
 programima i podacima u obliku neke vrste modula, to ima svojih prednosti:
 
\end_layout

\begin_layout Itemize
moduli mogu biti pisani i kompajlirani nezavisno
\end_layout

\begin_layout Itemize
za različite module mogu se definisati različiti stepeni zaštite
\end_layout

\begin_layout Itemize
moduli mogu biti deljeni između procesa 
\end_layout

\begin_layout Standard
Pomenute zahteve zadovoljava jedna od tehnika upravljanja memorijom koja
 se zove segmentacija.
 
\end_layout

\begin_layout Subsection
Fizička organizacija 
\end_layout

\begin_layout Standard
Računarska memorija
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!fizička organizacija
\end_layout

\end_inset

 je organizovana u najmanje dva nivoa, koje zovemo glavna memorija i sekundarna
 memorija.
 Glavna memorija obezbeđuje brz pristup po relativno visokoj ceni, ali ne
 obezbeđuje trajno skladištenje podataka.
 Sekundarna memorija je sporija i jeftinija od glavne memorije i po pravilu
 obezbeđuje trajno skladištenje podataka.
 U šemi dva nivoa, glavni sistemski problem je organizacija toka informacija
 između glavne i sekundarne memorije, što je osnova upravljanja memorijom.
 
\end_layout

\begin_layout Section
Podela memorije na particije 
\end_layout

\begin_layout Standard
Osnovna operacija upravljanja memorijom
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!podela na particije
\end_layout

\end_inset

 je učitavanje procesa u glavnu memoriju da bi ih procesor izvršio.
 U skoro svim modernim sistemima koji rade sa više programa ovo podrazumeva
 naprednu šemu upravljanja memorijom poznatu kao virtuelna memorija.
 Virtuelna memorija je zasnovana na tehnikama segmentacije i straničenja.
 S druge strane, postoji i tehnika upravljanja memorijom koja ne koristi
 virtuelnu memoriju: to je podela memorije na particije.
 
\end_layout

\begin_layout Subsection
Podela na particije fiksne veličine 
\end_layout

\begin_layout Standard
U većini šema za upravljanje memorijom, možemo da pretpostavimo da operativni
 sistem zauzima određeni fiksni deo glavne memorije, a da je ostatak na
 raspolaganju drugim procesima.
 Najjednostavnija tehnika za upravljanje neiskorišćenom memorijom je da
 se ona podeli na oblasti (particije) sa fiksnim granicama.
 Međutim, upotreba fiksnih particija
\begin_inset Index idx
status open

\begin_layout Plain Layout
particije!fiksne veličine
\end_layout

\end_inset

 jednake veličine prouzrokuje teškoće.
 Na primer, program može da bude suviše velik da bi stao u particiju.
 U tom slučaju, programer mora da projektuje program koji koristi preklapanja
 (overlay), tako da se u određenom trenutku samo deo programa nalazi u glavnoj
 memoriji.
 Takođe, u slučaju particija fiksne veličine glavna memorija se ne koristi
 efikasno jer svaki program, bez obzira koliko mali, zauzima celu particiju.
 To je
\begin_inset Index idx
status open

\begin_layout Plain Layout
fragmentacija!unutrašnja
\end_layout

\end_inset

 tzv.
 
\series bold
unutrašnja
\series default
 
\series bold
fragmentacija
\series default
.
 Zbog toga se particije fiksne veličine skoro i ne koriste u modernim operativni
m sistemima, već se koriste isključivo particije nejednakih veličina.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.2: Dodela memorije kod podele na particije.
\end_layout

\begin_layout Subsection
Dinamička podela na particije 
\end_layout

\begin_layout Standard
Teškoće sa deljenjem na fiksne particije se prevazilaze dinamičkim deljenjem
 na particije.
 Kod dinamičkog deljenja memorije, particije su promenljive dužine i broja.
 Kada se proces učita u glavnu memoriju, njemu se dodeljuje tačno onoliko
 memorije koliko zahteva.
 Međutim, primena ovog metoda dovodi do situacije u kojoj postoji mnogo
 malih praznina, tj.
 neiskorišćenih delova u memoriji.
 Kako vreme prolazi, memorija postaje sve više fragmentirana, pa se smanjuje
 njeno iskorišćenje.
 Ova pojava se zove 
\series bold
spoljašnja fragmentacija
\series default
 i suprotna
\begin_inset Index idx
status open

\begin_layout Plain Layout
fragmentacija!spoljašnja
\end_layout

\end_inset

 je unutrašnjoj fragmentaciji.
 Tehnika za prevazilaženje spoljašnje fragmentacije je sažimanje: s vremena
 na vreme, operativni sistem pomera procese da budu susedni da bi se sva
 slobodna memorija grupisala u jedan blok.
 Sažimanje memorije zahteva vreme, pa projektanti operativnih sistema moraju
 da odluče na koji način da pridruže procese memoriji.
 Postoje tri algoritma smeštanja procesa u glavnu memoriju, u kojima su
 glavni parametri slobodni blokovi veličine jednake ili veće od procesa
 koji se smešta u memoriju.
 
\end_layout

\begin_layout Itemize
Best-fit: odabira blok koji je po veličini najbliži zahtevu.
 
\end_layout

\begin_layout Itemize
First-fit: pregleda memoriju od početka i dodeljuje prvi slobodan blok koji
 je dovoljno velik da primi proces.
 
\end_layout

\begin_layout Itemize
Next-fit: nastavlja da pregleda memoriju od lokacije koja je poslednja dodeljena
 i odlučuje se za blok koji je dovoljno velik.
 
\end_layout

\begin_layout Section
Straničenje 
\end_layout

\begin_layout Standard
Deljenje na
\begin_inset Index idx
status open

\begin_layout Plain Layout
straničenje
\end_layout

\end_inset

 particije fiksne i promenljive veličine je neefikasno u pogledu iskorišćenja
 memorije
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!straničenje
\end_layout

\end_inset

; prva tehnika za rezultat ima unutrašnju, a druga spoljašnju fragmentaciju.
 Pretpostavimo, međutim, da je glavna memorija izdeljena na jednake delove
 fiksne veličine koji su relativno mali i da se svaki proces takođe deli
 na male jednake delove te iste fiksne veličine.
 Tada delovi procesa, poznati kao
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice
\end_layout

\end_inset

 
\series bold
stranice
\series default
 (pages), mogu da se dodele raspoloživim delovima memorije, poznatim kao
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!okviri
\end_layout

\end_inset

 
\series bold
okviri stranica
\series default
 (page frame).
 Pokazaćemo da se neiskorišćen prostor u memoriji koji je posledica unutrašnje
 fragmentacije za svaki proces sastoji samo od dela poslednje stranice procesa,
 tj.
 da tehnika straničenja ne prouzrokuje spoljašnju fragmentaciju.
 
\end_layout

\begin_layout Standard
Na Slici 6.3 ilustrovano je korišćenje stranica i okvira.
 U datom trenutku, neki od okvira u memoriji su u upotrebi, a neki su slobodni.
 Operativni sistem održava listu slobodnih okvira.
 Proces A koji se čuva na disku sastoji se od četiri stranice.
 Kada dođe vreme da se učita taj proces, operativni sistem nalazi četiri
 slobodna okvira i učitava četiri stranice procesa A u ta četiri okvira
 (Slika 6.3 b).
 Zatim se učitavaju proces B, koji se sastoji od tri stranice i proces C,
 koji se sastoji od četiri stranice.
 Nakon toga se proces B suspenduje i zamenjuje (swap out) iz glavne memorije.
 Kasnije, svi procesi u glavnoj memoriji su blokirani, a operativni sistem
 treba da učita novi proces D, koji se sastoji od pet stranica.
 Pretpostavimo da ne postoji dovoljno neupotrebljenih susednih okvira koji
 bi sadržali proces.
 To ne sprečava operativni sistem da učita stranicu D.
 U tom slučaju se koristi pojam logičke adrese.
 
\series bold
Logička adresa
\series default
 je referenca
\begin_inset Index idx
status open

\begin_layout Plain Layout
adresa!logička
\end_layout

\end_inset

 na memorijsku lokaciju nezavisno od tekuće dodele podataka memoriji.
 Operativni sistem održava tabelu stranica
\begin_inset Index idx
status open

\begin_layout Plain Layout
tabela stranica
\end_layout

\end_inset

 za svaki proces.
 Tabela stranica pokazuje lokaciju okvira za svaku stranicu procesa.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.3.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.3: Dodela stranica procesa slobodnim okvirima.
\end_layout

\begin_layout Standard
Unutar programa, svaka logička adresa se sastoji od broja stranice (page
 number) i pomeraja
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!pomeraj
\end_layout

\end_inset

 (offset) unutar stranice.
 Podsetimo se da je u slučaju proste particije logička adresa zapravo položaj
 reči u odnosu na početak programa; procesor prevodi logičku adresu u fizičku
 adresu.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.4.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.4: Logička adresa.
\end_layout

\begin_layout Standard
Kod straničenja, preslikavanje logičkih u fizičke adrese
\begin_inset Index idx
status open

\begin_layout Plain Layout
adresa!fizička
\end_layout

\end_inset

 (apsolutne adrese, tj.
 stvarne lokacije u glavnoj memoriji) obavlja hardver procesora.
 Procesor mora da zna kako da pristupi tabeli stranica tekućeg procesa.
 Polazeći od logičke adrese (broja stranice i pomeraja unutar nje) procesor
 koristi tabelu stranica da bi ustanovio fizičku adresu (tj.
 broj okvira i pomeraj unutar njega).
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.5.png
	scale 75

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.5: Dobijanje fizičke adrese preslikavanjem logičke adrese kod straničenja.
\end_layout

\begin_layout Standard
Straničenje je slično podeli na fiksne particije.
 Razlika je što su kod straničenja particije male, program može zauzimati
 više od jedne particije, i one ne moraju da budu susedne.
 Dakle, kod jednostavnog straničenja, glavna memorija je podeljena na mnogo
 malih okvira iste veličine.
 Svaki proces je podeljen na stranice veličine okvira; manji procesi zahtevaju
 nekoliko stranica, a veći više stranica.
 Kada se proces učita, sve njegove stranice se učitavaju u raspoložive okvire
 i postavlja se tabela stranica.
 Taj pristup rešava mnoge probleme koji se javljaju u podeli na particije.
 
\end_layout

\begin_layout Section
Segmentacija 
\end_layout

\begin_layout Standard
Korisnički program i njemu pridruženi podaci mogu da se podele na određen
 broj segmenata.
 Segmenti svih programa
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!segmentacija
\end_layout

\end_inset

 ne moraju da budu iste veličine, mada postoji maksimalna dužina segmenta.
 Kao kod straničenja, logička adresa koja koristi segmentaciju
\begin_inset Index idx
status open

\begin_layout Plain Layout
segmentacija
\end_layout

\end_inset

 sastoji se od dva dela, u ovom slučaju od broja segmenta i pomeraja unutar
 tog segmenta.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.6.png
	scale 75

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.6: Dobijanje fizičke adrese preslikavanjem logičke adrese kod segmentacij
e.
\end_layout

\begin_layout Standard
Zbog upotrebe segmenata različitih veličina, segmentacija je slična dinamičkoj
 podeli na particije.
 U odsustvu šeme za preklapanje ili upotrebe virtuelne memorije, zahteva
 se da se svi segmenti programa učitaju u memoriju radi izvršavanja.
 Razlika u poređenju sa dinamičkom podelom na particije je u tome što kod
 segmentacije program može da zauzme više od jedne particije i te particije
 ne moraju da budu susedne.
 Segmentacija rešava problem unutrašnje fragmentacije, ali, kao i kod dinamičke
 podele na particije, ostaje problem spoljašnje fragmentacije.
 Međutim, zbog toga što se proces deli na izvestan broj manjih delova, spoljašnj
a fragmentacija je po pravilu manja.
 Za razliku od straničenja koje je nevidljivo za programera, segmentacija
 je obično vidljiva i pogodna za organizaciju programa i podataka.
 Programer ili kompajler obično pridružuju programe i podatke različitim
 segmentima.
 U cilju modularnog programiranja program ili podaci mogu dalje da se podele
 na više manjih segmenata.
 Loša strana ove tehnike je to što programer mora znati ograničenja maksimalne
 veličine segmenata.
 Sledeća pogodnost korišćenja segmenata različitih veličina je to što ne
 postoji prosta veza između logičkih i fizičkih adresa.
 Slično straničenju, tehnika jednostavne segmentacije koristi tabelu segmenata
 za svaki proces i listu slobodnih blokova u glavnoj memoriji.
 Svaki upis u tabelu segmenata treba da dâ početnu adresu odgovarajućih
 segmenata u glavnoj memoriji.
 Upis takođe treba da obezbedi dužinu segmenta da se ne bi koristile pogrešne
 adrese.
 Kada proces uđe u stanje izvršavanja, adresa iz tabele segmenata
\begin_inset Index idx
status open

\begin_layout Plain Layout
tabela segmenata
\end_layout

\end_inset

 se učitava u specijalan registar hardvera za upravljanje memorijom.
 
\end_layout

\begin_layout Section
Virtuelna memorija 
\end_layout

\begin_layout Standard
Pošto je upravljanje memorijom
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!virtuelna
\end_layout

\end_inset

 složena aktivnost procesorskog hardvera i softvera operativnog sistema,
 prvo ćemo prikazati hardverski aspekt virtuelne memorije
\begin_inset Index idx
status open

\begin_layout Plain Layout
virtuelna memorija
\end_layout

\end_inset

, definišući straničenje, segmentaciju i njihovu kombinaciju.
 Zatim ćemo definisati dizajn virtuelne memorije kao karakteristiku operativnog
 sistema.
 
\end_layout

\begin_layout Standard
Kod tehnike virtuelne memorije sve adresne reference su logičke reference
 koje se tokom izvršavanja prevode u realne adrese.
 To omogućuje lociranje procesa bilo gde u glavnoj memoriji i menjanje njegove
 lokacije tokom vremena.
 Virtuelna memorija dozvoljava procesu da bude podeljen na manje delove.
 Tokom izvršavanja ne zahteva se da delovi budu susedni u glavnoj memoriji,
 niti da svi budu u glavnoj memoriji.
 Dve osnovne tehnike virtuelne memorije su straničenje i segmentacija.
 Kod jednostavnijih šema upravljanja memorijom moguća je i njihova kombinacija.
 Virtuelna memorija zahteva i hardversku i softversku podršku.
 Hardversku podršku obezbeđuje procesor, a podrazumeva dinamičko prevođenje
 virtuelnih adresa u fizičke i generisanje prekida kada referencirana stranica
 ili segment nisu u memoriji.
 Prekid zatim poziva softver za upravljanje memorijom operativnog sistema.
 
\end_layout

\begin_layout Subsection
Hardver i kontrolne strukture 
\end_layout

\begin_layout Standard
U tehnikama straničenja i segmentacije, sve memorijske reference unutar
 procesa su logičke adrese
\begin_inset Index idx
status open

\begin_layout Plain Layout
adresa!logička
\end_layout

\end_inset

 koje se dinamički prevode u fizičke adrese tokom izvršavanja.
 To znači da proces može biti zamenjen tako da u različitim trenucima izvršavanj
a zauzima različite delove glavne memorije.
 
\end_layout

\begin_layout Standard
Proces može da se podeli na veći broj delova (stranica ili segmenata) koji
 ne moraju da budu susedni u glavnoj memoriji.
 Primena takve tehnike podrazumeva kombinaciju dinamičkog prevođenja adresa
 tokom izvršavanja i korišćenja tabela stranica ili segmenata.
 Nije neophodno da sve stranice ili svi segmenti procesa budu u glavnoj
 memoriji tokom izvršavanja procesa.
 Deo procesa koji je u određenom trenutku u glavnoj memoriji definiše se
 kao rezidentan deo proces
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!rezidentan
\end_layout

\end_inset

a.
 Da bi se poboljšalo iskorišćenje sistema, više procesa treba da bude u
 glavnoj memoriji, pri čemu proces može biti i veći od glavne memorije.
 Pošto se proces izvršava u glavnoj memoriji, ta memorija se označava kao
 realna memorija.
 Programer ili korisnik sistema vide mnogo veću memoriju koja je alocirana
 sa diska, a zove se virtuelna memorija.
 
\end_layout

\begin_layout Subsection
Lokalitet i virtuelna memorija 
\end_layout

\begin_layout Standard
Virtuelna memorija zasnovana
\begin_inset Index idx
status open

\begin_layout Plain Layout
virtuelna memorija!i princip lokaliteta
\end_layout

\end_inset

 na straničenju ili straničenju sa segmentacijom postala je nezaobilazna
 komponenta savremenih operativnih sistema.
 U tehnikama virtuelizacije memorije pojavljuje se problem poznat kao
\begin_inset Index idx
status open

\begin_layout Plain Layout
thrashing
\end_layout

\end_inset

 
\series bold
thrashing
\series default
.
 Sistem troši mnogo više vremena na prebacivanje delova procesa iz glavne
 memorije u sekundarnu nego na stvarno izvršavanje instrukcija u procesu.
 Rešenje ovog problema zasniva se na predviđanju koji delovi procesa će
 biti korišćeni u bliskoj budućnosti.
 Ako se primeni i princip lokaliteta koji kaže da program i podaci referencirani
 u procesu teže da se klasterizuju, moguće 
\begin_inset Quotes eld
\end_inset

je pametno
\begin_inset Quotes erd
\end_inset

 predvideti koji delovi procesa će se koristiti u bliskoj budućnosti, čime
 se izbegava thrashing.
 
\end_layout

\begin_layout Subsection
Straničenje 
\end_layout

\begin_layout Standard
Termin virtuelna memorija se obično povezuje sa sistemom koji koristi straničenj
e
\begin_inset Index idx
status open

\begin_layout Plain Layout
straničenje
\end_layout

\end_inset

.
 Straničenje je u virtuelizaciji memorije prva koristila kompanija Atlas
 Computer pre nego što je ušlo u komercijalnu upotrebu.
 Kod običnog straničenja, svaki proces ima svoju tabelu stranica.
 Kada su sve stranice procesa učitane u glavnu memoriju, kreira se tabela
 stranica za taj proces i učitava u glavnu memoriju.
 Svaki upis u tabelu stranica sadrži broj okvira odgovarajuće stranice u
 glavnoj memoriji.
 Tabela stranica je potrebna i u tehnici virtuelne memorije zasnovanoj na
 straničenju.
 Obično se svakom procesu pridružuje jedinstvena tabela stranica.
 Međutim, u ovom slučaju, tabela stranica
\begin_inset Index idx
status open

\begin_layout Plain Layout
tabela stranica
\end_layout

\end_inset

 upisa postaje složenija.
 Pošto samo neke stranice procesa mogu biti u glavnoj memoriji, potreban
 je dodatni bit u svakom upisu tabele stranica koji će označavati da li
 je odgovarajuća stranica prisutna u glavnoj memoriji ili nije (bit P).
 Ako bit pokazuje da je stranica u memoriji, onda upis uključuje i broj
 okvira te stranice.
 Tabela upisa stranica uključuje i bit M koji definiše da li je sadržaj
 stranice promenjen od poslednjeg učitavanja u glavnu memoriju.
 Ako nema promena, onda nije neophodno ponovo upisivati stranicu kada dođe
 vreme da se ona zameni iz okvira u kome se trenutno nalazi.
 Postoje i drugi kontrolni bitovi za zaštitu ili deljenje na nivou stranica
 (Slika 6.7).
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.7.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.7: Straničenje i tabela upisa stranica.
\end_layout

\begin_layout Subsection
Struktura tabele stranica 
\end_layout

\begin_layout Standard
Osnovni mehanizam za učitavanje reči iz memorije uključuje prevođenje virtuelnih
 (logičkih) adresa, sastavljenih od broja stranice i pomeraja, u fizičku
 adresu koja se sastoji od broja okvira i pomeraja, uz pomoć tabele stranica.
 
\end_layout

\begin_layout Standard
Pošto je tabela stranica
\begin_inset Index idx
status open

\begin_layout Plain Layout
tabela stranica!struktura
\end_layout

\end_inset

 promenljive veličine, zavisno od veličine procesa, ne možemo očekivati
 da se ona čuva u registrima procesora; umesto toga, ona mora da bude u
 glavnoj memoriji da bi joj se lakše pristupilo.
 Slika 6.8 predstavlja hardversku implementaciju prevođenja adresa.
 Kada određeni proces počne da se izvršava, u registru se nalazi početna
 adresa tabele strana za taj proces.
 Broj strane virtuelne adrese se koristi kao indeks te tabele koji definiše
 odgovarajući broj okvira.
 Taj podatak se kombinuje sa delom virtuelne adrese koji definiše pomeraj
 da bi se dobila željena fizička (realna) adresa.
 Broj polja stranica obično je mnogo veći od broja polja okvira (n>m).
 Količina memorije posvećena tabelama stranica ponekad može biti neprihvatljivo
 velika.
 Da bi se prevazišao taj problem, većina tehnika virtuelne memorije čuva
 tabele stranica u virtuelnoj memoriji umesto u fizičkoj memoriji.
 Neki procesori koriste šemu sa dva nivoa za organizaciju velikih tabela
 stranica, u kojoj postoji direktorijum stranica koji definiše tabelu upisa
 stranica (page entry).
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.8.png
	scale 65

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.8: Prevođenje adresa u sistemu straničenja.
\end_layout

\begin_layout Subsection
Invertovana tabela stranica 
\end_layout

\begin_layout Standard
Postoje i invertovane tabele stranica
\begin_inset Index idx
status open

\begin_layout Plain Layout
tabela stranica!invertovana
\end_layout

\end_inset

 u kojima se deo virtuelne adrese sa brojem stranice mapira u heš (hash)
 vrednost pomoću proste funkcije heširanja.
 Heš vrednost je pokazivač na invertovanu tabelu stranica koja sadrži tabelu
 upisa stranica.
 Uglavnom se koristi po jedan upis u invertovanu tabelu stranica za svaki
 okvir stranice u realnoj memoriji, umesto jedan po virtuelnoj stranici.
 Na taj način za tabele se zahteva fiksni deo realne memorije bez obzira
 na broj procesa ili podržanih virtuelnih stranica.
 Pošto se nekoliko virtuelnih adresa može mapirati u istu heš tabelu upisa,
 koristi se tehnika ulančavanja.
 Tabela stranica se zove invertovana zato što umesto po broju virtuelne
 stranice indeksira upise u tabelu stranica po broju okvira.
 
\end_layout

\begin_layout Subsection
Translation Lookaside Buffer (TLB) 
\end_layout

\begin_layout Standard
Svaka referenca na virtuelnu stranicu može da prouzrokuje dva pristupa fizičkoj
 memoriji: jedan da bi se dobio odgovarajući upis u tabelu stranica i drugi
 da bi se dobio željeni podatak.
 Da bi se to izbeglo, većina tehnika virtuelne memorije koristi specijalnu
 i veoma brzu keš memoriju za upise u tabelu stranica, koja se zove translation
 lookaside buffer (TLB).
 TLB radi na isti način kao i memorijski keš i sadrži poslednje upise u
 tabelu stranica.
 Za datu virtuelnu adresu, procesor prvo ispituje da li je željeni upis
 u tabelu stranica u kešu (TLB
\begin_inset Index idx
status open

\begin_layout Plain Layout
TLB
\end_layout

\end_inset

 pogodak); ako jeste, broj okvira se čita iz tabele i izračunava se fizička
 adresa.
 Ako se ne pronađe traženi upis (TLB promašaj), procesor koristi broj strane
 za indeksiranje tabele stranica procesa i ispituje odgovarajući upis u
 tabelu stranica.
 Ako je bit prisustva postavljen, onda je stranica u glavnoj memoriji, pa
 procesor može da dobije broj okvira iz tabele upisa stranica da bi izračunao
 fizičku adresu.
 Procesor takođe ažurira TLB kako bi se uključio ovaj novi upis u tabelu
 stranica.
 Ako bit prisustva nije postavljen, onda željena stranica nije u glavnoj
 memoriji i generiše se greška u pristupu memoriji, tj.
 pogrešna stranica
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!pogrešne (page fault)
\end_layout

\end_inset

 (page fault).
 Hardver signalizira operativnom sistemu da učita potrebnu stranicu i ažurira
 tabelu stranica.
 Ova tehnika se često označava kao asocijativno mapiranje i suprotna je
 direktnom mapiranju ili indeksiranju koje smo ranije objasnili.
 
\end_layout

\begin_layout Subsection
Veličina stranice 
\end_layout

\begin_layout Standard
Važno pitanje pri projektovanju hardvera je veličina stranice
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!veličina
\end_layout

\end_inset

, jer zavisi od više faktora.
 Što je stranica manja, manja je i unutrašnja fragmentacija.
 Da bi se optimizovalo korišćenje glavne memorije, treba smanjiti unutrašnju
 fragmentaciju.
 Što je stranica manja, veći je broj stranica po jednom procesu; što je
 veći broj stranica po procesu, veća je i tabela stranica.
 Za veće programe u okruženju koji radi sa više programa, to može da znači
 da neki delovi tabele stranica aktivnog procesa moraju da budu u virtuelnoj
 memoriji, a ne u glavnoj.
 To može prouzrokovati dvostruku pogrešnu stranicu (page fault) za jednu
 referencu u memoriji: prvi put da bi se učitao potreban deo tabele stranica
 u memoriju i drugi put da bi se učitala stranica procesa.
 Takođe, fizičke karakteristike većine sekundarnih memorijskih uređaja koji
 su rotacioni diktiraju da veće stranice efikasnije prenose blokove podataka.
 Veličina stranice utiče i na brzinu pojave pogrešne stranice.
 Posmatrajmo princip lokaliteta stranica: ako je stranica veoma mala, u
 glavnoj memoriji će moći da se iskoristi relativno veliki broj stranica
 po jednom procesu.
 Nakon određenog vremena sve stranice u memoriji sadržaće delove procesa
 koji su blizu skorašnjih referenci, pa će brzina pojave pogrešnih stranica
 biti mala.
 Kako se veličina stranice povećava, svaka stranica pojedinačno sadržavaće
 lokacije koje su dalje od svih poslednjih referenci.
 Time efekat principa lokaliteta slabi, a brzina pojave pogrešnih stranica
 raste.
 Ova brzina opada sa približavanjem veličine stranice veličini kompletnog
 procesa, a jednaka je nuli kada stranica obuhvata ceo proces.
 
\end_layout

\begin_layout Standard
Brzina pojave pogrešne stranice zavisi i od broja okvira dodeljenih procesu.
 Za fiksnu veličinu stranica, brzina pojave pogrešnih stranica opada sa
 porastom broja stranica koje se održavaju u glavnoj memoriji.
 Politika operativnog sistema u pogledu količine memorije dodeljene svakom
 procesu utiče na odluku o veličini stranice prilikom projektovanja hardvera.
 I na kraju, problem veličine stranice je povezan sa veličinom glavne fizičke
 memorije i veličine programa.
 Sa porastom kapaciteta glavne memorije raste i adresni prostor koji aplikacije
 koriste; to je očigledno kod PC računara i radnih stanica, u kojima softverske
 aplikacije postaju veoma složene.
 
\end_layout

\begin_layout Subsection
Segmentacija 
\end_layout

\begin_layout Standard
Segmentacija dozvoljava programeru da vidi memoriju kao skup više adresnih
 prostora, odnosno segmenata
\begin_inset Index idx
status open

\begin_layout Plain Layout
segmentacija
\end_layout

\end_inset

.
 Veličina segmenata je različita i određuje se dinamički.
 Memorijske reference se sastoje od broja segmenta i pomeraja.
 Ovakva organizacija ima nekoliko prednosti u odnosu na nesegmentirani adresni
 prostor iz ugla programera: 
\end_layout

\begin_layout Standard
1.
 Rad sa rastućim strukturama podataka je prostiji: strukturama podataka
 se mogu dodeliti sopstveni segmenti, a operativni sistem će proširiti ili
 smanjiti segment po potrebi.
 
\end_layout

\begin_layout Standard
2.
 Korišćenjem više segmenata, dozvoljava se programima da budu zamenjeni
 i ponovo kompajlirani nezavisno, bez ponovnog povezivanja i učitavanja
 svih programa.
\end_layout

\begin_layout Standard
3.
 Deljenje između procesa: programer može da smesti koristan program ili
 korisnu tabelu podataka u segment koji drugi proces može da referencira.
 
\end_layout

\begin_layout Standard
4.
 Efikasna zaštita: pošto segment može da bude konstruisan tako da sadrži
 dobro definisan skup programa i podataka, programer ili administrator sistema
 može da dodeli ili oduzme privilegovane pristupe na uobičajen način.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.9.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.9: Tabela segmenata.
\end_layout

\begin_layout Standard
Prisetimo se da kod proste segmentacije svaki proces ima sopstvenu tabelu
 segmenata.
 Kada su svi segmenti učitani u glavnu memoriju, kreira se tabela segmenata
 za taj proces koja se učitava u glavnu memoriju.
 
\end_layout

\begin_layout Standard
Svaki upis u tabelu segmenata sadrži početnu adresu odgovarajućeg segmenta
 u glavnoj memoriji, kao i dužinu segmenta.
 Isti je slučaj i kod virtuelne memorije zasnovane na segmentaciji, ali
 tabela upisa segmenata postaje složenija.
 Pošto samo neki od segmenata procesa mogu biti u glavnoj memoriji, potreban
 je dodatni bit (P) za svaku tabelu upisa segmenata koji pokazuje da li
 je odgovarajući segment prisutan u glavnoj memoriji ili ne.
 Ako bit pokazuje da je segment u memoriji, upis uključuje i početnu adresu
 i dužinu tog segmenta.
 Drugi kontrolni bit u tabeli upisa segmenata je bit promene (M) koji pokazuje
 da li je sadržaj segmenta promenjen od trenutka poslednjeg učitavanja u
 memoriju.
 Mogu biti prisutni i drugi kontrolni bitovi.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.10.png
	scale 65

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.10: Prevođenje adresa u sistemu sa segmentacijom.
\end_layout

\begin_layout Standard
Osnovni mehanizam za čitanje reči iz memorije uključuje prevođenje virtuelne,
 odnosno logičke adrese
\begin_inset Index idx
status open

\begin_layout Plain Layout
adresa!logička
\end_layout

\end_inset

 sastavljene od broja segmenta i pomeraja u fizičku adresu
\begin_inset Index idx
status open

\begin_layout Plain Layout
adresa!fizička
\end_layout

\end_inset

 uz pomoć tabele segmenata.
 Pošto je tabela segmenata promenljive dužine, zavisno od veličine procesa,
 ne možemo očekivati da se čuva u registrima procesa, već mora da bude u
 glavnoj memoriji.
 Kada započne izvršavanje određenog procesa, registar sadrži početnu adresu
 tabele segmenata za proces.
 Broj segmenta virtuelne adrese se koristi za indeksiranje te tabele i pronalaže
nje odgovarajuće adrese u glavnoj memoriji za početak segmenta.
 Da bi se izračunala željena adresa, dodaje se i deo sa pomerajem.
 
\end_layout

\begin_layout Subsection
Kombinacija straničenja i segmentacije 
\end_layout

\begin_layout Standard
I straničenje
\begin_inset Index idx
status open

\begin_layout Plain Layout
straničenje!i segmentacija
\end_layout

\end_inset

 i segmentacija imaju svoje dobre osobine.
 Straničenje je nevidljivo za programera, uklanja spoljašnju fragmentaciju
 i na taj način povećava efikasnost glavne memorije.
 Pored toga, pošto su delovi procesa koji se pomeraju u memoriji fiksne
 veličine, moguće je razviti napredne algoritme upravljanja memorijom koji
 koriste ponašanje programa.
 Segmentacija koja je vidljiva za programera omogućuje mu da rukuje rastućim
 strukturama podataka, modularnošću i podrškom deljenju i zaštiti.
 Da bi se objedinile prednosti oba pristupa, neki sistemi su opremljeni
 posebno prilagođenim procesorskim hardverom i softverom operativnog sistema.
 U kombinovanom sistemu straničenja i segmentacije, adresni prostor korisnika
 je podeljen na segmente, pri čemu programer zna koliko ih ima.
 Svaki segment je podeljen na stranice fiksne veličine, koja odgovara dužini
 okvira u glavnoj memoriji.
 Ako je veličina segmenta manja od veličine stranice, segment zauzima samo
 jednu stranicu.
 S tačke gledišta programera, logička adresa se i dalje sastoji od broja
 segmenta i pomeraja u segmentu.
 S tačke gledišta sistema, pomeraj u segmentu se vidi kao broj stranice
 i pomeraj u stranici za stranicu sa zadatim segmentom.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.11.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.11: Kombinacija segmentacije i straničenja.
\end_layout

\begin_layout Subsection
Zaštita i deljenje 
\end_layout

\begin_layout Standard
Sâma segmentacija
\begin_inset Index idx
status open

\begin_layout Plain Layout
segmentacija!zaštita i deljenje
\end_layout

\end_inset

 primenjuje zaštitu i deljenje jer svaka tabela upisa segmenata sadrži dužinu
 i osnovnu adresu, pa program ne može da pristupi adresama van tog prostora.
 Da bi se ostvarilo deljenje, segment može da bude referenciran u tabelama
 segmenata nekoliko procesa.
 Isti mehanizam je moguće primeniti i za straničenje, ali se teže implementira
 jer struktura stranica programa i podataka nije vidljiva za programera.
 Napredniji mehanizam je korišćenje strukture zaštitnih prstenova.
 Svaki prsten sa nižim brojem (ili unutrašnji prsten) ima veće privilegije
 od prstena sa većim brojem (spoljašnjeg prstena).
 Prsten broj 0 obično je rezervisan za funkcije jezgra operativnog sistema,
 a prsten najvećeg broja za korisničke aplikacije.
 Program može da pristupi samo podacima koji se nalaze u istom prstenu ili
 prstenu sa manjom privilegijom, odnosno da pozove servis koji je u istom
 prstenu ili prstenu sa većom privilegijom.
 
\end_layout

\begin_layout Section
Operativni sistem i upravljanje memorijom 
\end_layout

\begin_layout Standard
Tokom projektovanja dela operativnog sistema koji se bavi upravljanjem memorijom
 treba doneti tri važne odluke: 
\end_layout

\begin_layout Itemize
da li će se koristiti virtuelna memorija, 
\end_layout

\begin_layout Itemize
da li će se koristiti straničenje, segmentacija ili njihova kombinacija
\end_layout

\begin_layout Itemize
koji algoritmi će se koristiti za različite aspekte upravljanja memorijom
\end_layout

\begin_layout Subsection
Politika učitavanja stranice u glavnu memoriju 
\end_layout

\begin_layout Standard
Stranice procesa treba da se učitaju na zahtev, a može se iskoristiti i
 predstraničenje učitavanjem
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!politika učitavanja
\end_layout

\end_inset

 većeg broja susednih stranica odjednom.
 
\end_layout

\begin_layout Subsection
Politika smeštanja stranica 
\end_layout

\begin_layout Standard
Određuje gde u fizičkoj memoriji smestiti delove procesa.
 Kod sistema
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!politika smeštanja
\end_layout

\end_inset

 koji koriste isključivo segmentaciju, dolazećem segmentu mora da se nađe
 slobodan prostor odgovarajuće veličine.
 
\end_layout

\begin_layout Subsection
Politika zamene stranica
\end_layout

\begin_layout Standard
Kada je memorija puna, mora da se donese odluka koja stranica (ili stranice
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!politika zamene
\end_layout

\end_inset

) mora da bude zamenjena.
 Ovaj deo tehnika upravljanja memorijom je verovatno onaj koji se najviše
 proučava.
 Kada su svi okviri u glavnoj memoriji zauzeti, a neophodno je učitati novu
 stranicu da bi se razrešila pogrešna stranica (page fault), politika zamene
 određuje koja stranica u memoriji treba da bude zamenjena.
 Cilj je pronaći stranicu koja neće biti referencirana u skorijoj budućnosti.
 Taj postupak se ne može primeniti jer zahteva da operativni sistem primeni
 predviđanje, ali daje optimalni algoritam koji služi za procenu kvaliteta
 drugih algoritama.
 Zbog principa lokaliteta, velika je verovatnoća da će stranice koje su
 poslednje referencirane biti referencirane u skorašnjoj budućnosti.
 Većina politika pokušava da predvidi buduće ponašanje na osnovu analize
 prethodnog ponašanja.
 Što je efikasnija i neprednija politika zamene, to su veći i hardverski
 i softverski troškovi primene tog rešenja.
 Postoje i određena ograničenja, na primer pojedini okviri u glavnoj memoriji
 mogu biti zaključani, pa se stranica koja je privremeno smeštena u takvom
 okviru ne može zameniti.
 Osnovni algoritmi izbora stranica
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!algoritmi zamene
\end_layout

\end_inset

 koje treba da se zamene su: 
\end_layout

\begin_layout Itemize
optimalni (OPT)
\end_layout

\begin_layout Itemize
najmanje korišćena stranica u poslednje vreme (Least recently used – LRU)
\end_layout

\begin_layout Itemize
prva stranica učitana, prva zamenjena (First in - first out – FIFO)
\end_layout

\begin_layout Itemize
algoritam sata (CLOCK)
\end_layout

\begin_layout Standard
Poređenje algoritama za zamenu stranica je prikazano na Slici 6.12.
 Optimalni algoritam (OPT) se zasniva na tome da se za zamenu izabere stranica
 za koju je procenjeno vreme sledećeg referenciranja najduže.
 To podrazumeva da operativni sistem treba da “zna” buduće događaje, pa
 algoritam služi samo za poređenje.
 Politika zamene LRU koja koristi najmanje korišćenu (referenciranu) stranicu
 u poslednje vreme na osnovu principa lokaliteta treba da pronađe stranicu
 koja ne bi trebalo da bude referencirana u skoroj budućnosti.
 Ovo je slično optimalnom algoritmu.
 Problem kod ovog algoritma je to što se teško primenjuje i prouzrokuje
 velike dodatne troškove.
 
\end_layout

\begin_layout Standard
Algoritam FIFO (prva stranica učitana, prva zamenjena) posmatra okvire stranica
 dodeljene procesu kao kružni bafer.
 Stranice se uklanjaju po kružnom principu (round-robin).
 Ovaj algoritam zamene je najprostiji za primenu, a zamenjuje stranicu koja
 je najduže u memoriji.
 Loša osobina mu je to što će ta stranica možda potrebna u sledećem referenciran
ju.
 
\end_layout

\begin_layout Standard
Najprostija forma algoritma sata (CLOCK) zahteva dodatni bit koji se zove
 bit korišćenja.
 Kada se stranica po prvi put učita u okvir u memoriji, bit korišćenja za
 taj okvir se postavi na 1.
 Kada se stranica referencira, bit korišćenja se postavlja na 1.
 Kada treba da se zameni stranica, operativni sistem pregleda bafer da bi
 našao okvir sa bitom korišćenja postavljenim na 0.
 Tokom pretraživanja zbog zamene svaki bit korišćenja postavljen na 1 menja
 se u 0.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika6.12.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6.12: Poređenje algoritama zamene stranica.
\end_layout

\begin_layout Subsection
Upravljanje rezidentnim skupom
\end_layout

\begin_layout Standard
Straničenjem virtuelne memorije nije neophodno i nije moguće učitati sve
 stranice jednog procesa u glavnu memoriju i pripremiti ih za izvršenje.
 Operativni sistem treba da odluči koliko stranica da učita u glavnu memoriju,
 odnosno koliko memorije da dodeli određenom procesu.
 Kod savremenih operativnih sistema postoji: 
\end_layout

\begin_layout Itemize
Fiksna alokacija: dodeljuje procesu fiksan broj stranica unutar kojih se
 izvršava.
 Kada se pojavi pogrešna stranica, jedna od stranica procesa treba da se
 zameni.
 
\end_layout

\begin_layout Itemize
Promenljiva alokacija: dozvoljava da se procesu tokom vremena dodeljuje
 promenljiv broj okvira.
 Ako je broj okvira premali, pogrešne stranice će se brzo pojavljivati,
 a ako je alokacija prevelika, u glavnoj memoriji postojaće višak programa.
 Operativni sistem održava listu slobodnih okvira.
 Slobodan okvir se dodaje rezidentnom skupu procesa kada se pogrešna strana
 pojavi (to je tzv.
 lokalna zamena).
 Ako nema slobodnih okvira, zamenjuje se neki okvir drugog procesa (tzv.
 globalna zamena).
 
\end_layout

\begin_layout Subsection
Politika čišćenja 
\end_layout

\begin_layout Standard
Politika čišćenja
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!politika čišćenja
\end_layout

\end_inset

 je suprotna od politike učitavanja stranice.
 Izmenjene stranice procesa mogu biti upisane tokom zamene, ili se može
 iskoristiti politika pretčišćenja koja klasterizuje izlaznih aktivnosti
 upisujući odjednom veći broj stranica.
 Često se koristi pristup baferovanja stranica.
 Zamenjena stranica se smešta u dve liste: izmenjenu i neizmenjenu.
 Stranice u izmenjenoj listi se periodično upisuju u blokovima.
 
\end_layout

\begin_layout Subsection
Politika kontrole 
\end_layout

\begin_layout Standard
Kontrola učitavanja bavi se određivanjem broja stranica koje će se nalaziti
 u glavnoj memoriji u bilo kom trenutku.
 Operativni sistem kontroliše nivo multiprogramiranja: suviše procesa može
 dovesti do thrashinga (odeljak 6.5.2).
 Ako stepen multiprogramiranja treba da se smanji, nekoliko tekućih rezidentnih
 procesa mora biti suspendovano, što se može utvrditi prema sledećim kriterijumu
ma: 
\end_layout

\begin_layout Itemize
proces sa najmanjim prioritetom, 
\end_layout

\begin_layout Itemize
proces koji nema svoje stranice u glavnoj memoriji, 
\end_layout

\begin_layout Itemize
poslednji proces koji je aktiviran, 
\end_layout

\begin_layout Itemize
proces sa najmanjim rezidentnim skupom, 
\end_layout

\begin_layout Itemize
najveći proces, itd.
 
\end_layout

\begin_layout Chapter
Sistem datoteka
\end_layout

\begin_layout Standard
S tačke gledišta korisnika, jedan od najinteresantnijih delova operativnog
 sistema je sistem datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistem datoteka
\end_layout

\end_inset

 (file system).
 On obezbeđuje apstrakcije resursa koji su obično pridruženi uređajima za
 sekundarno skladištenje.
 Sistem datoteka dozvoljava korisniku da kreira kolekcije podataka zvane
 
\series bold
datoteke
\series default
 (files) sa željenim osobinama kao što su: 
\end_layout

\begin_layout Itemize
dugoročno postojanje: datoteke se skladište na disku ili nekom drugom sekundarno
m skladištu i ne gube se nakon odjavljivanja korisnika ili isključivanja
 računara, 
\end_layout

\begin_layout Itemize
mogućnost deljenja između procesa: datoteke imaju imena i mogu im se dodeliti
 dozvole pristupa koje kontrolišu deljenje
\end_layout

\begin_layout Itemize
struktura: zavisno od sistema, datoteka može da ima internu strukturu koja
 je pogodna za određene aplikacije.
 
\end_layout

\begin_layout Standard
Pored toga datoteka može biti organizovana hijerarhijski ili preko složenijih
 struktura kako bi se odrazila veza između datoteka.
 Svaki sistem datoteka obezbeđuje i skup funkcija koje se mogu primenjivati
 na datoteke.
 Tipične operacije uključuju: 
\end_layout

\begin_layout Itemize

\shape italic
Create
\shape default
: definiše se nova datoteka i smešta u strukturu datoteka.
 
\end_layout

\begin_layout Itemize

\shape italic
Delete
\shape default
: datoteka se uklanja iz strukture datoteka i uništava.
 
\end_layout

\begin_layout Itemize

\shape italic
Open
\shape default
: proces deklariše da će otvoriti postojeću datoteku, a sistem dozvoljava
 procesu da izvrši funkcije nad datotekom.
 
\end_layout

\begin_layout Itemize

\shape italic
Close
\shape default
: datoteka se zatvara za dati proces, tako da on ne može više da izvršava
 funkcije nad datotekom sve dok je proces ponovo ne otvori.
 
\end_layout

\begin_layout Itemize

\shape italic
Read
\shape default
: proces čita sve podatke iz datoteke (ili deo podataka).
 
\end_layout

\begin_layout Itemize

\shape italic
Write
\shape default
: proces ažurira datoteku tako što dodaje nove podatke koji joj povećavaju
 veličinu ili tako što menja vrednosti postojećih podataka u datoteci.
\end_layout

\begin_layout Section
Struktura podataka
\end_layout

\begin_layout Itemize

\shape italic
Polje
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
polje
\end_layout

\end_inset

 (field): osnovni element podataka
\begin_inset Index idx
status open

\begin_layout Plain Layout
struktura podataka
\end_layout

\end_inset

.
 Jedno polje sadrži jednu vrednost, kao što je prezime studenta, datum ili
 očitana vrednost senzora.
 Polje je definisano svojom dužinom i tipom podatka (npr.
 ASCII string ili decimal).
 
\end_layout

\begin_layout Itemize

\shape italic
Zapis
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
zapis
\end_layout

\end_inset

 (record): skup povezanih polja koji aplikacija tretira kao jedinicu.
 
\end_layout

\begin_layout Itemize

\shape italic
Datoteka
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke
\end_layout

\end_inset

 (file): skup sličnih zapisa.
 Korisnici i aplikacije datoteku mogu da referenciraju po imenu.
 Datoteke imaju imena i mogu se kreirati i brisati.
 Ograničenja pristupa obično se primenjuju na nivou datoteka.
 Kod nekih složenijih sistema moguća je kontrola na nivou zapisa, čak i
 polja.
 
\end_layout

\begin_layout Itemize

\shape italic
Baza podataka
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
baza podataka
\end_layout

\end_inset

 (database): baza podataka je skup povezanih podataka.
 Veza između podataka je eksplicitna; baza podataka projektovana je tako
 da je može koristiti veći broj aplikacija.
 Baza podataka se sastoji od jednog ili više tipova datoteka.
 Sistem za upravljanje bazama podataka obično je odvojen od operativnog
 sistema.
 
\end_layout

\begin_layout Section
Osnovne operacije sa datotekama
\end_layout

\begin_layout Itemize

\shape italic
Retrieve_All
\shape default
: čitanje svih zapisa datoteke
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!osnovne operacije
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Itemize

\shape italic
Retrieve_One
\shape default
: čitanje samo jednog zapisa.
 
\end_layout

\begin_layout Itemize

\shape italic
Retrieve_Next
\shape default
: čitanje zapisa koji je sledeći u nekom logičkom nizu u odnosu na poslednji
 dobijeni zapis.
 
\end_layout

\begin_layout Itemize

\shape italic
Retrieve_Previous
\shape default
: čitanje zapisa koji prethodi poslednjem dobijenom zapisu.
 
\end_layout

\begin_layout Itemize

\shape italic
Insert_One
\shape default
: umetanje novog zapisa u datoteku.
 
\end_layout

\begin_layout Itemize

\shape italic
Delete_One
\shape default
: brisanje postojećeg zapisa.
 
\end_layout

\begin_layout Itemize

\shape italic
Update_One
\shape default
: čitanje zapisa, ažuriranje jednog ili više polja, i ponovni upis ažuriranog
 zapisa u datoteku.
 
\end_layout

\begin_layout Itemize

\shape italic
Retrieve_Few
\shape default
: čitanje više zapisa.
 
\end_layout

\begin_layout Section
Sistemi za upravljanje datotekama
\end_layout

\begin_layout Standard
Sistem upravljanja datotekama
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!sistemi upravljanja
\end_layout

\end_inset

 je skup sistemskog softvera koji korisnicima i aplikacijama obezbeđuje
 usluge pri korišćenju datoteka.
 Jedini način da korisnik ili aplikacija pristupe datoteci je kroz sistem
 upravljanja datotekama.
 Ciljevi ovog sistema su sledeći: 
\end_layout

\begin_layout Itemize
izaći u susret potrebama upravljanja podacima i zahtevima korisnika, što
 uključuje skladištenje podataka i sposobnost izvršenja ranije pomenutih
 operacija,
\end_layout

\begin_layout Itemize
garantovati da su podaci u datotekama ispravni, 
\end_layout

\begin_layout Itemize
optimizovati karakteristike, sa sistemske tačke gledišta, u odnosu na celokupnu
 propusnost i sa tačke gledišta korisnika u odnosu na vreme odziva, 
\end_layout

\begin_layout Itemize
obezbediti U/I podršku za veliki broj različitih tipova uređaja za skladištenje,
 
\end_layout

\begin_layout Itemize
minimizirati ili otkloniti potencijalne mogućnosti za gubljenje ili uništavanje
 podataka, 
\end_layout

\begin_layout Itemize
obezbediti standardizovan skup U/I interfejsnih rutina za korišćenje procesa,
 
\end_layout

\begin_layout Itemize
obezbediti U/I podršku za više korisnika, za slučaj višekorisničkih sistema.
 
\end_layout

\begin_layout Standard
Za interaktivni sistem opšte namene definisaćemo minimalan skup zahteva
 za svakog korisnika da bi mogao da: 
\end_layout

\begin_layout Enumerate
kreira, briše, čita, upisuje i menja datoteke
\end_layout

\begin_layout Enumerate
ima kontrolisan pristup datotekama drugih korisnika
\end_layout

\begin_layout Enumerate
kontroliše koji tipovi pristupa su dozvoljeni korisnicima datoteka
\end_layout

\begin_layout Enumerate
restrukturira datoteke u oblik koji odgovara problemu
\end_layout

\begin_layout Enumerate
premešta podatke između datoteka 
\end_layout

\begin_layout Enumerate
sigurno uskladišti i povrati datoteke u slučaju oštećenja
\end_layout

\begin_layout Enumerate
pristupi datotekama koristeći simbolička imena.
 
\end_layout

\begin_layout Section
Arhitektura sistemskog softvera za rad sa datotekama
\end_layout

\begin_layout Standard
Tipična softverska organizacija data je na Slici 8.1.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika8.1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8.1: Sistemski softver za rad sa datotekama
\end_layout

\begin_layout Standard
Na najnižem nivou, upravljački programi (drajveri) uređaja komuniciraju
 direktno sa periferijskim uređajima ili njihovim kontrolerima ili kanalima.
 Upravljački program uređaja je odgovoran za pokretanje U/I operacija na
 uređaju i obradu U/I zahteva.
 Za operacije sa datotekama tipični uređaji su diskovi.
 Upravljački programi uređaja su obično sastavni deo operativnih sistema.
 Sledeći nivo je označen kao osnovni sistem datoteka, ili fizički U/I nivo.
 To je osnovni interfejs ka spoljašnjem okruženju računarskog sistema zadužen
 za smeštanje blokova na uređaj za sekundarno skladištenje i baferovanje
 tih blokova u glavnoj memoriji.
 Ovaj nivo se ne bavi sadržajem podataka ili struktura uključenih datoteka
 i deo je operativnog sistema.
 
\end_layout

\begin_layout Standard
Osnovni U/I supervizor je odgovoran za sve početne i završne U/I operacije
 sa datotekama.
 Na ovom nivou održavaju se kontrolne strukture koje se bave ulazom i izlazom
 uređaja, raspoređivanjem i statusom datoteka.
 Osnovni U/I supervizor bira uređaj na kome će se izvršiti U/I operacije
 sa datotekom.
 On se takođe bavi raspoređivanjem i pristupom disku da bi se optimizovale
 performanse.
 Deo je operativnog sistema.
 U/I baferi se pridružuju, a sekundarna memorija se alocira.
 Logički U/I omogućuje korisnicima i aplikacijama da pristupe zapisima.
 Dakle, gde god se osnovni sistem datoteka bavi blokovima podataka, logički
 U/I modul se bavi zapisima datoteka.
 Nivo sistema datoteka najbliži korisniku često se označava kao metod pristupa.
 On obezbeđuje standardni interfejs između aplikacija i sistema datoteka
 s jedne strane, i uređaja koji čuvaju te podatke s druge strane.
 
\end_layout

\begin_layout Section
Funkcije za upravljanje datotekama
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika8.2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8.2: Elementi upravljanja datotekama.
\end_layout

\begin_layout Standard
Korisnici i aplikacioni programi komuniciraju sa sistemom datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!funkcije za upravljanje
\end_layout

\end_inset

 tako što šalju komande za kreiranje i brisanje datoteka ili izvršavanje
 operacija sa njima.
 Sistem datoteka pre svega treba da prepozna i locira izabranu datoteku.
 To zahteva korišćenje neke vrste direktorijuma koji služi za opis lokacije
 svih datoteka i njihovih atributa.
 Samo ovlašćeni korisnici imaju pristup određenim datotekama na određene
 načine.
 Osnovne operacije koje korisnik ili aplikacija mogu da izvrše sa datotekom
 izvršavaju se na nivou zapisa.
 Korisnici vide datoteku kao organizovanu sekvencijalnu strukturu zapis
\begin_inset Index idx
status open

\begin_layout Plain Layout
zapisi!sekvencijalna struktura
\end_layout

\end_inset

a (zapisi korisnika su uskladišteni po abecednom redosledu od poslednjeg
 imena).
 Kada se korisnici i aplikacije bave zapisima, U/I je dat na osnovu blokova.
 Da bi se podržao U/I rad sa blokovima datoteke, potrebno je više funkcija.
 Neophodno je upravljanje sekundarnom memorijom, što podrazumeva alociranje
 datoteka i slobodnih blokova.
 Disk raspoređivanje i alociranje datoteka se posmatraju kroz optimizaciju
 performansi.
 
\end_layout

\begin_layout Section
Organizacija datoteka
\end_layout

\begin_layout Standard
Organizaciju datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!organizacija
\end_layout

\end_inset

 definišemo preko logičkog strukturiranja zapisa, kao što je određeno načinom
 na koji im se pristupa.
 Fizička organizacija datoteke na uređaju za sekundarno skladištenje zavisi
 od strategije rada sa blokovima i strategije alokacije datoteke.
 U izboru načina organizovanja datoteka potrebno je voditi računa o više
 kriterijuma: 
\end_layout

\begin_layout Itemize
kratko vreme pristupa
\end_layout

\begin_layout Itemize
lako ažuriranje
\end_layout

\begin_layout Itemize
ekonomičnost skladištenja
\end_layout

\begin_layout Itemize
lako održavanje 
\end_layout

\begin_layout Itemize
pouzdanost 
\end_layout

\begin_layout Standard
Relativan prioritet ovih kriterijuma zavisi od aplikacija koje koriste datoteku.
 Ovi kriterijumi su često međusobno u suprotnosti.
 Nabrojaćemo nekoliko alternativnih načina organizovanja datoteka koji se
 najčešće primenjuju:
\end_layout

\begin_layout Itemize
gomila podataka (pile) 
\end_layout

\begin_layout Itemize
sekvencijalna datoteka 
\end_layout

\begin_layout Itemize
indeksno sekvencijalna datoteka 
\end_layout

\begin_layout Itemize
indeksna datoteka 
\end_layout

\begin_layout Itemize
direktna (heširana) datoteka
\end_layout

\begin_layout Subsection
Gomilanje podataka 
\end_layout

\begin_layout Standard
Najprostiji oblik organizovanja datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!sa gomilanjem podataka
\end_layout

\end_inset

 je gomilanje podataka (pile).
 Podaci su skupljeni po redosledu kako stižu.
 Svaki zapis se sastoji od jedne grupe podataka.
 Svrha gomilanja je da prosto prikupi gomilu podataka i sačuva ih.
 Zapisi mogu da imaju različita polja, ili slična polja u različitom redosledu.
 Na taj način svako polje je samoopisujuće, uključujući i ime polja kao
 i vrednost.
 Dužina svakog polja mora biti implicitno označena delimiterima, eksplicitno
 uključena kao potpolje, ili standardna (default) za takav tip polja (Slika
 8.3).
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika8.3.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8.3: Gomilanje podataka (pile).
\end_layout

\begin_layout Standard
Pošto ne postoji struktura za 
\begin_inset Quotes eld
\end_inset

nagomilanu
\begin_inset Quotes erd
\end_inset

 datoteku, zapisu se pristupa nakon detaljnog pretraživanja.
 Ako želimo da nađemo zapis koji sadrži određeno polje sa određenom vrednošću,
 neophodno je ispitati sve zapise 
\begin_inset Quotes eld
\end_inset

na gomili
\begin_inset Quotes erd
\end_inset

 dok se ne pronađe željeni zapis, ili dok se ne pretraži cela datoteka.
 Gomilanje se koristi kod datoteka kada su podaci prikupljeni i uskladišteni
 pre obrade ili kada ih nije lako organizovati.
 Ovaj tip datoteka dobro koristi prostor kada su veličina i struktura uskladište
nih podataka promenljivi i pogodan je kada su pretraživanja detaljna i laka
 za ažuriranje.
 Međutim, ovakav tip datoteka ne odgovara mnogim aplikacijama.
 
\end_layout

\begin_layout Subsection
Sekvencijalna datoteka 
\end_layout

\begin_layout Standard
Najčešće primenjivan oblik strukture datoteke je sekvencijalna datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!sekvencijalne
\end_layout

\end_inset

 (Slika 8.4).
 Kod ovog tipa datoteke za zapise se koristi fiksni format.
 Svi zapisi su iste dužine, sastavljeni od istog broja polja fiksne dužine.
 Pošto su dužina i pozicija svakog polja poznati, samo vrednosti polja treba
 da budu uskladištene; ime polja i dužina svakog polja su atributi strukture
 datoteke.
 Jedno posebno polje, obično prvo u svakom zapisu, označeno je kao 
\series bold
polje sa ključem
\series default
 (key field).
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika8.4.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8.4: Sekvencijalna datoteka.
\end_layout

\begin_layout Standard
Polje sa ključem
\begin_inset Index idx
status open

\begin_layout Plain Layout
polje sa ključem
\end_layout

\end_inset

 jedinstveno identifikuje zapis; vrednosti ključeva za različite zapise
 su uvek različiti.
 Zapisi su uskladišteni kao sekvence ključeva: po abecedi za tekstualni
 ključ, odnosno po numeričkom redosledu za numerički ključ.
\end_layout

\begin_layout Standard
Sekvencijalne datoteke se obično koriste u paketnim aplikacijama i u opštem
 slučaju su optimalne za takve aplikacije ako one uključuju obradu svih
 zapisa.
 Sekvencijalno organizovanje datoteka se primenjuje za skladištenje na trakama
 i diskovima.
 Za interaktivne aplikacije koje uključuju upite i(li) ažuriranje pojedinačnih
 zapisa, sekvencijalna datoteka daje slabe performanse.
 Pristup zahteva sekvencijalno pretraživanje datoteke na osnovu ključa.
 Ako cela datoteka ili njen veći deo može da se učita u glavnu memoriju
 odjednom, moguće su efikasnije tehnike pretraživanja.
 Međutim, da bi se pristupilo zapisu u velikoj sekvencijalnoj datoteci,
 obrada postaje obimna što prouzrokuje veliko kašnjenje.
 Pojavljuju se i problemi sa dodavanjem novog sadržaja datoteci.
 Sekvencijalna datoteka je po pravilu uskladištena po jednostavnom sekvencijalno
m redosledu zapisa unutar blokova, što znači da se fizička organizacija
 datoteke na traci ili disku direktno poklapa sa njenom logičkom organizacijom.
 U ovom slučaju, uobičajeni postupak je da se novi zapisi smeste u odvojenu
 
\begin_inset Quotes eld
\end_inset

nagomilanu
\begin_inset Quotes erd
\end_inset

 (pile) datoteku, nazvanu log datoteka, transakciona datoteka ili dnevnik.
 Periodično paketno (batch) ažuriranje se izvršava tako što spaja log datoteku
 sa glavnom datotekom da bi se kreirala nova datoteka po ispravnom sledu
 ključa.
 Alternativa je fizičko organizovanje sekvencijalne datoteke po principu
 ulančane liste.
 Jedan ili više zapisa se skladište u svaki fizički blok.
 Svaki blok na disku sadrži pokazivač na sledeći blok.
 Umetanje novih zapisa podrazumeva rad sa pokazivačima, ali ne zahteva da
 novi zapisi zauzmu određenu poziciju fizičkog bloka.
 Na taj način se ostvaruju dodatne pogodnosti u odnosu na vreme obrade i
 opšte troškove.
 
\end_layout

\begin_layout Subsection
Indeksno sekvencijalna datoteka 
\end_layout

\begin_layout Standard
Popularan pristup kojim se prevazilaze nedostaci sekvencijalnih datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!indeksno sekvencijalne
\end_layout

\end_inset

 jeste korišćenje indeksno sekvencijalnih datoteka.
 Indeksno sekvencijalna datoteka održava rad sa ključem kao sekvencijalna
 datoteka: zapisi su organizovani u sekvence na osnovu polja sa ključem.
 Dodatak su indeks datoteke za podršku slučajnom (random) pristupu i datoteke
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!sa prelivanjem
\end_layout

\end_inset

 sa "prelivanjem" (overflow).
 Indeks ubrzava pronalaženje okruženja u blizini željenog zapisa.
 Datoteka sa prelivanjem je slična log datoteci koja se koristi sa sekvencijalni
m datotekama, ali je integrisana.
 To znači da na zapis koji ne može da stane u datoteku 
\begin_inset Quotes eld
\end_inset

sa prelivanjem
\begin_inset Quotes erd
\end_inset

 pokazuje pokazivač poslednjeg zapisa u toj datoteci (Slika 8.5).
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika8.5.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8.5: Indeksno sekvencijalna datoteka.
\end_layout

\begin_layout Standard
U najprostijoj indeksno sekvencijalnoj strukturi koristi se jedan nivo indeksira
nja.
 Indeks je u ovom slučaju jedna sekvencijalna datoteka.
 Svaki zapis u indeksnoj datoteci sastoji se iz dva polja: polja sa ključem
\begin_inset Index idx
status open

\begin_layout Plain Layout
polje sa ključem
\end_layout

\end_inset

 (key field), koje je isto kao polje sa ključem u glavnoj datoteci i pokazivača
 na glavnu datoteku.
 Da bi se pronašlo određeno polje, pretražuje se indeks da bi se našla najveća
 vrednost ključa koja je jednaka željenoj vrednosti ključa ili joj prethodi.
 Pretraživanje se nastavlja u glavnoj datoteci na lokaciji na koju pokazuje
 pokazivač.
 Dodavanje u datoteku se obavlja na sledeći način: svaki zapis u glavnoj
 datoteci sadrži jedno dodatno polje koje nije vidljivo za aplikaciju, a
 koje je pokazivač na datoteku sa prelivanjem.
 Kada novi zapis treba da se doda u datoteku, on se dodaje datoteci sa prelivanj
em.
 Zapis u glavnoj datoteci koji istog trenutka prethodi novom zapisu u logičkoj
 sekvenci se ažurira tako da sadrži pokazivač na novi zapis u datoteci sa
 prelivanjem.
 Ako je prethodni zapis sâm u datoteci sa prelivanjem, onda se pokazivač
 na taj zapis ažurira.
 Kao i kod sekvencijalne datoteke, indeksna sekvencijalna datoteka se povremeno
 spaja sa datotekom sa prelivanjem u paketnom režimu.
 
\end_layout

\begin_layout Standard
Indeksno sekvencijalna datoteka primetno smanjuje vreme potrebno za pristup
 jednom zapisu, bez žrtvovanja sekvencijalne prirode datoteke.
 Da bi se sekvencijalno obradila cela datoteka, zapisi u glavnoj datoteci
 se obrađuju redom sve dok se naiđe na pokazivač na datoteku sa prelivanjem;
 zatim se pristup nastavlja u datoteci sa prelivanjem dok se ne naiđe na
 null pokazivač, kada se pristup nastavlja na mestu gde se stalo u glavnoj
 datoteci.
 Da bi se povećala efikasnost u pristupu može se koristiti indeksiranje
 u više nivoa.
 Na taj način se najniži nivo indeksne datoteke posmatra kao sekvencijalna
 datoteka, a najviši nivo indeksne datoteke se kreira za tu datoteku.
 
\end_layout

\begin_layout Subsection
Indeksna datoteka
\end_layout

\begin_layout Standard
Indeksna sekvencijalna datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!indeksne
\end_layout

\end_inset

 zadržava jedno ograničenje sekvencijalne datoteke: efikasnost obrade je
 ograničena zbog toga što se zasniva na jednom polju datoteke.
 Kada je neophodno pretražiti zapis na osnovu nekog drugog atributa, a ne
 na osnovu polja sa ključem, nijedan oblik sekvencijalnih datoteka nije
 odgovarajući.
 U nekim aplikacijama ta funkcija je poželjna.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika8.6.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8.6: Indeksna datoteka.
\end_layout

\begin_layout Standard
Da bi se postigla ova prilagodljivost, potrebna je struktura koja koristi
 višestruke indekse, po jedan za svaki tip polja koje može biti subjekat
 pretraživanja.
 U opštim indeksnim datotekama, pojam sekvencijalnosti i jedan ključ se
 odbacuju.
 Zapisima se pristupa isključivo preko indeksa.
 Usled toga nema ograničenja smeštanja zapisa sve dok pokazivač na najmanje
 jedan indeks referencira taj zapis.
 Šta više, mogu da se iskoriste zapisi promenljive dužine.
 Koriste se dva tipa indeks
\begin_inset Index idx
status open

\begin_layout Plain Layout
indeks!detaljan
\end_layout

\end_inset

a: detaljni (exhaustive) i parcijaln
\begin_inset Index idx
status open

\begin_layout Plain Layout
indeks!parcijalan
\end_layout

\end_inset

i (partial).
 Detaljni indeks sadrži jedan upis za svaki zapis u glavnoj datoteci.
 Sâm indeks je organizovan kao sekvencijalna datoteka zbog lakog pretraživanja.
 Parcijalni indeks sadrži upise za zapise za koje postoji polje interesovanja.
 Ako se koriste zapisi promenljive dužine, neki zapisi neće sadržavati sva
 polja.
 Kada se novi zapis dodaje glavnoj datoteci svi indeksi datoteka moraju
 da budu ažurirani.
 Indeksne datoteke se najčešće koriste u aplikacijama u kojima su vremenske
 linije informacija kritične, a podaci se retko detaljno pretražuju (npr.
 rezervacije avionskih karata i kontrolni sistemi inventara).
 
\end_layout

\begin_layout Subsection
Direktne (heširane) datoteke
\end_layout

\begin_layout Standard
Ove datoteke koriste mogućnost direktnog pristupa bilo kom bloku poznate
 adrese na disku.
 Kao i sa sekvencijalnim i indeksno sekvencijalnim datotekama, za svaki
 zapis je neophodno polje sa ključem.
 Međutim, ovde nema sekvencijalnog redosleda.
 Direktne datoteke
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!direktne
\end_layout

\end_inset

 koriste heširanje vrednosti ključa u kombinaciji sa datotekama sa prelivanjem.
 Često se koriste u primenama gde se zahteva brzo pretraživanje, gde se
 koriste se zapisi fiksne dužine ili tamo gde se uvek pristupa samo jednom
 zapisu.
 Primeri su direktorijumi, tabele sa cenama, rasporedi i tabele sa imenima.
 
\end_layout

\begin_layout Section
Direktorijumi datoteka
\end_layout

\begin_layout Standard
Direktorijumi datoteka su pridruženi svakom sistemu za upravljanje datotekama
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!direktorijumi
\end_layout

\end_inset

 i skupu datoteka.
 Oni sadrže informacije o datotekama, uključujući atribute, lokacije i vlasništv
o.
 Oprativni sistem upravlja većim delom ovih informacija, posebno onima koje
 su povezane sa skladištenjem.
 Sâm direktorijum je datoteka kojoj mogu da pristupe različite rutine za
 upravljanje datotekama.
 Mada su neke informacije u direktorijumima na raspolaganju korisnicima
 i aplikacijama, one se dobijaju indirektno, od sistemskih rutina.
 S tačke gledišta korisnika, direktorijum obezbeđuje mapiranje između imena
 datoteka, poznatih korisnicima i aplikacijama, i samih datoteka.
 Svaki upis, tj.
 ulaz u datoteku uključuje ime datoteke.
 Gotovo svi sistemi rade sa različitim tipovima datoteka i različitim organizaci
jama datoteka, pa su sve ove informacije na raspolaganju.
 Važna kategorija informacija o svakoj datoteci je skladištenje, uključujući
 lokaciju i veličinu.
 U deljenim sistemima važno je obezbediti informacije za kontrolu pristupa
 datoteci.
 Po pravilu je jedan korisnik vlasnik datoteke i može garantovati određene
 privilegije pristupa drugim korisnicima.
 Na kraju, potrebne su korisne informacije za upravljanje tekućim korišćenjem
 datoteke, kao i zapisi istorije njenog korišćenja.
 
\end_layout

\begin_layout Subsection
Struktura direktorijuma
\end_layout

\begin_layout Standard
Načini na koji se informacije o datotekama skladište veoma se razlikuju
 u različitim sistemima.
 Neke informacije se mogu uskladištiti u zaglavlju zapisa pridruženog datoteci;
 to smanjuje količinu memorije potrebne za direktorijum, čineći ga lakšim
 za održavanje i ubrzava pristup u odnosu na direktorijum
\begin_inset Index idx
status open

\begin_layout Plain Layout
direktorijumi
\end_layout

\end_inset

 u glavnoj memoriji.
 Najprostiji oblik strukture za direktorijum
\begin_inset Index idx
status open

\begin_layout Plain Layout
direktorijumi!struktura
\end_layout

\end_inset

 je lista upisa; postoji po jedan upis za svaku datoteku.
 Ova struktura se može predstaviti jednom sekvencijalnom datotekom sa imenom
 datoteke koje služi kao ključ.
 Ovo nije pogodno kada više korisnika dele sistem, čak ni za jednog korisnika
 koji ima više datoteka.
 Da bi definisali zahteve za strukturom datoteka, objasnićemo operacije
 koje se mogu izvršiti na direktorijumu: 
\end_layout

\begin_layout Itemize

\shape italic
Pretraživanje
\shape default
: kada korisnik ili aplikacija referencira datoteku, direktorijum mora da
 se pretraži da bi se našao upis koji odgovara toj datoteci.
 
\end_layout

\begin_layout Itemize

\shape italic
Kreiranje datoteke
\shape default
: kada se nova datoteka kreira, direktorijumu mora da se doda jedan upis.
 
\end_layout

\begin_layout Itemize

\shape italic
Brisanje datoteke
\shape default
: kada se datoteka obriše, upis mora da se ukloni iz direktorijuma.
 
\end_layout

\begin_layout Itemize

\shape italic
Listanje direktorijuma
\shape default
: ako se traži ceo direktorijum ili njegov deo, daje se spisak datoteka
 čiji je vlasnik korisnik koji je izdao zahtev zajedno sa određenim atributima
 za svaku datoteku (tip, kontrolne informacije pristupa, informacije o korišćenj
u).
 
\end_layout

\begin_layout Itemize

\shape italic
Ažuriranje direktorijuma
\shape default
: pošto se neki atributi datoteka skladište u direktorijumu, promena jednog
 atributa zahteva promenu u odgovarajućem upisu u direktorijumu.
 
\end_layout

\begin_layout Standard
Prosta lista nije pogodna za podršku ovim operacijama, pa se problem rešava
 šemama sa dva nivoa.
 Postoji jedan direktorijum za svakog korisnika i glavni (master) direktorijum.
 Master direktorijum ima po jedan upis za svaki korisnički direktorijum,
 a sadrži adresu i kontrolne informacije pristupa.
 Svaki korisnički direktorijum je lista datoteka tog korisnika.
 Zbog toga imena moraju da budu jedinstvena samo unutar skupa datoteka jednog
 korisnika, a sistem datoteka može lako da primeni ograničenja pristupa
 direktorijumima.
 Međutim, korisniku se ne obezbeđuje pomoć u strukturiranju skupa datoteka.
 Najprilagodljiviji pristup koji je skoro univerzalno prihvaćen je hijerarhijski
 pristup ili pristup strukture stabla.
 I tu postoji master direktorijum koji sadrži veći broj korisničkih direktorijum
a.
 Svaki od ovih korisničkih direktorijuma može da ima poddirektorijume i
 datoteke kao upise.
 Svaki direktorijum je uskladišten kao sekvencijalna datoteka.
 Kada direktorijumi imaju veliki broj upisa, ovakva organizacija može da
 prouzrokuje nepotrebno duga vremena pretraživanja.
 U tom slučaju primenjuje se heš struktura.
 
\end_layout

\begin_layout Subsection
Dodeljivanje imena 
\end_layout

\begin_layout Standard
Korisnicima treba da se omogući da referenciraju datoteke
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!dodeljivanje imena
\end_layout

\end_inset

 simboličkim imenima.
 Svaka datoteka u sistemu mora da ima jedinstveno ime da bi reference na
 nju bile nedvosmislene.
 S druge strane, ne može se tražiti od korisnika da obezbede jedinstvena
 imena, naročito ne u deljenim sistemima.
 Korišćenjem direktorijuma strukture stabla minimiziraju se teškoće u dodeli
 jedinstvenih imena.
 Bilo koja datoteka u sistemu može da bude locirana praćenjem putanje od
 korena (root) ili master direktorijuma prema donjim granama dok se ne stigne
 do datoteke.
 Niz imena direktorijuma zajedno sa samim imenom datoteke definišu ime putanje
 (pathname) za datu datoteku.
 Dakle, datoteke mogu da imaju ista imena, ali imena putanja moraju da im
 budu različita da bi bile jedinstveno definisane u sistemu.
 Za interaktivne korisnike ili procese obično se definiše radni direktorijum
\begin_inset Index idx
status open

\begin_layout Plain Layout
direktorijumi!radni
\end_layout

\end_inset

 (home directory).
 Datoteke se zatim referenciraju relativno u odnosu na taj radni direktorijum.
 
\end_layout

\begin_layout Section
Deljenje datoteka
\end_layout

\begin_layout Standard
U višekorisničkom sistemu uvek postoje zahtevi za dozvolu deljenja datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!deljenje
\end_layout

\end_inset

 između više korisnika.
 Pozabavićemo se sa dva problema: pravom pristupa i upravljanjem istovremenim
 pristupom.
\end_layout

\begin_layout Subsection
Prava pristupa 
\end_layout

\begin_layout Standard
Sistem datoteka treba da obezbedi prilagodljiv način za deljenje datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!prava pristupa
\end_layout

\end_inset

 između korisnika kojim se može kontrolisati pristup određenim datotekama.
 Korisnicima ili grupama korisnika se mogu dodeliti određena prava pristupa
 datoteci.
 Sledeća lista definiše prava pristupa koja se mogu dodeliti određenom korisniku
 za određenu datoteku: 
\end_layout

\begin_layout Itemize

\shape italic
Bez prava pristupa
\shape default
: korisnik ne samo da nema pravo da pristupi datoteci nego je ni ne vidi,
 odnosno ne može da pročita korisnički direktorijum koji uključuje ovu datoteku.
 
\end_layout

\begin_layout Itemize

\shape italic
Znanje
\shape default
: korisnik može da utvrdi da datoteka postoji i ko je njen vlasnik.
 Korisnik zatim može da traži od vlasnika dodatna prava pristupa.
 
\end_layout

\begin_layout Itemize

\shape italic
Izvršavanje
\shape default
: korisnik može da učita i izvrši program, ali ga ne može kopirati.
 
\end_layout

\begin_layout Itemize

\shape italic
Čitanje
\shape default
: korisnik može da čita sadržaj datoteke, kao i da je kopira i izvrši.
 
\end_layout

\begin_layout Itemize

\shape italic
Dodavanje
\shape default
: korisnik može da doda podatke datoteci, najčešće na kraju, ali ne može
 da menja ili briše postojeći sadržaj te datoteke.
 
\end_layout

\begin_layout Itemize

\shape italic
Ažuriranje
\shape default
: korisnik može da menja, briše i dodaje podatke datoteci.
 
\end_layout

\begin_layout Itemize

\shape italic
Promena zaštite
\shape default
: korisnik može da menja dodeljena prava pristupa drugim korisnicima.
 Ova prava obično ima samo vlasnik datoteke.
 U nekim sistemima vlasnik ima pravo da proširi prava na druge korisnike.
 
\end_layout

\begin_layout Itemize

\shape italic
Brisanje
\shape default
: korisnik ima pravo da izbriše datoteku iz sistema datoteka.
 Jedan korisnik se može označiti kao vlasnik datoteke, što je obično osoba
 koja je kreirala datoteku.
 
\end_layout

\begin_layout Standard
Vlasnik ima sva prava pristupa sa prethodne liste i može da dodeli drugim
 korisnicima ta prava.
 Pristup se može obezbediti različitim klasama korisnika: 
\end_layout

\begin_layout Itemize

\shape italic
Određeni korisnik
\shape default
: individualni korisnici označeni korisničkim identitetom ID.
 
\end_layout

\begin_layout Itemize

\shape italic
Grupe korisnika
\shape default
: skup korisnika koji nisu definisani kao samostalni korisnici.
 Sistem mora na neki način da vodi računa o članstvu u grupama korisnika.
 
\end_layout

\begin_layout Itemize

\shape italic
Svi korisnici
\shape default
: svi korisnici imaju pristup sistemu.
 Ovo su javne datoteke.
 
\end_layout

\begin_layout Standard
Veza između korisnika i datoteka definiše se matricom pristupa ili kontrolnom
 listom pristupa
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!kontrolna lista pristupa
\end_layout

\end_inset

 kao na sledećoj slici.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika8.8.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8.7: Kontrolna lista pristupa
\end_layout

\begin_layout Subsection
Istovremeni pristup 
\end_layout

\begin_layout Standard
Kada se dodeli pristup jednom ili više korisnika, operativni sistem ili
 sistem za upravljanje datotekama
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!istovremeni pristup
\end_layout

\end_inset

 moraju da vode računa o istovremenom pristupu datotekama zaključavajući
 ili celu datoteku ili pojedine zapise tokom ažuriranja.
 Ovo je problem čitača/pisača (odeljak 5.6.2).
 Prilikom projektovanja deljenog pristupa datotekama mora se voditi računa
 o međusobnom isključivanju i mogućnosti potpunog zastoja.
 
\end_layout

\begin_layout Section
Zapisi kao blokovi (record blocking)
\end_layout

\begin_layout Standard
Kao što smo ranije objasnili, zapisi su logičke jedinice pristupa strukturiranim
 datotekama, a blokovi
\begin_inset Index idx
status open

\begin_layout Plain Layout
zapisi!kao blokovi
\end_layout

\end_inset

 su U/I jedinice za sekundarno skladištenje.
 Za izvršavanje, U/I zapisi moraju se organizovati kao blokovi.
 Razmotrićemo nekoliko problema koji se pojavljuju.
 
\end_layout

\begin_layout Standard
Da li blokovi treba da budu fiksne ili promenljive dužine? U većini sistema
 blokovi su fiksne dužine, što može da uprosti U/I, alokaciju bafera u glavnoj
 memoriji i organizaciju blokova u sekundarnom skladištenju.
 
\end_layout

\begin_layout Standard
Kolika treba da bude relativna veličina bloka u odnosu na srednju vrednost
 veličine zapisa? Što je veći blok, to je više zapisa koji prolaze jednu
 U/I operaciju.
 Ako se datoteka obrađuje ili pretražuje sekvencijalno, to je prednost zato
 što se broj U/I operacija smanjuje ako se koriste veći blokovi i na taj
 način se ubrzava obrada.
 Ako se zapisima pristupa slučajno i ne posmatra se određeni lokalitet referenci
, onda veći blokovi prouzrokuju nepotreban prenos zapisa koji se ne koriste.
 Međutim, kombinovanjem brzine pojave sekvencijalnih operacija sa potencijalom
 lokaliteta referenci, vreme U/I prenosa opada sa korišćenjem većih blokova.
 Veći blokovi zahtevaju veće U/I bafere, otežavajući upravljanje baferima.
 Kada se određuje veličina bloka, mogu da se iskoriste sledeća tri metoda
 rada sa blokovima: 
\end_layout

\begin_layout Enumerate
Rad sa fiksnim blokovima
\begin_inset Index idx
status open

\begin_layout Plain Layout
blokovi!fiksni
\end_layout

\end_inset

: koriste se zapisi fiksne dužine sa integralnim brojem zapisa uskladištenim
 u bloku.
 Na kraju svakog bloka može se pojaviti neiskorišćen prostor (unutrašnja
 fragmentacija
\begin_inset Index idx
status open

\begin_layout Plain Layout
fragmentacija!unutrašnja
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Enumerate
Rad sa spregnutim blokovima
\begin_inset Index idx
status open

\begin_layout Plain Layout
blokovi!spregnuti
\end_layout

\end_inset

 promenljive dužine: koriste se zapisi promenljive dužine koji se pakuju
 u blokove u kojima nema neiskorišćenog prostora.
 Jedan zapis može da bude spregnut u dva bloka; tada je nastavak zapisa
 definisan pokazivačem na drugi blok.
 
\end_layout

\begin_layout Enumerate
Rad sa nespregnutim blokovi
\begin_inset Index idx
status open

\begin_layout Plain Layout
blokovi!nespregnuti
\end_layout

\end_inset

ma promenljive dužine: koriste se zapisi promenljive dužine, ali se zapisi
 ne nalaze u različitim blokovima.
 U većini blokova postoji prostor koji je neiskorišćen zbog nemogućnosti
 da se iskoristi ostatak bloka ako je sledeći zapis veći od preostalog neiskoriš
ćenog prostora.
 
\end_layout

\begin_layout Standard
Rad sa fiksnim blokovima je zajednički režim za sekvencijalne datoteke sa
 zapisima fiksne dužine.
 Rad sa spregnutim blokovima promenljive dužine je efikasan za skladištenje
 i nije ograničen veličinom zapisa.
 Ova tehnika je teška za primenu jer zapisi koji se nalaze na dva bloka
 zahtevaju dve U/I operacije pa se datoteke teško ažuriraju, bez obzira
 na to kako su organizovane.
 Rad sa nespregnutim blokovima promenljive dužine kao rezultat daje neiskorišćen
 prostor i zapise ograničene veličine u odnosu na veličinu bloka.
 Tehnike koje povezuju zapise i blokove mogu da sarađuju sa hardverom virtuelne
 memorije (ako on postoji).
 U okruženju virtuelne memorije poželjno je da stranica bude osnovna jedinica
 prenosa.
 Pošto su stranice su u opštem slučaju sasvim male, nepraktično ih je tretirati
 kao blok za rad sa nespregnutim blokovima.
 Neki sistemi kombinuju više stranica za kreiranje većeg bloka za U/I svrhe.
 
\end_layout

\begin_layout Section
Upravljanje sekundarnim skladištenjem
\end_layout

\begin_layout Standard
U uređajima za sekundarno skladištenje datoteka se sastoji od skupa blokova.
 Operativni sistem ili sistem za upravljanje datotekama je odgovoran za
 alociranje (dodelu) blokova datotekama.
 Razmotrićemo dva problema u upravljanju.
 Prvo, prostor sekundarnog skladištenja mora da bude dodeljen datotekama,
 i drugo, neophodno je voditi računa o prostoru koji se može iskoristiti
 za alokaciju.
 Ova dva zadatka su povezana.
\end_layout

\begin_layout Standard
Kada se kreira nova datoteka, prostor se dodeljuje datoteci kao jedna jedinica
 ili više susednih jedinica koje nazivamo 
\series bold
porcije
\series default
 (portion).
 Porcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
porcije
\end_layout

\end_inset

 može da bude jedan blok, ali i cela datoteka.
 Primer ovakve strukture je tabela alokacije datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!tabela alokacije
\end_layout

\end_inset

 (file allocation table, FAT) koja je korišćena u DOS-u i nekim drugim operativn
im sistemima.
 
\end_layout

\begin_layout Subsection
Prealokacija i dinamička alokacija 
\end_layout

\begin_layout Standard
Prealokacija
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!prealokacija
\end_layout

\end_inset

 zahteva da maksimalna veličina datoteke bude deklarisana u trenutku zahteva
 za njeno kreiranje.
 Međutim, za mnoge aplikacije veoma je teško (ako ne i nemoguće) proceniti
 koliko je procena maksimalne veličine datoteke pouzdana.
 U takvim slučajevima korisnici i programeri aplikacija težiće da precene
 veličinu datoteke da se ne bi desilo da ponestane prostora.
 U odnosu na alokaciju u sekundarnom skladištu, to je gubljenje vremena,
 pa se koristi dinamička alokacija kojom se datoteci dodeljuju potrebne
 porcije prostora.
 
\end_layout

\begin_layout Subsubsection
Veličina porcije 
\end_layout

\begin_layout Standard
Pri izboru veličine porcije
\begin_inset Index idx
status open

\begin_layout Plain Layout
porcije
\end_layout

\end_inset

 treba uzeti u obzir efikasnost na nivou datoteke i efikasnost na nivou
 celog sistema.
 Postoji četiri parametra koje treba imati u vidu: 
\end_layout

\begin_layout Itemize
Susedan prostor poboljšava karakteristike, posebno za operacije pretraživanja
 i rada sa transakcijama.
 
\end_layout

\begin_layout Itemize
Veliki broj malih porcija povećava tabele potrebne za upravljanje alokacijom.
 
\end_layout

\begin_layout Itemize
Porcije fiksne veličine (npr.
 blokovi) mogu uprostiti realokaciju prostora.
 
\end_layout

\begin_layout Itemize
Porcije promenljive veličine ili male fiksne veličine minimiziraju prostor
 izgubljen i neiskorišćen zbog prekomerne alokacije.
 
\end_layout

\begin_layout Standard
Ovi zahtevi se mogu razmatrati zajedno, a rezultat je da postoje dve glavne
 alternative.
 
\end_layout

\begin_layout Enumerate
Promenljive, velike susedne porcije: obezbeđuju bolje karakteristike.
 Promenljiva veličina umanjuje gubljenje prostora, a tabele alokacije datoteka
 su male.
 Međutim, prostor se teško ponovo koristi.
 
\end_layout

\begin_layout Enumerate
Blokovi
\begin_inset Index idx
status open

\begin_layout Plain Layout
porcije!blokovi
\end_layout

\end_inset

: Male, fiksne porcije omogućuju veću prilagodljivost.
 One zahtevaju veće tabele ili složenije strukture za njihovu alokaciju.
 Susedstvo se odbacuje kao primarni cilj; blokovi se alociraju onoliko koliko
 je potrebno.
 
\end_layout

\begin_layout Standard
Obe opcije su kompatibilne sa prealokacijom ili dinamičkom alokacijom.
 U slučaju promenljive, velike susedne porcije, datoteci se unapred dodeljuju
 susedne grupe blokova, pa nema potrebe za tabelom alokacije datoteka: potreban
 je samo pokazivač na prvi blok i broj alociranih blokova.
 U slučaju blokova, sve potrebne porcije alociraju se odjednom, što znači
 da tabela alokacije za datoteku ostaje fiksne veličine.
 Sa porcijama promenljive veličine povezana je fragmentacija slobodnog prostora.
 
\end_layout

\begin_layout Standard
Moguće su sledeće alternativne strategije: 
\end_layout

\begin_layout Itemize
Prvi koji odgovara (first fit): izabere se prva nekorišćena susedna grupa
 blokova dovoljne veličine sa liste slobodnih blokova.
 
\end_layout

\begin_layout Itemize
Najbolje odgovara (best fit): izabere se najmanje korišćena grupa dovoljne
 veličine.
 
\end_layout

\begin_layout Itemize
Najbliže odgovara (closest fit): izabere se nekorišćena grupa dovoljne veličine
 koja je najbliža prethodnoj alokaciji za datoteku da bi se povećao efekat
 lokaliteta.
 
\end_layout

\begin_layout Standard
Na modeliranje alternativnih strategija utiče veliki broj međusobno zavisnih
 faktora: tipovi datoteka, uzorak pristupa datoteci, stepen multiprogramiranja,
 keširanje diska, raspoređivanje diska itd.
 
\end_layout

\begin_layout Section
Metode alokacije datoteka
\end_layout

\begin_layout Standard
Najčešće se koriste tri metoda za alokaciju datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!metode alokacije
\end_layout

\end_inset

: susedna, ulančana i indeksna.
 Kod susedne alokacije, u trenutku kreiranja datoteci se dodeljuje skup
 susednih blokova.
 Na taj način definišemo strategiju prealokacije koristeći porcije, tj.
 delove promenljive veličine.
 Tabeli alokacije datoteka potrebni su samo jedan upis za svaku datoteku,
 pokazivač na početni blok i dužina datoteke.
 Susedna alokacija je najbolja ako se posmatra pojedinačna sekvencijalna
 datoteka.
 U istom trenutku može da se pročita više blokova da bi se poboljšale U/I
 performanse za sekvencijalnu obradu.
 Takođe, veoma je lako dobiti jedan blok.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika8.9.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8.8: Susedna alokacija.
\end_layout

\begin_layout Standard
Kod susedne alokacije
\begin_inset Index idx
status open

\begin_layout Plain Layout
alokacija!susedna
\end_layout

\end_inset

 može da se pojavi spoljašnja fragmentacija, što otežava pronalaženje susednih
 blokova prostora dovoljne veličine.
 S vremena na vreme potrebno je primeniti algoritam sažimanja da bi se oslobodio
 dodatni prostor na disku (Slika 8.8).
 Takođe, u slučaju prealociranja, neophodno je deklarisati veličinu datoteke
 u vreme kreiranja, sa problemima koje smo naveli ranije.
 Kao suprotnost susednoj alokaciji definiše se ulančana alokacija (Slika
 8.9).
 To je alokacija na osnovu pojedinačnog bloka.
 Svaki blok sadrži pokazivač na sledeći blok u lancu.
 Alokacionoj tabeli datoteka i u tom slučaju potrebni su samo jedan upis
 za svaku datoteku, početni blok za pokazivač i dužina datoteke.
 
\end_layout

\begin_layout Standard
Mada je prealokacija
\begin_inset Index idx
status open

\begin_layout Plain Layout
prealokacija
\end_layout

\end_inset

 moguća, mnogo je jednostavnije alocirati blokove kada su potrebni.
 Izbor blokova je u tom slučaju veoma lak: bilo koji slobodan blok može
 da se doda lancu.
 Ne postoji spoljašnja fragmentacija zato što je u svakom trenutku potreban
 samo jedan blok.
 Ovaj tip fizičke organizacije je najbolji za sekvencijalne datoteke.
 Da bi se izabrao pojedinačni blok datoteke, mora se proći kroz lanac do
 željenog bloka.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika8.10.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8.9: Ulančana alokacija
\begin_inset Index idx
status open

\begin_layout Plain Layout
alokacija!ulančana
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Jedna od posledica ulančavanja je to da se ne može primeniti princip lokaliteta.
 Ako je potrebno učitati nekoliko blokova datoteke u istom trenutku, kao
 kod sekvencijalne obrade, potreban je niz pristupa različitim delovima
 diska.
 Da bi prevazišli taj problem, neki sistemi periodično konsoliduju datoteke.
 Indeksna alokacija rešava mnoge probleme susedne i ulančane alokacije.
 U ovom slučaju tabela alokacije datoteka sadrži odvojene indekse jednog
 nivoa za svaku datoteku; indeks ima jedan upis za svaku porciju dodeljenu
 datoteci.
 Indeksi datoteka obično nisu fizički uskladišteni kao deo tabele alokacija
 datoteka.
 Umesto toga, indeksi jedne datoteke se drže u odvojenom bloku na koji pokazuje
 upis za datoteku u tabeli alokacije datoteka.
 Alokacija može biti zasnovana na blokovima fiksne veličine (Slika 8.10)
 ili porcijama promenljive veličine.
 
\end_layout

\begin_layout Standard
Alokacija pomoću blokova
\begin_inset Index idx
status open

\begin_layout Plain Layout
alokacija!pomoću blokova
\end_layout

\end_inset

 otklanja spoljašnju fragmentaciju, dok alokacija sa porcijama promenljive
 veličine pobojšava lokalitet.
 U oba slučaja, s vremena na vreme mora se izvršiti konsolidacija datoteke.
 Ona smanjuje veličinu indeksa u slučaju porcija promenljive veličine, ali
 ne u slučaju alokacije blokova.
 Indeksna alokacija podržava i sekvencijalni i direktni pristup datotekama,
 što je čini najpopularnijim oblikom alokacije datoteka.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika8.11.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8.10: Indeksna alokacija
\begin_inset Index idx
status open

\begin_layout Plain Layout
alokacija!indeksna
\end_layout

\end_inset


\end_layout

\begin_layout Section
Upravljanje slobodnim prostorom
\end_layout

\begin_layout Standard
Prostorom koji trenutno nije dodeljen nijednoj datoteci upravlja operativni
 sistem.
 Da bi prethodno opisane tehnike alokacije mogle da se primene, neophodno
 je da znamo koji su blokovi na raspolaganju disku.
 Uz tabelu alokacije datoteka potrebna nam je i tabela alokacije diska.
 Primenjuje se više tehnika.
\end_layout

\begin_layout Subsection
Tabele sa bitovima 
\end_layout

\begin_layout Standard
Ovaj metod koristi vektor koji sadrži po jedan bit za svaki blok na disku.
 Svaki upis vrednosti 0 odgovara slobodnom bloku, a svaki upis vrednosti
 1 odgovara bloku koji se koristi.
 Kod tabela sa bitovima veoma je lako pronaći susedne grupe slobodnih blokova.
 Iako su ove tabele veoma male, mogu znatno da opterete sistem.
 Količina memorije (u bajtovima) koja je potrebna za blok bitmape je:
\end_layout

\begin_layout Standard

\family typewriter
veličina diska u bajtovima / 8 x veličina bloka sistema datoteka
\end_layout

\begin_layout Standard
Tako za disk veličine 16GB sa blokovima veličine 512b tabela bitova zauzima
 približno 4 MB.
 Ako 4MB glavne memorije može da se "potroši
\begin_inset Quotes erd
\end_inset

 na tabelu bitova, onda tabela bitova
\begin_inset Index idx
status open

\begin_layout Plain Layout
tabela bitova
\end_layout

\end_inset

 može da se pretraži bez pristupa disku.
 Međutim, čak i sa današnjim memorijama, kapacitet od 4MB je preveliki deo
 glavne memorije da bi se posvetio jednoj funkciji.
 Rešenje je da se tabela bitova smesti na disk.
 Tabela veličine 4MB zahteva oko 8000 blokova na disku.
 Nije efikasno pretraživati toliki prostor na disku kad god je blok potreban.
 Čak i ako je tabela bitova u glavnoj memoriji, detaljno pretraživanje tabele
 može da uspori sistem datoteka na neprihvatljiv stepen, posebno kada je
 disk skoro pun i postoji samo nekoliko preostalih blokova.
 Većina sistema datoteka koja koristi tabele bitova održava nezavisne strukture
 podataka sa sadržajima podopsega tabele bitova.
 
\end_layout

\begin_layout Subsection
Ulančane slobodne porcije 
\end_layout

\begin_layout Standard
Slobodne porcije
\begin_inset Index idx
status open

\begin_layout Plain Layout
porcije!ulančane slobodne
\end_layout

\end_inset

 mogu da budu ulančane pomoću pokazivača i vrednosti dužine u svakoj slobodnoj
 porciji.
 Ovaj metod ima zanemarljive opšte troškove zato što više nije potrebna
 tabela alokacije diska, već samo pokazivač na početak lanca i dužina prve
 porcije.
 Ovaj metod je podesan za sve metode alokacije datoteka.
 Ako je alokacija u određenom trenutku jedan blok, treba samo izabrati slobodan
 blok sa vrha lanca i podesiti prvi pokazivač ili vrednost dužine.
 Ako je alokacija sa porcijama promenljive dužine, može se koristiti algoritam
 prvog podešavanja.
 Primena ovog metoda prouzrokuje izvesne probleme.
 Nakon određenog vremena disk postaje potpuno fragmentiran, sa mnogo porcija
 veličine jednog bloka.
 Takođe treba obratiti pažnju da prilikom alociranja bloka, pre nego što
 se podaci upišu u blok njega treba pročitati da bi se dobio pokazivač na
 nov prvi slobodan blok.
 Kada u određenom trenutku veoma veliki broj pojedinačnih blokova treba
 da bude alociran za rad sa datotekama, to primetno usporava kreiranje datoteka.
 Slično, brisanje veoma fragmentovanih datoteka zahteva mnogo vremena.
 
\end_layout

\begin_layout Subsection
Indeksiranje 
\end_layout

\begin_layout Standard
U pristupu indeksiranja slobodan prostor se posmatra kao datoteka, a tabela
 indeksa se koristi na sličan način kao kod alokacije datoteka.
 Zbog efikasnosti, indeks treba da bude definisan na osnovu porcija promenljive
 dužine umesto na osnovu blokova.
 Postoji jedan upis (stavka) u tabeli za svaku slobodnu porciju na disku.
 Ovaj pristup obezbeđuje efikasnu podršku za sve metode alokacije datoteka.
 
\end_layout

\begin_layout Subsection
Lista slobodnih blokova 
\end_layout

\begin_layout Standard
Svakom bloku se pridružuje sekvencijalni broj; lista brojeva svih slobodnih
 blokova se održava na rezervisanom delu diska.
 Zavisno od veličine diska, potrebna su 24 ili 32 bita za skladištenje jednog
 bloka brojeva, tako da je veličina liste slobodnih blokova 24 ili 32 puta
 veća od veličine odgovarajuće tabele bitova.
 Zbog toga se lista slobodnih blokova mora čuvati na disku umesto u glavnoj
 memoriji.
 Ovaj metod ipak daje zadovoljavajuće rezultate.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Pouzdanost 
\end_layout

\begin_layout Standard
Sistem održava kopiju tabele alokacije diska u glavnoj memoriji zbog efikasnijeg
 rada.
 Da bi se sprečile greške, tabela alokacije diska koja se nalazi na disku
 se zaključava sve dok se alokacija ne završi, da drugi korisnici ne bi
 pristupali tabeli.
 Često alociranje malih porcija bitno utiče na performanse sistema.
 Da bi se smanjili opšti troškovi, može se iskoristiti šema alokacije paketnog
 skladištenja.
 U ovom slučaju dobija se paket slobodnih delova diska za alokaciju.
 Odgovarajući delovi na disku koji su iskorišćeni su označeni.
 Alokacija može da se obavi u glavnoj memoriji.
 Kada je paket oslobođen, tabela alokacije diska se ažurira na disku i spremna
 je za nov paket.
 Ako sistem "zakaže, delovi diska koji su označeni kao iskorišćeni na neki
 način moraju da se 
\begin_inset Quotes eld
\end_inset

očiste
\begin_inset Quotes erd
\end_inset

 pre nego što se ponovo alociraju; tehnike čišćenja zavise od određenih
 karakteristika sistema datoteka.
\end_layout

\begin_layout Chapter
Ulazno-izlazni (U/I) sistem
\end_layout

\begin_layout Standard
Najšarolikiji aspekt projektovanja operativnog sistema verovatno je U/I
 sistem
\begin_inset Index idx
status open

\begin_layout Plain Layout
U/I sistem
\end_layout

\end_inset

.
 Pošto postoji veliki broj uređaja i aplikacija za U/I uređaje, veoma je
 teško razviti opšte, dosledno rešenje.
 Spoljašnji uređaji koji definišu U/I kao deo računarskog sistema mogu se
 grubo podeliti u tri kategorije: 
\end_layout

\begin_layout Itemize

\shape italic
Čitljivi
\shape default
: služe za komunikaciju sa korisnicima računara (npr.
 štampači i terminali)
\end_layout

\begin_layout Itemize

\shape italic
Mašinski čitljivi
\shape default
: pogodni za komunikaciju sa elektronskom opremom (npr.
 diskovi, senzori, kontroleri, aktuatori).
 
\end_layout

\begin_layout Itemize

\shape italic
Komunikacije
\shape default
: pogodni za komunikaciju sa udaljenim uređajima (npr.
 digitalne linije, modemi).
 
\end_layout

\begin_layout Standard
Između ove tri klase uređaja postoje značajne razlike: 
\end_layout

\begin_layout Itemize
Brzina podataka: brzina prenosa podataka može da se razlikuje za nekoliko
 redova veličine.
 
\end_layout

\begin_layout Itemize
Aplikacija: disk koji se koristi za skladištenje datoteka zahteva softver
 za upravljanje datotekama.
 Disk koji se koristi za skladištenje stranica u virtuelnoj memoriji zahteva
 specijalan hardver i softver.
 Terminali koje koriste administratori sistema ili obični korisnici imaju
 različite nivoe privilegija i prioriteta u operativnom sistemu.
\end_layout

\begin_layout Itemize
Složenost kontrola: različiti uređaji zahtevaju kontrolne interfejse različite
 složenosti.
\end_layout

\begin_layout Itemize
Jedinica prenosa: podaci mogu da se prenose kao nizovi bajtova ili znakova
 (terminal) ili kao veći blokovi (disk).
\end_layout

\begin_layout Itemize
Predstavljanje podataka: različiti uređaji koriste različite šeme kodiranja
 podataka, uključujući i razlike u kodiranju znakova i paritetu.
 
\end_layout

\begin_layout Itemize
Greške: priroda grešaka, način na koji se greške prijavljuju, njihove posledice
 i opseg odgovornosti veoma se razlikuju od uređaja do uređaja.
 
\end_layout

\begin_layout Section
Organizacija U/I funkcija 
\end_layout

\begin_layout Standard
Postoje tri tehnike za izvršavanje ulaza/izlaza: 
\end_layout

\begin_layout Itemize
Programirani U/I
\begin_inset Index idx
status open

\begin_layout Plain Layout
U/I sistem!organizacija
\end_layout

\end_inset

: proces izdaje komandu U/I modulu, i ne radeći ništa čeka da se operacija
 završi pre nego što nastavi posao.
 
\end_layout

\begin_layout Itemize
Prekidni U/I: proces izdaje U/I komandu i nastavlja da izvršava određene
 instrukcije; kada U/I modul završi svoj posao, prekida proces.
 Ako određene instrukcije nisu u istom procesu, nije neophodno da proces
 čeka na završavanje U/I operacije.
 U suprotnom, proces se suspenduje u toku prekida i izvršava se drugi posao.
\end_layout

\begin_layout Itemize
Direktan pristup memoriji (Direct Memory Access - DMA
\begin_inset Index idx
status open

\begin_layout Plain Layout
DMA
\end_layout

\end_inset

): DMA modul upravlja razmenom podataka između glavne memorije i U/I uređaja.
 Proces šalje zahtev za prenos bloka podataka DMA modulu i prekida se tek
 nakon prenosa celog bloka.
 
\end_layout

\begin_layout Section
Direktan pristup memoriji (DMA)
\end_layout

\begin_layout Standard
Slika 7.1 prikazuje logiku direktnog pristupa memoriji.
 DMA
\begin_inset Index idx
status open

\begin_layout Plain Layout
DMA
\end_layout

\end_inset

 tehnika omogućuje izbegavanje procesora i preuzimanje kontrole nad sistemom
 da bi se podaci prenosili u memoriju i iz nje preko sistemske magistrale.
 DMA tehnika radi na sledeći način: kada procesor želi da učita ili upiše
 blok podataka, on izdaje komandu DMA modulu šaljući mu sledeće informacije:
\end_layout

\begin_layout Itemize
da li treba koristiti kontrolnu liniju za čitanje (read) ili upis (write)
 između procesora i DMA modula 
\end_layout

\begin_layout Itemize
adresu U/I uređaja koji se koristi, uz komunikaciju preko linije podataka
 
\end_layout

\begin_layout Itemize
početnu lokaciju u memoriji iz koje se čita ili u koju se upisuje, uz komunikaci
ju preko linije podatake i čuvanje DMA modula u adresnom registru
\end_layout

\begin_layout Itemize
broj reči koji se upisuje ili čita, uz komunikaciju preko linije podatake
 i čuvanje DMA modula u brojaču podataka
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika7.1.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.1: Tipičan DMA blok dijagram
\end_layout

\begin_layout Standard
Pošto je dodelio U/I operaciju DMA modulu, procesor nastavlja da radi drugi
 posao.
 DMA modul prenosi čitav blok podataka, reč po reč, direktno u memoriju
 ili iz nje, bez prolaska kroz procesor.
 Kada se prenos završi, DMA modul šalje prekidni signal procesoru, što znači
 da je procesor uključen samo na početku i na kraju prenosa podataka.
\end_layout

\begin_layout Section
Ciljevi u projektovanju U/I sistema
\end_layout

\begin_layout Standard
U dizajnu U/I sistema stalno su prisutna dva cilja: efikasnost i opštost.
 Efikasnost je važna zato što su U/I operacije često “usko grlo” u računarskom
 sistemu.
 Većina U/I uređaja je izuzetno spora u poređenju sa glavnom memorijom i
 procesorom.
 Jedan način na koji se rešava taj problema je multiprogramiranje, koje
 dozvoljava nekim procesima da čekaju na U/I operacije dok se drugi procesi
 izvršavaju.
 
\end_layout

\begin_layout Subsection
Logička struktura U/I funkcije
\end_layout

\begin_layout Standard
Hijerarhijska priroda modernih operativnih sistema podrazumeva da funkcije
 operativnih sistema treba da budu klasifikovane prema složenosti, karakteristič
nim vremenima izvršavanja i nivoima apstrakcije.
 Dakle, operativni sistemi treba da budu organizovani u slojevima, pri čemu
 svaki sloj izvršava povezani skup funkcija.
 Svaki sledeći sloj nalazi se iznad nižeg sloja i prikriva detalje realizacije
 svojih funkcija, a obezbeđuje servise sledećim višim slojevima.
 Slojevi bi trebalo da budu definisani tako da promena u jednom sloju ne
 utiče na druge slojeve, jer se tako složeni problem deli na više potproblema
 kojima se može upravljati.
 
\end_layout

\begin_layout Standard
Na Slici 7.2 prikazana je organizacija U/I sistema
\begin_inset Index idx
status open

\begin_layout Plain Layout
U/I sistem!logička struktura
\end_layout

\end_inset

 koja koristi filozofiju slojeva.
 Detalji organizacije zavise od tipa uređaja i aplikacija.
 Predstavljene su tri najvažnije logičke strukture.
 U delu a) prikazan je lokalni periferni uređaj koji komunicira na prost
 način, npr.
 razmenjivanjem niza bajtova ili zapisa.
 Za takav uređaj uključeni su sledeći slojevi: 
\end_layout

\begin_layout Itemize
Logički U/I (logical I/O): ovaj modul se bavi uređajem kao logičkim resursom,
 tj.
 upravlja opštim U/I funkcijama u odnosu na korisničke procese, dozvoljavajući
 im da se bave identifikacijom uređaja i komandama kao što su open, close,
 read, write, ...
 
\end_layout

\begin_layout Itemize
Uređaj U/I (device I/O): zahtevane operacije i podaci (znakovi i zapisi
 u baferima) moraju se konvertovati u odgovarajuće nizove U/I instrukcija,
 komandi sa kanalima i redoslede kontrolera.
 Za poboljšanje iskorišćenja mogu da se upotrebe tehnike rada sa baferima.
 
\end_layout

\begin_layout Itemize
Raspoređivanje i kontrola (scheduling and control): na ovom nivou obavlja
 se stvarno smeštanje u redove i raspoređivanje U/I operacija, kao i kontrola
 operacija.
 Takođe, na ovom nivou rukuje se prekidima, definiše se U/I status i daje
 kao izveštaj.
 Ovo je sloj softvera koji zapravo komunicira sa U/I modulom, odnosno sa
 hardverom.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika7.2.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.2: Model U/I organizacije
\end_layout

\begin_layout Standard
Za komunikacione uređaje, U/I struktura (Slika 7.2 b) liči na prethodno opisanu.
 Najvažnija razlika je u tome da je logički U/I modul zamenjen komunikacionom
 arhitekturom koja se sastoji iz više slojeva (primer TCP/IP).
 Slika 7.2 c prikazuje reprezentativnu strukturu za U/I upravljanje na uređajima
 za sekundarno skladištenje koji podržavaju sistem datoteka.
 Vidimo tri dodatna sloja:
\end_layout

\begin_layout Itemize
Upravljanje direktorijumom: u ovom sloju simbolička imena datoteka se konvertuju
 u identifikatore koji referenciraju datoteku direktno ili indirektno kroz
 deskriptor datoteke ili tabelu indeksa.
 Ovaj sloj se bavi i korisničkim operacijama koje utiču na direktorijume,
 kao što su add, delete, reorganize, … 
\end_layout

\begin_layout Itemize
Sistem datoteka: ovaj sloj se bavi logičkom strukturom datoteka i operacijama
 koje određuje korisnik kao što su open, close, read, write, … Na ovom nivou
 se definišu i prava pristupa.
 
\end_layout

\begin_layout Itemize
Fizička organizacija: slično virtuelnim memorijskim adresama koje se konvertuju
 u fizičke adrese glavne memorije, uzimajući u obzir strukture segmentacije
 i straničenja, logičke reference na datoteke i zapise se konvertuju u fizičke
 adrese sekundarnog skladišta, uzimajući u obzir strukture fizičkih staza
 i sektora uređaja za sekundarno skladištenje.
 U ovom sloju se obavlja i alokacija prostora sekundarnog skladišta i upravlje
 se glavnim baferima za skladištenje.
 
\end_layout

\begin_layout Subsection
U/I baferi
\end_layout

\begin_layout Standard
Da bi se izbegli opšti troškovi i neefikasnost pri U/I operacijama, pogodno
 je ulazni prenos izvršiti unapred, pre postavljanja zahteva, a izlazni
 prenos izvesno vreme posle zahteva.
 Ova tehnika je poznata kao 
\series bold
baferovanje
\series default
 (buffering).
 Da bi se razumelo baferovanje, važno je razlikovati dva tipa U/I uređaja:
 one koji su orijentisani na rad sa blokovima i one koji su orijentisani
 na rad sa tokovima podataka (stream).
 Blok orijentisani uređaji
\begin_inset Index idx
status open

\begin_layout Plain Layout
U/I uređaji!blok orijentisani
\end_layout

\end_inset

 skladište informacije u blokove koji su obično fiksne veličine, a u određenom
 trenutku prenosi se jedan blok.
 U opštem slučaju, moguće je referencirati podatke na osnovu broja bloka
 u kome se nalaze.
 Primeri blok orijentisanih uređaja su diskovi i trake.
 Uređaji orijentisani na rad sa tokovima
\begin_inset Index idx
status open

\begin_layout Plain Layout
U/I uređaji!orijentisani na rad sa tokovima
\end_layout

\end_inset

 prenose podatke u računar i iz njega kao nizove bajtova, tj.
 bez strukture bloka.
 Terminali, štampači, komunikacioni portovi, miševi i mnogi drugi uređaji
 koji ne služe za sekundarno skladištenje podataka su orijentisani ka tokovima.
 Baferovanje je tehnika uklanjanja „špiceva“ U/I
\begin_inset Index idx
status open

\begin_layout Plain Layout
U/I baferi
\end_layout

\end_inset

 zahteva.
 Baferovanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
baferovanje
\end_layout

\end_inset

 ne dozvoljava da U/I uređaj opslužuje proces beskonačno dugo, odnosno duže
 od srednjeg vremena servisiranja zahteva U/I uređaja.
 Čak i kada ima više bafera, svi baferi mogu biti puni, pa sistem mora da
 čeka na obradu podataka.
 U multiprogramskom okruženju u kome postoje različite U/I aktivnosti i
 servisne aktivnosti procesa, baferovanje je tehnika koji može da poveća
 efikasnost operativnog sistema i karakteristike pojedinačnih procesa.
 
\end_layout

\begin_layout Section
Disk raspoređivanje
\end_layout

\begin_layout Standard
Brzina diskova je veoma
\begin_inset Index idx
status open

\begin_layout Plain Layout
diskovi!raspoređivanje
\end_layout

\end_inset

 ograničena u poređenju sa brzinama rada procesora i glavne memorije.
 Na primer, u poređenju sa glavnom memorijom, brzina diska je manja za četiri
 reda veličine, a očekuje se da će razlika u brzinama biti još veća u skorijoj
 budućnosti.
 Zato su karakteristike podsistema skladištenja podataka na disku veoma
 važne i stalno se istražuje kako da se poboljšaju.
 
\end_layout

\begin_layout Subsection
Kašnjenje diskova
\end_layout

\begin_layout Standard
Stvarni detalji U/I operacija diska
\begin_inset Index idx
status open

\begin_layout Plain Layout
diskovi!kašnjenje
\end_layout

\end_inset

 zavise od računarskog sistema, operativnog sistema i prirode U/I kanala
 i kontrolera diska.
 Opšti vremenski dijagram U/I disk prenosa prikazan je na Slici 7.3.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika7.3.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.3: Vremenski prikaz U/I disk prenosa
\end_layout

\begin_layout Standard
Kada disk radi, rotira konstantnom brzinom.
 Kada se podaci čitaju ili upisuju, glava diska mora biti postavljena iznad
 željene staze i na početak željenog sektora na toj stazi.
 Vreme potrebno da se glava pozicionira iznad staze zove se 
\series bold
vreme pretraživanja
\series default
 (seek
\begin_inset Index idx
status open

\begin_layout Plain Layout
diskovi!vreme pretraživanja
\end_layout

\end_inset

 time).
 Kada se staza izabere, kontroler diska čeka da odgovarajući sektor rotira
 do linije gde se nalazi glava diska.
 Vreme potrebno da početak sektora stigne do glave diska
\begin_inset Index idx
status open

\begin_layout Plain Layout
diskovi!kašnjenje zbog rotacije
\end_layout

\end_inset

 zove se 
\series bold
kašnjenje zbog rotacije
\series default
 (rotational delay ili rotational latency).
 Zbir vremena pretraživanja i kašnjenja zbog rotacije diska
\begin_inset Index idx
status open

\begin_layout Plain Layout
diskovi!vreme pristupa
\end_layout

\end_inset

 zove se 
\series bold
vreme pristupa
\series default
 (access time).
 To je vreme potrebno da se dođe u poziciju čitanja ili upisa podataka,
 kada se sektor pomera ispod glave diska.
 Ovo je deo operacije upisa ili čitanja sa prenosom podataka, za koju se
 definiše i vreme potrebno za prenos podataka (transfer time).
 Osim vremena pristupa i vremena prenosa, postoji više kašnjenja zbog čekanja
 u redu na U/I operacije diska.
 Kada proces izda U/I zahtev, on prvo da čeka u redu dok uređaj ne postane
 dostupan, i tek tada se uređaj dodeljuje procesu.
 Ako uređaj deli jedan ili više U/I kanala sa drugim diskovima, onda postoji
 i dodatno čekanje da se oslobodi traženi kanal.
 Kada se kanal oslobodi, obavlja se pretraživanje i počinje pristup disku.
\end_layout

\begin_layout Subsubsection
Vreme pretraživanja
\end_layout

\begin_layout Standard
Vreme za koje se ruka diska pomeri do željene staze je vreme pretraživanja.
 Ono se sastoji od dve ključne komponente: početno startup vreme i vreme
 koje je potrebno da glava diska dođe do određene staze kada se potvrdi
 identifikacija staze.
 Kod savremenih diskova (veličine 3,5 inča – 8,9 cm) stalno se smanjuje
 rastojanje koje ruka diska treba da pređe.
 Tipično srednje vreme pretraživanja diska je kraće od 10 ms.
 
\end_layout

\begin_layout Subsubsection
Kašnjenje usled rotacije 
\end_layout

\begin_layout Standard
Disk rotira brzinom koja je u opsegu od 3600 obrtaja u minutu (rpm) do 15000
 rpm.
 Srednja vrednost kašnjenja usled rotacije je približno 2 ms.
 
\end_layout

\begin_layout Subsubsection
Vreme prenosa 
\end_layout

\begin_layout Standard
Vreme prenosa
\begin_inset Index idx
status open

\begin_layout Plain Layout
diskovi!vreme prenosa
\end_layout

\end_inset

 ka disku ili sa diska zavisi od brzine rotacije diska na sledeći način:
\end_layout

\begin_layout Standard
T = b/(rN)
\end_layout

\begin_layout Standard
gde je T vreme prenosa, b broj bajtova koji treba da se prenesu, N broj
 bajtova na stazi i r brzina rotacije (broj obrtaja u sekundu).
 Prema tome, ukupno srednje vreme pristupa može da se predstavi kao: 
\end_layout

\begin_layout Standard
Ta = Ts + 1/(2r) + b/(rN)
\end_layout

\begin_layout Standard
gde je Ts srednja vrednost vremena pretraživanja.
 
\end_layout

\begin_layout Section
Algoritmi za raspoređivanje diska
\end_layout

\begin_layout Standard
Očigledno je da redosled po kome se čita sadržaj sektora sa diska 
\begin_inset Index idx
status open

\begin_layout Plain Layout
diskovi!algoritmi za raspoređivanje
\end_layout

\end_inset

ima ogroman uticaj na U/I karakteristike.
 Razlog zbog koga postoje razlike u karakteristikama je vreme pretraživanja.
 Ako zahtevi za pristup sektorima uključuju biranje staza na slučajan način,
 onda će karakteristike U/I disk sistema biti veoma slabe.
 Da bi se rešio taj problem, potrebno je smanjiti srednje vreme traženja
 odgovarajućih staza.
 Posmatrajmo tipičnu situaciju u multiprogramskom okruženju, u kome operativni
 sistem održava red sa zahtevima za svaki U/I uređaj.
 Za jedan disk postojaće veći broj U/I zahteva (čitanje i upis) od raznih
 procesa iz reda.
 Ako izaberemo jedan uzorak iz reda na slučajan način, onda možemo da očekujemo
 da će se staze koje će biti posećene pojavljivati na slučajan način, dajući
 slabe performanse.
 Slučajno raspoređivanje je korisno za poređenje sa ostalim tehnikama.
 
\end_layout

\begin_layout Subsection
FIFO raspoređivanje
\end_layout

\begin_layout Standard
Prvi stigao, prvi servisiran (first in, first out – FIFO
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!FIFO
\end_layout

\end_inset

) je najprostiji oblik raspoređivanja koji obrađuje zahtev iz reda na sekvencija
lan način.
 Prednost ove strategije je to što se ista pažnja poklanja svakom zahtevu
 prema redosledu pristizanja.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika7.4.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.4: FIFO raspoređivanje.
\end_layout

\begin_layout Standard
Ako postoji samo nekoliko procesa koji zahtevaju pristup i ako ima mnogo
 zahteva koji traže klasterizovane sektore datoteke, karakteristike FIFO
 raspoređivanja će biti dobre.
 Međutim, ako se mnogo procesa takmiči da pristupi disku na slučajan način,
 moraju se koristiti druge, naprednije tehnike raspoređivanja.
\end_layout

\begin_layout Standard
Slika 7.4 prikazuje FIFO disk raspoređivanje.
 Vertikalna osa odgovara stazama na disku.
 Horizontalna osa odgovara vremenu, što je ekvivalentno broju pređenih staza.
 Pretpostavljeno je da je početna lokacija glave diska na stazi 100, da
 je broj staza 200 i da red zahteva diska ima slučajno raspoređene zahteve.
 Zahtevi za stazama po redosledu primljenom od disk raspoređivača su: 55,
 58, 39, 18, 90, 160, 150, 38 i 184.
\end_layout

\begin_layout Subsection
Raspoređivanje po prioritetu 
\end_layout

\begin_layout Standard
Kod ove vrste raspoređivanja
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!po prioritetu
\end_layout

\end_inset

 kontrola raspoređivanja je van dometa softvera za upravljanje diskom.
 Ovaj pristup se ne koristi za optimizaciju iskorišćenja diska, već za druge
 ciljeve unutar operativnog sistema.
 Ovo raspoređivanje daje veći prioritet kratkim paketnim poslovima i interaktivn
im poslovima, a postiže loše rezultate sa bazama podataka.
 
\end_layout

\begin_layout Subsection
LIFO raspoređivanje
\end_layout

\begin_layout Standard
Ako se u sistemima za obradu transakcija uređaj dodeljuje poslednjem korisniku,
 kao rezultat može da se dobije malo ili nikakvo pomeranje ruke diska kroz
 sekvencijalnu datoteku.
 Uz pomoć dobrih osobina principa lokaliteta može da se poboljša propusnost
 i smanji dužina reda.
 Taj princip se koristi u raspoređivanju tipa 
\begin_inset Quotes eld
\end_inset

poslednji stigao, prvi uslužen
\begin_inset Quotes erd
\end_inset

 (Last In First Out – LIFO
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!LIFO
\end_layout

\end_inset

).
 Što duže posao aktivno koristi sistem datoteka, obrađuje se brže.
 Međutim, ako je radno opterećenje diska visoko, može se pojaviti „gladovanje“
 (tj.
 da se zahtevi koji nikako neće stići na red).
 FIFO i LIFO raspoređivanja zasnivaju se isključivo na atributima reda sa
 zahtevima.
 Ako raspoređivač zna tekuću poziciju staze, onda se može primeniti raspoređivan
je zasnovano na zahtevanom uzorku.
 
\end_layout

\begin_layout Subsection
SSTF raspoređivanje
\end_layout

\begin_layout Standard
SSTF
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!SSTF
\end_layout

\end_inset

 algoritam (najkraće vreme servisiranja prvo, Shortest Service Time First
 – SSTF) bira zahtev U/I diska koji zahteva najmanje pomeranje ruke diska
 od tekuće pozicije.
 Uvek se bira zahtev sa minimalnim vremenom pretraživanja.
 To ne garantuje da će srednje vreme pretraživanja većeg broja pomeranja
 ruke diska biti minimalno.
 Algoritam ima bolje karakteristike od FIFO algoritma.
 Slika 7.5 prikazuje performanse SSTF raspoređivanja na istom primeru kao
 i FIFO.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika7.5.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.5: SSTF
\end_layout

\begin_layout Subsection
SCAN raspoređivanje
\end_layout

\begin_layout Standard
Uz izuzetak FIFO raspoređivanja, u svim dosad opisanim algoritmima može
 da se desi da neki zahtevi ostanu neizvršeni sve dok se ceo red ne isprazni.
 Uvek mogu da stignu novi zahtevi koji će biti izabrani pre postojećeg zahteva.
 Jednostavno rešenje koje sprečava pojavu “gladovanja” (starvation) je SCAN
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!SCAN
\end_layout

\end_inset

 algoritam, poznat i kao algoritam lifta.
 Ruka diska se pomera samo u jednom smeru zadovoljavajući sve zahteve na
 tom putu, sve dok ne stigne do poslednje staze u tom smeru ili dok više
 nema zahteva u tom smeru.
 Nakon toga se smer menja i skeniranje se nastavlja u suprotnom smeru uz
 rešavanje svih zahteva na tom putu redom (Slika 7.6).
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika7.6.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.6: SCAN
\end_layout

\begin_layout Standard
Kada se redovi dinamički menjaju, SCAN raspoređivanje je slično SSTF raspoređiva
nju sve dok uzorci zahteva ne postanu neuobičajeni.
 SCAN, kao i SSTF i LIFO, ne koristi efekat lokaliteta.
 SCAN algoritam daje prednost poslovima čiji su zahtevi na stazama blizu
 unutrašnje i spoljašnje strane diska i nedavno pristiglim poslovima.
 Prvi problem se rešava C-SCAN algoritmom, a drugi algoritmom N-step_SCAN.
\end_layout

\begin_layout Subsection
C-SCAN raspoređivanje
\end_layout

\begin_layout Standard
Kružni SCAN
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!C-SCAN
\end_layout

\end_inset

 algoritam ograničava skeniranje samo u jednom smeru.
 Kada se poseti poslednja potrebna staza u jednom smeru, ruka diska se vraća
 na suprotan kraj diska i skeniranje počinje ispočetka.
 Time se smanjuje maksimalno kašnjenje (Slika 7.7).
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika7.7.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.7: C-SCAN
\end_layout

\begin_layout Subsection
N-step-SCAN i FSCAN raspoređivanje
\end_layout

\begin_layout Standard
N-step-SCAN
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!N-step-SCAN
\end_layout

\end_inset

 algoritam deli zahteve za diskom koji su u redu na podredove dužine N.
 Podredovi se obrađuju jedan po jedan primenom SCAN algoritma.
 Kada se red obradi, novi zahtevi se mogu dodati nekom drugom redu.
 Ako ima više od N zahteva na kraju skeniranja, onda se svi oni obrađuju
 u sledećem skeniranju.
 Sa velikim brojem N ovaj algoritam ima karakteristike kao SCAN, a za N=1,
 postaje FIFO.
 
\end_layout

\begin_layout Standard
FSCAN
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!FSCAN
\end_layout

\end_inset

 je algoritam koji koristi dva podreda.
 Kada skeniranje počne, svi zahtevi su u jednom podredu, a drugi je prazan.
 Svi novi zahtevi se stavljaju u drugi podred, čime se odlaže njihovo izvršavanj
e sve dok se svi stari zahtevi ne obrade.
 
\end_layout

\begin_layout Section
Redundantan niz nezavisnih diskova (RAID)
\end_layout

\begin_layout Standard
Kao što smo ranije pomenuli, karakteristike uređaja za sekundarno skladištenje
 se mnogo sporije poboljšavaju od brzine procesora i glavne memorije.
 Jedan od načina poboljšanja karakteristika skladištenja na disku je primena
 niza diskova koji rade nezavisno i paralelno.
 Kada u sistemu ima više diskova, odvojeni U/I zahtevi mogu da se izvršavaju
 paralelno samo ako se podaci nalaze na više diskova.
 Jedan U/I zahtev može da se izvrši paralelno samo ako je blok podataka
 kome se pristupa distribuiran na više diskova.
 Standardizovana šema za rad sa više diskova
\begin_inset Index idx
status open

\begin_layout Plain Layout
diskovi!RAID
\end_layout

\end_inset

 poznata je kao RAID
\begin_inset Index idx
status open

\begin_layout Plain Layout
RAID
\end_layout

\end_inset

 (Redundant Array of Independent Disks).
 Ova šema se sastoji od sedam nivoa (od 0 do 6) koji ne predstavljaju hijerarhij
ske veze, već arhitekture različitog dizajna koje dele tri zajedničke karakteris
itke: 
\end_layout

\begin_layout Enumerate
RAID je skup fizičkih diskova koje operativni sistem vidi kao jedan logički
 disk
\end_layout

\begin_layout Enumerate
Podaci su distribuirani na nizu fizičkih diskova.
 
\end_layout

\begin_layout Enumerate
Redundantni (dodatni) diskovi se koriste za skladištenje informacija o parnosti,
 koje garantuju da se u slučaju greške podaci mogu povratiti.
 
\end_layout

\begin_layout Standard
RAID 0 i 1 ne podržavaju treću karakteristiku.
 U tehnici RAID, diskovi velikog kapaciteta zamenjuju se s nekoliko diskova
 manjeg kapaciteta na kojima su distribuirani podaci da bi se omogućio istovreme
ni pristup podacima sa više diskova.
 Na taj način se poboljšavaju U/I performanse.
 RAID šema ubrzava rad, ali povećava i verovatnoću pojave greške.
 Zato se koriste informacije o parnosti (parity) koje omogućavaju "oporavak"
 (tj.
 ponovno nalaženje) podataka izgubljenih zbog greške na disku.
 Prikazaćemo detaljnije nivoe 0, 1 i 5 koji se najčešće primenjuju.
 
\end_layout

\begin_layout Subsection
RAID 0 (bez redundantnosti) 
\end_layout

\begin_layout Standard
Ovaj nivo jednostavno raspodeljuje podatke na niz diskova (Slika 7.8).
 Sistem radi sa logičkim diskovima koji su podeljeni na "trake" (strip)
 koje mogu biti fizički blokovi, sektori ili neke druge jedinice.
 Trake su mapirane na kružni način (round robin) na susedne fizičke diskove
 u RAID nizu.
 Prednost ove šeme je paralelno izvršavanje U/I zahteva na trakama.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika7.8.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.8: RAID 0
\end_layout

\begin_layout Subsection
RAID 1 (preslikavanje) 
\end_layout

\begin_layout Standard
U tehnici RAID 1 (Slika 7.9) svaka logička traka je preslikana na dva posebna
 fizička diska.
 Za svaki disk u nizu postoji disk 
\begin_inset Quotes eld
\end_inset

u ogledalu
\begin_inset Quotes erd
\end_inset

 (mirror) koji sadrži identične podatke.
 Ako se na jednom disku pojavi greška, podaci se mogu dobiti sa drugog diska.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika7.9.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.9: RAID 1
\end_layout

\begin_layout Subsection
RAID 5 (distribuirana parnost na nivou blokova) 
\end_layout

\begin_layout Standard
RAID 5 koristi tehniku nezavisnog pristupa, u kojoj svaki disk radi nezavisno
 tako da odvojeni U/I zahtevi mogu da se izvršavaju paralelno (Slika 7.10).
 I ovde se koristi podela podataka u trake.
 U odgovarajućim trakama na svim diskovima čuvaju se bitovi parnosti, čime
 se izbegava potencijalno U/I "usko grlo" jednog paritetnog diska.
 Tipična alokacija je kružna (round robin) šema.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Slika7.10.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.10: RAID 5
\end_layout

\begin_layout Standard
Preostale RAID šeme su: RAID 2 (redundantnost uz Hammingov kod), RAID 3
 (isprepletena parnost na nivou bitova), RAID 4 (parnost na nivou blokova)
 i RAID 6 (dvojna redundantnost).
\end_layout

\begin_layout Section
Disk keš
\end_layout

\begin_layout Standard
Termin keš memorija se obično koristi za memoriju koja je manja i brža od
 glavne memorije, a smeštena je između glavne memorije i procesora.
 Takva keš memorija smanjuje srednje vreme pristupa memoriji korišćenjem
 principa lokaliteta.
 Isti princip se može primeniti na disk memoriju.
 Disk
\begin_inset Index idx
status open

\begin_layout Plain Layout
diskovi!keš
\end_layout

\end_inset

 keš je bafer u glavnoj memoriji za sektore sa diska.
 Keš sadrži kopije određenih sektora na disku.
 Kada se pošalje jedan U/I zahtev za određeni sektor, prvo se proverava
 da li je sektor u disk kešu.
 Ako jeste, zahtev se odatle zadovoljava, a ako nije zahtevani sektor se
 učitava sa diska u disk keš.
 Zbog principa lokaliteta referenci, ako je blok podataka učitan u keš da
 bi zadovoljio jedan U/I zahtev, vrlo je verovatno da će uskoro biti ponovo
 referenciran.
 
\end_layout

\begin_layout Part
Jezgro operativnog sistema Linux
\end_layout

\begin_layout Chapter
Uvod u jezgro (kernel) Linuxa
\end_layout

\begin_layout Section
Operativni sistem UNIX kao preteča Linuxa
\end_layout

\begin_layout Standard
Nakon četiri decenije korišćenja, operativni sistem UNIX
\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistemi!UNIX
\end_layout

\end_inset

 je još uvek jedan od najsnažnijih i najelegantnijih operativnih sistema.
 Kreirali su ga 1969.
 godine Denis Riči i Ken Tompson.
 UNIX je nastao iz Multicsa, projekta višekorisničkog operativnog sistema
 u Bellovim laboratorijama.
 Nakon što se projekat Multics neuspešno završio, članovi istraživačkog
 centra ostali su bez posla na razvoju interaktivnog operativnog sistema.
 U leto 1969.
 godine programeri Belovih laboratorija skicirali su sistem datoteka koji
 će kasnije postati deo UNIX-a.
 Tokom testiranja tog dizajna, Ken Tompson je primenio nov sistem na PDP-7.
 Godine 1973.
 operativni sistem je ponovo napisan u jeziku C, što je otvorilo put budućoj
 prenosivosti sistema.
 Prva verzija UNIX-a koja je bila u širokoj upotrebi van Bellovih laboratorija
 bilo je šesto izdanje, poznato pod nazivom V6.
 Nakon toga i druge kompanije počele su da instaliraju UNIX na novim mašinama.
 Pojavilo se nekoliko njegovih varijanti: 1977 Unix System III, a 1982 kompanija
 AT&T je razvila System V Release 4 (SVR4).
 Jednostavnost dizajna povezana sa činjenicom da je distribuiran sa izvornim
 (source) kodom dovela je do brzog razvoja ovog operativnog sistema.
 Najpoznatije varijante su stigle sa Univerziteta u Berkliju, pod nazivom
 Berkeley Software Distributions (BSD).
 U tim verzijama UNIX-a dodati su virtuelna memorija, straničenje na zahtev
 i protokoli TCP/IP.
 Poslednje varijante su Darwin, Dragonfly BSD, FreeBSD, NetBSD i OpenBSD
 sistemi.
 Poznate kompanije su razvijale sopstvene komercijalne verzije UNIX-a sa
 višestrukim radnim stanicama i serverima kao što su Digitalov Tru64, Hewlett
 Packardov HP-UX, IBM-ov AIX, Sequentov DYNIX/ptx, SGI-jev IRIX i Sunov
 Solaris.
 Kao dobre osobine UNIX-a pokazale su se mali broj (nekoliko stotina) sistemskih
 poziva, pregledan dizajn, sistem datoteka.
 Ove osobine uprošćuju rad sa podacima i uređajima svodeći ga na skup prostih
 sistemskih poziva: 
\family typewriter
open()
\family default
, 
\family typewriter
read()
\family default
, 
\family typewriter
write()
\family default
, 
\family typewriter
ioctl()
\family default
 i 
\family typewriter
close()
\family default
.
 Uz to, jezgro UNIX-a i sa njim povezani sistemski servisi napisani su u
 jeziku C, što omogućuje prenosivost.
 UNIX veoma brzo kreira procese i ima jedinstven sistemski poziv 
\family typewriter
fork()
\family default
.
 Konačno, UNIX obezbeđuje prostu ali robusnu komunikaciju između procesa.
 UNIX je danas moderan operativni sistem koji podržava multitasking, višenitni
 rad, virtuelnu memoriju, straničenje na zahtev, deljene biblioteke sa učitavanj
em na zahtev i TCP/IP umrežavanje.
 Postoje varijante koje rade sa stotinama procesora, kao i one namenjene
 malim, 
\begin_inset Quotes eld
\end_inset

embedded
\begin_inset Quotes erd
\end_inset

 uređajima.
 
\end_layout

\begin_layout Section
Nastanak Linuxa
\end_layout

\begin_layout Standard
Linux
\begin_inset Index idx
status open

\begin_layout Plain Layout
operativni sistemi!Linux
\end_layout

\end_inset

 je razvio student Univerziteta u Helsinkiju Linus Torvalds
\begin_inset Index idx
status open

\begin_layout Plain Layout
Linus Torvalds
\end_layout

\end_inset

 1991.
 godine kao operativni sistem za računare koji koriste Intelove mikroprocesore
 80386 .
 Linus je koristio Minix, jeftin Unix kreiran kao sredstvo za učenje, ali
 zbog licenci koje su usporavale distribuciju izmena u izvornom kôdu, odlučio
 se da napiše sopstveni operativni sistem.
 Prvo je napisao prost emulator za terminale koji je koristio za povezivanje
 sa većim Unix sistemom na fakultetu, a zatim ga je razvijao i poboljšavao.
 Godine 1991.
 postavio je prvu verziju Linuxa na Internet.
 Nakon toga Linux je postao kolaborativni projekat u čijem razvoju učestvuju
 mnogi programeri.
 Linux radi na sledećim procesorima: AMD x86-64, ARM, Compaq Alpha, CRIS,
 DEC VAX, H8/300, Hitachi SuperH, HP PA-RISC, IBM S/390, Intel IA-64, MIPS,
 Motorola 68000, PowerPC, SPARC, UltraSPARC i v850.
 Pojavile su se nove kompanije specijalizovane za Linux kao što su MontaVista
 i Red Hat, a velike kompanije kao što su IBM i Novell obezbeđuju Linux
 rešenja za embedded sisteme, desktop sisteme i servere.
 
\end_layout

\begin_layout Standard
Linux je klon UNIX-a, ali nije UNIX.
 Mada je pozajmio mnoge ideje od UNIX-a i primenjuje njegov interfejs za
 programiranje API (kao što je definisano standardom POSIX
\begin_inset Index idx
status open

\begin_layout Plain Layout
POSIX
\end_layout

\end_inset

), njegov kôd on nije direktna kopija izvornog kôda UNIX-a kao u drugim
 UNIX sistemima.
 Jedna od najinteresantnijih karakteristika Linuxa jeste to da nije komercijalni
 proizvod, već projekat razvijen saradnjom preko Interneta.
 Iako Linus Torvalds ostaje kreator Linuxa i održava kernel, razvoj nastavlja
 povezana grupa programera.
 Linuxov kernel je slobodan softver, tj.
 softver otvorenog koda sa licencom GNU General Public License (GPL, verzija
 2.0).
 Korisnici su slobodni da preuzimaju izvorni kôd Linuxa sa Interneta i da
 načine bilo kakve promene.
 Jedina obaveza koju imaju je da ako distribuiraju svoje promene, moraju
 korisnicima da daju ista prava koja sami koriste, uključujući i raspolaganje
 izvornim kodom.
 
\end_layout

\begin_layout Standard
Osnovni delovi operativnog sistema Linux su kernel, C biblioteka i prevodilac,
 niz alata i osnovne sistemske funkcije (kao što su proces prijavljivanja
 i interpreter komandi).
 U neke Linux sisteme uključeno je desktop okruženje X Window System sa
 svim karakteristikama (GNOME, KDE).
 Postoji ogroman broj slobodnih komercijalnih aplikacija za Linux.
 Kada se kaže Linux najčešće se misli na kernel, odnosno jezgro samog operativno
g sistema.
 
\end_layout

\begin_layout Section
Pregled jezgra operativnih sistema
\end_layout

\begin_layout Standard
Operativni sistem se posmatra kao skup delova sistema odgovornog za osnovno
 korišćenje i administriranje računara.
 Pod tim se podrazumevaju jezgro (kernel), upravljački programi uređaja
 (drivers), softver za podizanje sistema (boot loader), interpreter komandi
\begin_inset Index idx
status open

\begin_layout Plain Layout
interpreter komandi
\end_layout

\end_inset

 (command shell), korisnički interfejsi za rad sa datotekama i sistemske
 usluge.
 Termin sistem upućuje na operativni sistem i sve aplikacije koje rade u
 njemu.
 Jezgro ili kernel
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel
\end_layout

\end_inset

 je softver koji obezbeđuje osnovne servise za sve delove sistema, upravlja
 hardverom i raspoređuje sistemske resurse.
 Kernel se ponekad naziva unutrašnjost operativnog sistema.
 Tipične komponente kernela su prekidne rutine, tj.
 upravljači prekida
\begin_inset Index idx
status open

\begin_layout Plain Layout
upravljač prekida
\end_layout

\end_inset

 (interrupt handlers) koje obrađuju zahteve za prekidom, raspoređivač za
 deljenje vremena procesora između više procesa (scheduler), sistem za upravljan
je memorijom, tj.
 adresnim prostorom procesa i sistemski servisi kao što su umrežavanje i
 komunikacije između procesa.
 Kernel uključuje i zaštitu memorijskog prostora i pun pristup hardveru.
 Stanje sistema i memorijski prostor zajedno se zovu kernel prostor.
 Korisničke aplikacije se izvršavaju u korisničkom prostoru.
 Aplikacije koje se izvršavaju u sistemu komuniciraju sa kernelom preko
 sistemskih poziva.
 Neki bibliotečki pozivi imaju širu funkciju od sâmog sistemskog poziva;
 tada je poziv u kernelu samo jedan korak u funkciji (takva je npr.
 C funkcija 
\family typewriter
printf()
\family default
 koja obezbeđuje formatizovanje i baferovanje podataka, a samo eventualno
 pozive 
\family typewriter
write()
\family default
 za ispis podataka na konzolu).
 Nasuprot tome, neki bibliotečki pozivi imaju vezu sa kernelom "jedan-na-jedan"
 (npr.
 bibliotečka funkcija 
\family typewriter
open()
\family default
 svodi se na čist sistemski poziv 
\family typewriter
open()
\family default
).
 Druge bibliotečke funkcije, kao na primer 
\family typewriter
strcpy()
\family default
, uopšte i ne koriste kernel.
 Kada neka aplikacija izvršava sistemski poziv, kaže se da kernel radi u
 ime aplikacije, odnosno da aplikacija izvršava sistemski poziv u kernel
 prostoru i da kernel radi u kontekstu procesa.
 Dakle, osnovni način na koji aplikacije rade je sistemski poziv u kernelu.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko1.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 9.1: Veza između aplikacija, kernela i hardvera.
\end_layout

\begin_layout Standard
Kernel upravlja i sistemskim hardverom.
 Skoro sve arhitekture, uključujući i sisteme koje Linux podržava, obezbeđuju
 rad sa prekidima (interrupt).
 Kada hardver želi da komunicira sa sistemom, on generiše prekid koji asinhrono
 prekida kernel.
 Prekidi se identifikuju po broju.
 Kernel koristi broj da bi izvršio specifičnu prekidnu rutinu procesa (interrupt
 handler) i odgovorio na njega.
 Na primer, kada se pritisne taster na tastaturi, kontroler tastature generiše
 prekid da bi stavio do znanja sistemu da postoji novi podatak u baferu
 tastature.
 Kernel beleži koji je broj generisanog prekid
\begin_inset Index idx
status open

\begin_layout Plain Layout
prekid
\end_layout

\end_inset

a i izvršava odgovarajuću prekidnu rutinu.
 Ona sa svoje strane obrađuje podatak sa tastature i oslobađa kontroler
 tastature za obradu novih podataka.
 Da bi se obezbedila sinhronizacija, kernel može i da onemogući prekide.
 U mnogim operativnim sistemima, uključujući i Linux, prekidne rutine ne
 rade u kontekstu procesa, već u specijalnom prekidnom kontekstu koji nije
 pridružen nijednom procesu.
 Ovaj specijalni kontekst postoji isključivo da bi prekidna rutina brzo
 odgovorila na prekid.
 U Linuxu se može generalizovati da svaki procesor u datom trenutku radi
 nešto od sledećeg: 
\end_layout

\begin_layout Standard
• U prostoru kernela, u kontekstu procesa, izvršava određeni proces 
\end_layout

\begin_layout Standard
• U prostoru kernela, u kontekstu prekida, rukuje prekidom bez pridruživanja
 procesu.
 
\end_layout

\begin_layout Standard
• U korisničkom prostoru izvršava korisnički kôd u procesu.
 
\end_layout

\begin_layout Section
Monolitna jezgra i mikrokerneli
\end_layout

\begin_layout Standard
Rad jezgra operativnog sistema može da se prikaže preko dva glavna pojma
 projektovanja: monolitni kernel i mikrokernel
\begin_inset Index idx
status open

\begin_layout Plain Layout
mikrokernel
\end_layout

\end_inset

.
 Monolitna jezgra su se koristila do 1980.
 godine, a bila su implementirana kao veliki procesi koji se kompletno izvršavaj
u u jedinstvenom adresnom prostoru.
 Zbog toga su se takvi kerneli obično čuvali na disku u obliku statičkog
 binarnog kôda.
 Svi servisi kernela izvršavali su se u velikom objedinjenom adresnom prostoru
 kernela.
 Komunikacija unutar kernela u slučaju monolitnih jezgara je trivijalna
 zato što rade u sistemskom režimu, u istom adresnom prostoru: kernel može
 da pozove funkcije direktno, kao što radi aplikacija u korisničkom prostoru.
 Zagovornici ovog modela ističu njegovu jednostavnost i dobre karakteristike,
 koje su činile osnovu prvobitnih UNIX sistema.
\end_layout

\begin_layout Standard
S druge strane, mikrokerneli nisu implementirani kao prosti, veliki procesi,
 već je funkcionalnost kernela spuštena na nivo odvojenih procesa, koji
 se obično zovu serveri.
 Kod ovakvog načina organizacije jezgra, isključivo serveri zahtevaju rad
 u privilegovanom režimu, dok ostatak jezgra radi u korisničkom prostoru.
 Svi serveri se održavaju odvojeno i rade u različitim adresnim prostorima.
 Zbog toga nije moguće direktno pozvati funkciju kao u monolitnim kernelima.
 Komunikacija u mikrokernelima se izvodi preko prosleđivanja poruka (message
 passing): u sistem je ugrađen mehanizam komunikacije između procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!komunikacija prosleđivanjem poruka
\end_layout

\end_inset

 (interprocess communication, IPC) tako da različiti serveri komuniciraju
 i traže usluge jedni od drugih slanjem poruka.
 Odvajanje različitih servera sprečava greške koje mogu nastati u jednom
 serveru kao rezultat grešaka nekog drugog servera.
 Takođe, modularnost sistema dozvoljava zamenu jednog servera drugim.
 Međutim, pošto je mehanizam komunikacije zahtevniji od običnih funkcijskih
 poziva, kao i zbog neophodne promene konteksta (context switch) iz prostora
 kernela u korisnički prostor i obrnuto, prosleđivanje poruka prouzrokuje
 kašnjenje i manju propusnost u poređenju sa monolitnim kernelima sa prostim
 pozivima funkcija.
 
\end_layout

\begin_layout Standard
U svim praktično implementiranim mikrokernelima većina servera (ili čak
 svi) su izmešteni u prostor jezgra, jer se tako ublažavaju negativni efekti
 čestih promena konteksta i dozvoljavaju direktni pozivi funkcija.
 Jezgra operativnih sistema Windows NT i Mach (na kome je zasnovan Mac OS
 X) su primeri mikrokernela.
 Poslednje verzije Windowsa NT i Mac OS X-a ne koriste mikrokernel servere
 u korisničkom prostoru, čime je potisnuta najvažnija ideja mikrokernela.
 U Linuxu je monolitni kernel koji se izvršava u jednom adresnom prostoru
 u potpunosti u sistemskom režimu, ali je Linux istovremeno pozajmio dosta
 toga i od mikrokernela: koristi modularni dizajn sa prinudnim suspendovanjem
 procesa (preemption), podržava niti jezgra i sposoban je da dinamički učita
 posebne module kôda jezgra u kernel.
 Istovremeno, Linux nema sledeće osobine mikrokernel dizajna: svi procesi
 rade u sistemskom režimu sa direktnim pozivom funkcija i ne koristi prosleđivan
je poruka kao metod komunikacije između procesa.
 Linux je modularan i sam raspoređuje procese.
 
\end_layout

\begin_layout Section
Jezgro Linuxa u poređenju sa kernelom klasičnog UNIX-a
\end_layout

\begin_layout Standard
Zahvaljujući zajedničkom poreklu i istom interfejsu za programiranje (API),
 moderni UNIX
\begin_inset Index idx
status open

\begin_layout Plain Layout
Linux!i UNIX
\end_layout

\end_inset

 kerneli dele zajedničke osobine.
 Uz nekoliko izuzetaka, kernel UNIX-a je tipično monolitan i statički.
 On postoji kao samoizvršavajuća slika koji radi u jednom adresnom prostoru.
 UNIX obično zahteva jedinicu za upravljanje memorijom (memory management
 unit, MMU) sa podrškom za straničenje; to je hardver koji omogućava sistemu
 da primeni zaštitu memorije i obezbedi jedinstveni adresni prostor svakom
 procesu.
\end_layout

\begin_layout Standard
U nastavu je predstavljena analiza karakteristika koje se razlikuju kod
 Linuxovog kernela i drugih UNIX varijanti:
\end_layout

\begin_layout Standard
• Linux podržava dinamičko učitavanje modula kernela.
 Iako je kernel Linuxa monolitan, on može dinamički da učita i vrati kôd
 kernela na zahtev.
 
\end_layout

\begin_layout Standard
• Linux podržava simetrične multiprocesore (Symmetrical Multiprocessing,
 SMP).
 Mada mnoge komercijalne varijante UNIX-a sada podržavaju SMP, to nije slučaj
 u tradicionalnim UNIX implementacijama.
\end_layout

\begin_layout Standard
• Linux kernel podržava raspoređivanje sa prinudnim suspendovanjem (preemptive
 scheduling).
 Za razliku od tradicionalnih UNIX varijanti, Linux kernel je sposoban da
 prekine izvršenje zadatka čak i onda kada se on izvršava u kernelu.
 Od drugih komercijalnih Unix implementacija, Solaris i IRIX imaju kernel
 sa prinudnom suspenzijom procesa, ali većina tradicionalnih UNIX kernela
 nije takva.
\end_layout

\begin_layout Standard
• Linux ne razlikuje niti i standardne procese.
 Iz ugla kernela svi procesi su isti; neki samo dele resurse.
\end_layout

\begin_layout Standard
• Linux obezbeđuje objektno orijentisan model uređaja sa klasama uređaja,
 događajima i sistemom datoteka uređaja korisničkog prostora (sysfs).
 
\end_layout

\begin_layout Standard
• Iz Linuxa su izostavljene neke loše projektovane UNIX karakteristike,
 npr.
 tokovi (stream) i loši standardi.
 
\end_layout

\begin_layout Section
Verzije jezgra Linuxa
\end_layout

\begin_layout Standard
Linux kerneli mogu biti stabilni i razvojni.
 Stabilni kerneli su izdanja pogodna za široku upotrebu.
 Nove stabilne verzije
\begin_inset Index idx
status open

\begin_layout Plain Layout
Linux!verzije kernela
\end_layout

\end_inset

 kernel
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel!verzije
\end_layout

\end_inset

a izdaju se najčešće samo da bi se obezbedile ispravke grešaka i novi upravljačk
i programi (drajveri).
 S druge strane, razvojni kerneli trpe značajne promene.
 
\end_layout

\begin_layout Standard
Verzije kernela označavaju se sa tri broja razdvojena tačkama.
 Prvi broj je glavno izdanje (major release), drugi broj je sporedna verzija
 (minor release), a treći je revizija (revision).
 Sporedna verzija određuje da li je kernel
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel!stabilna verzija
\end_layout

\end_inset

 u stabilnoj ili razvojnoj fazi: paran broj označava stabilnu verziju, a
 neparan razvojnu verziju
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel!razvojna verzija
\end_layout

\end_inset

 jezgra.
 Na primer, verzija kernela 2.6.0 označava stabilan kernel.
 Prva dva broja definišu "seriju kernela", u ovom slučaju to je serija kernela
 2.6.
\end_layout

\begin_layout Standard
Pojavljivale su se sledeće stabilne verzije kernela: [1.0.9] [1.2.13] [2.0.40]
 [2.2.26] [2.4.18] [2.4.20] [2.4.28] [2.6.10] [2.6.11]
\end_layout

\begin_layout Standard
Razvojna verzija serije 1.3 stabilizovana je na 2.0, a 2.5 na 2.6.
 Poslednja stabilna verzija otvorenog koda Linuxovog kernela je 3.0.
 Treća iteracija nazvana 3.0.0-rc1 pojavila se 15 godina nakon verzije 2.0.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 9.2: Oznake verzija Linuxovog jezgra.
\end_layout

\begin_layout Section
Početak rada sa kernelom 
\end_layout

\begin_layout Standard
Izvorni kôd Linuxa se može dobiti u obliku standardne distribucije izvornog
 koda (tarball) i dodatnih "zakrpa" (patch) sa zvaničnog sajta za Linuxov
 kernel,
\begin_inset Newline linebreak
\end_inset

 http://www.kernel.org (Slika 9.3).
 
\end_layout

\begin_layout Subsection
Instaliranje izvornog kôda kernela
\end_layout

\begin_layout Standard
Izvorni kôd kernela se distribuira ili u GNU formatu zip (gzip) ili češće
 u formatu bzip2.
 Kôd kernela
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel!instaliranje izvornog kôda
\end_layout

\end_inset

 u formatu bzip2 nalazi se u datoteci 
\family typewriter
linux-x.y.z.tar.bz2
\family default
, gde su
\family typewriter
 x.y.z
\family default
 verzije izvornog kôda.
 Ako je izvorni kôd komprimovan u bzip2 arhivu, u komandnoj liniji treba
 otkucati 
\end_layout

\begin_layout Standard

\family typewriter
$ tar xvjf linux-x.y.z.tar.bz2 
\end_layout

\begin_layout Standard
Ako je izvorni kod komprimovan u zip arhivu, treba otkucati
\end_layout

\begin_layout Standard

\family typewriter
$ tar xvzf linux-x.y.z.tar.gz 
\end_layout

\begin_layout Standard
Rezultat raspakivanja biće direktorijum 
\family typewriter
linux-x.y.z
\family default
.
 
\end_layout

\begin_layout Subsection
Korišćenje zakrpa
\end_layout

\begin_layout Standard
Distribucija izvornog kôda i novih verzija ostvaruje se zakrpa
\begin_inset Index idx
status open

\begin_layout Plain Layout
zakrpa
\end_layout

\end_inset

ma (patch).
 Da bi se primenile dodatne zakrpe (incremental patch) unutar stabla izvornog
 kernela, treba otkucati 
\end_layout

\begin_layout Standard

\family typewriter
$ patch p1 < ../patch-x.y.z 
\end_layout

\begin_layout Subsection
Stablo izvornog koda kernela
\end_layout

\begin_layout Standard
Stablo izvornog kôda
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel!stablo izvornog kôda
\end_layout

\end_inset

 podeljeno je na direktorijume i poddirektorijume koji su nabrojani i opisani
 počev od korenskog (root) direktorijuma u sledećoj Tabeli 9.1.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko3.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 9.3: Web strana za preuzimanje jezgra Linuxa.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row endhead="true">
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tabela 9.1: Stablo izvornog kôda jezgra Linuxa
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Direktorijum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
arch
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Izvor za specifične arhitekture
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
crypto
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interfejs za šifrovanje (CryptoAPI)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
documentation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dokumentacija za kernel
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
drivers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Upravljački programi uređaja
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Virtuelni i pojedinačni sistemi datoteka
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
include
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zaglavlja kernela
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
init
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Podizanje i inicijalizacija kernela
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ipc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kôd za komunikaciju između procesa
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
kernel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Podsistemi jezgra, kao što je raspoređivač
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
lib
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pomoćne rutine
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
mm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Podsistemi upravljanja memorijom i virtuelnom memorijom
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
net
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mrežni podsistem
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
scripts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Skriptovi za kompajliranje (build) kernela
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
security
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modul bezbednosti Linuxa
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
sound
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Podsistem za zvuk
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
usr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rani kôd korisničkog prostora (nazvan initramfs)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Kompajliranje i podešavanje kernela
\end_layout

\begin_layout Standard
Kernel nudi više alata za konfigurisanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel!podešavanje
\end_layout

\end_inset

.
 Najprostije je u komandnoj liniji uneti komandu:
\end_layout

\begin_layout Standard

\family typewriter
$ make config
\end_layout

\begin_layout Standard
Ova naredba prikazuje sve opcije i od korisnika traži da interaktivno bira
 yes, no ili module.
 Pošto to dugo traje, može da se pokrene i komanda:
\end_layout

\begin_layout Standard

\family typewriter
$ make menuconfig
\end_layout

\begin_layout Standard
ili za X11 grafiku:
\end_layout

\begin_layout Standard

\family typewriter
$ make xconfig
\end_layout

\begin_layout Standard
za gtk+ grafiku: 
\end_layout

\begin_layout Standard

\family typewriter
$ make gconfig
\end_layout

\begin_layout Standard
Komanda: 
\end_layout

\begin_layout Standard

\family typewriter
$ make defconfig
\end_layout

\begin_layout Standard
podešava standardnu konfiguraciju za određenu arhitekturu.
 Konfiguracione opcije nalaze se u datoteci .config korena stabla izvornog
 kôda kernela.
 Veoma često se ta datoteka direktno menja, a nakon toga konfiguracija se
 ažurira naredbom: 
\end_layout

\begin_layout Standard

\family typewriter
$ make oldconfig
\family default
 
\end_layout

\begin_layout Standard
Ovo bi trebalo da se uradi pre kompajliranja (building) kernela.
 Nakon podešavanja konfiguracije jezgra, ono treba da se kompajlira naredbom:
 
\end_layout

\begin_layout Standard

\family typewriter
$ make
\family default
 
\end_layout

\begin_layout Subsection
Instalacija kernela
\end_layout

\begin_layout Standard
Nakog kompajliranja, kernel
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel!instaliranje
\end_layout

\end_inset

 treba da se instalira.
 Način instaliranja zavisi od arhitekture sistema i modula za podizanje
 (boot loader), pa u odgovarajućoj dokumentaciji treba potražiti uputstva
 gde treba kopirati sliku kernela i kako je treba podesiti za podizanje.
 Na primer, za x86 arhitekturu treba kopirati 
\family typewriter
arch/i386/boot/bzImage
\family default
 u 
\family typewriter
/boot
\family default
, dodeliti mu ime 
\family typewriter
vmlinuz-version
\family default
 i promeniti sadržaj datoteke 
\family typewriter

\begin_inset Newline linebreak
\end_inset

/boot/grub/grub.conf
\family default
 gde treba navesti novi kernel.
 U sistemu koji koristi modul za podizanje LILO treba promeniti datoteku
 
\family typewriter
/etc/lilo.conf
\family default
.
 Instaliranje modula kernela je automatsko i nezavisno od arhitekture, a
 postiže se komandom
\end_layout

\begin_layout Standard

\family typewriter
$ make modules_install
\family default
 
\end_layout

\begin_layout Standard
pri čemu se svi instalirani kompajlirani moduli smeštaju u direktorijum
 
\family typewriter
/lib
\family default
.
 
\end_layout

\begin_layout Standard
Treba imati u vidu da se kernel prilično razlikuje od standardnih aplikacija
 korisničkog prostora: 
\end_layout

\begin_layout Standard
• nema pristup C biblioteci 
\end_layout

\begin_layout Standard
• napisan je u GNU C-u 
\end_layout

\begin_layout Standard
• nema zaštitu memorije kao korisnički prostor 
\end_layout

\begin_layout Standard
• ne može lako da radi sa promenljivama u pokretnom zarezu (floating point)
 
\end_layout

\begin_layout Standard
• ima mali stek fiksne veličine 
\end_layout

\begin_layout Standard
• pošto koristi asimetrične prekide, prinudno preuzimanje procesa i podržava
 SMP, sinhronizacija i konkurentnost su najvažniji za kernel 
\end_layout

\begin_layout Standard
• važno je da kernel bude prenosiv, tj.
 da radi na raznim platformama.
 
\end_layout

\begin_layout Chapter
Upravljanje procesima u Linuxu
\end_layout

\begin_layout Standard
Proces je, uz datoteku, jedna od osnovih apstrakcija u operativnom sistemu.
 Proces je program (objektni kôd uskladišten na nekom medijumu) u izvršenju.
 Međutim, procesi se ne mogu svesti samo na izvršavanje programskog kôda
 (koji se u UNIX-u često zove i sekcija kôda).
 Oni uključuju i skup resursa kao što su otvorene datoteke i signali, interni
 podaci jezgra, stanje procesa, adresni prostor, jedna ili više niti u izvršenju
 i sekcija podataka u kome se nalaze globalne promenljive.
 Procesi su zapravo sve ono što je rezultat izvršavanja programskog kôda.
 Niti izvršenja, ili samo niti, su objekti aktivnosti unutar procesa.
 Svaka nit uključuje jedinstveni programski brojač, stek procesa i skup
 registara procesora.
 Kernel raspoređuje pojedinačne niti, a ne procese.
 U tradicionalnim UNIX sistemima, svaki proces se sastoji od jedne niti.
 U modernim sistemima, međutim, programi sa više niti su uobičajeni.
 
\end_layout

\begin_layout Standard
Linux nitima prilazi na specifičan način, jer ne pravi razliku između niti
 i procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
procesi!i niti
\end_layout

\end_inset

.
 U Linuxu je nit samo specijalna vrsta procesa.
 U modernim operativnim sistemima, procesi obezbeđuju dve vrste virtuelizacije
 procesora i memorije.
 Virtuelni procesor 
\begin_inset Quotes eld
\end_inset

zavarava
\begin_inset Quotes erd
\end_inset

 proces da ima monopol nad sistemom, iako je procesor zapravo podeljen između
 velikog broja drugih procesa.
 Postupak 
\begin_inset Quotes eld
\end_inset

zavaravanja
\begin_inset Quotes erd
\end_inset

 spada u kategoriju raspoređivanja procesa.
 Virtuelna memorija dozvoljava dodelu memorije procesu.
 Treba obratiti pažnju da niti dele apstraktnu virtuelnu memoriju, ali svaka
 nit ima sopstveni, 
\begin_inset Quotes eld
\end_inset

virtuelizovan
\begin_inset Quotes erd
\end_inset

 procesor.
 Sâm program nije proces; proces je aktivan program sa povezanim resursima.
 Dva ili više procesa mogu da postoje i da izvršavaju isti program.
 U stvari, dva ili više procesa mogu da postoje i da dele različite resurse,
 kao što su otvorene datoteke ili adresni prostor.
 
\end_layout

\begin_layout Standard
Ime koje se u Linuxu koristi za proces je
\begin_inset Index idx
status open

\begin_layout Plain Layout
zadatak
\end_layout

\end_inset

 
\series bold
zadatak 
\series default
(task).
 U Linuxu se proces pravi sistemskim pozivom 
\family typewriter
fork()
\family default
 kojim se kreira novi proces tako što se duplira postojeći.
 Proces koji poziva 
\family typewriter
fork()
\family default
 je proces roditelj, dok je kreiran proces dete.
 Proces roditelj nastavlja da se izvršava, a proces dete počinje izvršavanje
 na istom mestu gde se sistemski poziv vraća.
 Sistemski poziv 
\family typewriter
fork()
\family default
 se vraća iz kernela dva puta: jednom u proces roditelj i ponovo u nov proces
 dete.
 
\end_layout

\begin_layout Standard
Za kreiranje novog adresnog prostora i učitavanje novog programa u njega
 koristi se porodica funkcijskih programa 
\family typewriter
exec*()
\family default
.
 U jezgru Linuxa, sistemski poziv 
\family typewriter
fork()
\family default
 je implementiran preko sistemskog poziva 
\family typewriter
clone()
\family default
, o čemu će biti više reči u sledećem odeljku.
 Program se završava sistemskim pozivom 
\family typewriter
exit()
\family default
.
 Ova funkcija završava proces i oslobađa sve njegove resurse.
 Proces roditelj
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!roditelj
\end_layout

\end_inset

 može da sazna status završenog procesa deteta
\begin_inset Index idx
status open

\begin_layout Plain Layout
procesa!dete
\end_layout

\end_inset

 preko sistemskog poziva 
\family typewriter
wait4()
\family default
, koji omogućuje procesu da čeka završetak određenog procesa.
 Kada se proces završi, šalje se u specijalno 
\begin_inset Quotes eld
\end_inset

zombi
\begin_inset Quotes erd
\end_inset

 stanje koje se koristi za predstavljanje završenih procesa sve dok proces
 roditelj ne pozove 
\family typewriter
wait()
\family default
 ili 
\family typewriter
waitpid()
\family default
.
 Linux sistemi preko C biblioteke obično obezbeđuju funkcije 
\family typewriter
wait()
\family default
, 
\family typewriter
waitpid()
\family default
, 
\family typewriter
wait3()
\family default
 i 
\family typewriter
wait4()
\family default
.
 Sve ove funkcije vraćaju status završenog procesa sa nešto drugačijom semantiko
m.
 
\end_layout

\begin_layout Section
Deskriptor procesa
\end_layout

\begin_layout Standard
Kernel uvezuje procese
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!deskriptor
\end_layout

\end_inset

 u kružnu dvostruko ulančanu listu zadataka (task).
 Elementi u listi zadataka su deskriptori procesa tipa C strukture 
\family typewriter
task_struct
\family default
, definisane u datoteci 
\family typewriter
<linux/sched.h>
\family default
.
 Deskriptor procesa sadrži sve informacije o određenom procesu (to je zapravo
 blok za kontrolu procesa, PCB).
 Struktura 
\family typewriter
task_struct
\family default
 je relativno velika struktura podataka: zauzima približno 1,7 KB za 32-bitne
 mašine, a sadrži sve informacije koje jezgro treba da ima o procesu: otvorene
 datoteke, adresni prostor procesa, stanja procesa itd.
 (Slika 10.1)
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko4.png
	scale 65

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 10.1: Deskriptor procesa i lista zadataka.
\end_layout

\begin_layout Standard
Struktura zadatka (
\family typewriter
thread_info
\family default
) definisana je za arhitekture x86 u zaglavlju 
\family typewriter

\begin_inset Newline newline
\end_inset

<asm/thread_info.h>
\family default
:
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
struct thread_info { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct task_struct *task; 
\end_layout

\begin_layout LyX-Code

\size small
struct exec_domain *exec_domain; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long flags; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long status; 
\end_layout

\begin_layout LyX-Code

\size small
__u32 cpu; 
\end_layout

\begin_layout LyX-Code

\size small
__s32 preempt_count; 
\end_layout

\begin_layout LyX-Code

\size small
mm_segment_t addr_limit; 
\end_layout

\begin_layout LyX-Code

\size small
struct restart_block restart_block; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long previous_esp; 
\end_layout

\begin_layout LyX-Code

\size small
__u8 supervisor_stack[0]; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout Standard
Svaka struktura zadatka
\begin_inset Index idx
status open

\begin_layout Plain Layout
zadatak!struktura
\end_layout

\end_inset

 
\family typewriter
thread_info
\family default
 alocirana je na kraju steka zadatka.
 Element strukture 
\family typewriter
*task
\family default
 je pokazivač na stvarnu strukturu 
\family typewriter
task_struct
\family default
, što je prikazano na Slici 10.2.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko5.png
	scale 65

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 10.2: Deskriptor i stek zadatka.
\end_layout

\begin_layout Subsection
Skladištenje deskriptora procesa
\end_layout

\begin_layout Standard
Sistem identifikuje proces pomoću jedinstvenog identifikacionog broja (PID).
 PID je brojna vrednost predstavljena tipom 
\family typewriter
pid_t
\family default
 (što je tipično 
\family typewriter
int
\family default
).
 Kernel čuva ovu vrednost kao 
\family typewriter
pid
\family default
 unutar svakog deskriptora procesa (strukture 
\family typewriter
task_struct
\family default
).
 Administrator operativnog sistema može ovu vrednost da poveća izmenom datoteke
 
\family typewriter
/proc/sys/kernel/pid_max
\family default
.
 Unutar kernela zadaci se obično referenciraju direktno pokazivačem na njihovu
 strukturu
\family typewriter
 task_struct
\family default
.
 Kernel kôd koji se bavi procesima
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!identifikator(PID)
\end_layout

\end_inset

 radi direktno sa strukturom 
\family typewriter
task_struct
\family default
.
 Zbog toga je veoma korisna mogućnost da se brzo pronađe deskriptor procesa
 zadatka koji se izvršava, što omogućuje makro 
\family typewriter
current
\family default
.
 Ovaj makro se posebno implementira za svaku arhitekturu.
 
\end_layout

\begin_layout Section
Stanja procesa u Linuxu
\end_layout

\begin_layout Standard
Polje deskriptora opisuje trenutno stanje procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!stanja u Linuxu
\end_layout

\end_inset

.
 Svaki proces u sistemu je u jednom od pet poznatih stanja, pa je stanje
 predstavljeno jednim od pet flegova: 
\end_layout

\begin_layout Standard
• 
\shape italic
TASK_RUNNING
\shape default
: proces se može izvršiti; proces se ili trenutno izvršava ili je u redu
 procesa spremnih za izvršenje.
 Ovo je jedino moguće stanje za proces koji se izvršava u korisničkom prostoru;
 može se takođe primeniti i za proces koji se aktivno izvršava u prostoru
 jezgra.
 
\end_layout

\begin_layout Standard
• 
\shape italic
TASK_INTERRUPTIBLE
\shape default
: proces "spava" (blokiran je), čekajući da se ispuni neki uslov.
 Kada je uslov ispunjen, kernel postavlja stanje procesa na TASK_RUNNING.
 Proces se takođe "budi" prerano i postaje kandidat za izvršavanje ako primi
 signal.
 
\end_layout

\begin_layout Standard
• 
\shape italic
TASK_UNINTERRUPTIBLE
\shape default
: ovo stanje je identično stanju TASK_INTERRUPTIBLE, osim što se proces
 ne "budi" i ne postaje kandidat za izvršavanje kada primi signal.
 Ovo stanje se koristi u situacijama kada proces mora da čeka bez prekida
 ili kada se događaj očekuje veoma brzo.
 
\end_layout

\begin_layout Standard
• 
\shape italic
TASK_ZOMBIE
\shape default
: Zadatak je završen, ali njegov proces roditelj još nije izdao sistemski
 poziv 
\family typewriter
wait4()
\family default
.
 Deskriptor procesa mora da se sačuva za slučaj da proces roditelj želi
 da mu pristupi.
 Kada proces roditelj pozove 
\family typewriter
wait4()
\family default
, deskriptor procesa se dealocira.
 
\end_layout

\begin_layout Standard
• 
\shape italic
TASK_STOPPED
\shape default
: Izvršavanje procesa se zaustavlja; zadatak se ne izvršava niti se bira
 za izvršavanje.
 Zadatak je u ovom stanju ako primi neki od signala SIGSTOP, SIGTSTP, SIGTTIN,
 ili SIGTTOU (ili ako primi bilo kakav signal tokom debagovanja).
 
\end_layout

\begin_layout Section
Kontekst procesa
\end_layout

\begin_layout Standard
Tokom izvršavanja programskog kôda u procesu, kôd se čita iz datoteke koja
 se izvršava unutar adresnog prostora programa.
 Normalno izvršavanje programa se ostvaruje u korisničkom prostoru.
 Kada program izvršava sistemski poziv ili generiše izuzetak, on ulazi u
 prostor jezgra i definiše se kontekst procesa.
 Nakon napuštanja kernela, proces
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!kontekst
\end_layout

\end_inset

 nastavlja izvršenje u korisničkom prostoru sve dok proces višeg prioriteta
 ne postane kandidat za izvršavanje.
 Tada se poziva raspoređivač procesa (scheduler) koji šalje proces višeg
 prioriteta na izvršavanje.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko6.png
	scale 75

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 10.3: Dijagram toka stanja procesa u Linuxu.
\end_layout

\begin_layout Section
Copy-on-Write
\end_layout

\begin_layout Standard
Tradicionalno, kada se izvršava sistemski poziv 
\family typewriter
fork()
\family default
, svi resursi koje poseduje proces roditelj se dupliraju, a kopija resursa
 se predaje procesu detetu.
 Ovaj postupak je neefikasan.
 Zbog toga je u Linuxu sistemski poziv 
\family typewriter
fork()
\family default
 implementiran kroz korišćenje copy-on-write
\begin_inset Index idx
status open

\begin_layout Plain Layout
copy-on-write
\end_layout

\end_inset

 stranica.
 Copy-on-write (ili COW) je tehnika odlaganja kopiranja podataka.
 Umesto dupliranja adresnog prostora procesa, proces roditelj i proces dete
 mogu da dele istu kopiju adresnog prostora.
 Podaci se, međutim, obeležavaju na takav način da ako se upisuju, pravi
 se duplikat i tada svaki proces prima jedinstvenu kopiju podataka.
 Dakle, duplikati resursa prave se samo u slučaju upisivanja podataka.
 Sve dok se podaci samo učitavaju, oni se dele, tj.
 ne pravi se posebna kopija za proces dete.
 Ova tehnika odlaže kopiranje svake strane u adresni prostor sve dok se
 ne zatraži upisivanje.
 U slučaju da se nikada ne upisuje, na primer, ako se 
\family typewriter
exec()
\family default
 pozove odmah nakon sistemskog poziva 
\family typewriter
fork()
\family default
, nema nikakve potrebe za kopiranjem.
 Jedini opšti trošak koji se pojavljuje izvršenjem sistemskog poziva 
\family typewriter
fork()
\family default
 je dupliranje tabele strana procesa roditelja i kreiranje jedinstvenog
 deskriptora za proces dete.
 Ovo je važna optimizacija u Linuxu u poređenju sa UNIX filozofijom koja
 ne podržava brzo izvršavanje procesa.
 
\end_layout

\begin_layout Section
Sistemski poziv fork()
\end_layout

\begin_layout Standard
Linux implementira 
\family typewriter
fork()
\family default
 preko sistemskog poziva
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski pozivi!fork()
\end_layout

\end_inset

 
\family typewriter
clone()
\family default
.
 Bibliotečki pozivi 
\family typewriter
fork()
\family default
, 
\family typewriter
vfork()
\family default
 i 
\family typewriter
__clone()
\family default
 pozivaju sistemski poziv 
\family typewriter
clone()
\family default
 sa neophodnim flegovima.
 Sistemski poziv 
\family typewriter
clone()
\family default
 poziva 
\family typewriter
do_fork()
\family default
, koji je definisan u datoteci 
\family typewriter
kernel/fork.c
\family default
.
 Ova funkcija poziva 
\family typewriter
copy_process()
\family default
 i tada počinje izvršavanje procesa.
 Sistemski poziv 
\family typewriter
vfork()
\family default
 ima isti efekat kao i 
\family typewriter
fork()
\family default
, osim što se ne kopira tabela upisa strana procesa roditelja.
 Umesto toga, proces dete se izvršava kao samostalna nit u adresnom prostoru
 roditelja, a roditelj je blokiran sve dok proces dete ne pozove 
\family typewriter
exec()
\family default
 ili se ne završi.
 
\end_layout

\begin_layout Section
Niti u Linuxu
\end_layout

\begin_layout Standard
Niti su popularna programska apstrakcija koja obezbeđuje više tokova izvršavanja
 unutar istog programa u deljenom memorijskom adresnom prostoru.
 Niti mogu da dele i otvorene datoteke, kao i druge resurse.
 U sistemima sa jednim procesorom nit
\begin_inset Index idx
status open

\begin_layout Plain Layout
nit!u Linuxu
\end_layout

\end_inset

i dozvoljavaju konkurentno programiranje, dok u multiprocesorskim sistemima
 omogućuju pravi paralelizam.
 
\end_layout

\begin_layout Standard
Linux ima jedinstvenu implementaciju niti: kernel uopšte ne poznaje pojam
 niti, već ih implementira kao standardne procese.
 Linux kernel ne obezbeđuje nikakve specijalne semantike raspoređivanja
 niti strukture podataka za predstavljanje niti.
 Umesto toga, nit je samo proces koji deli određene resurse sa drugim procesima.
 Svaka nit ima jedinstvenu strukturu 
\family typewriter
task_struct
\family default
.
 Ovaj pristup se razlikuje od pristupa u drugim operativnim sistemima kao
 što su Microsoftov Windows ili Sunov Solaris, u kojima kernel eksplicitno
 podržava rad sa nitima (koje se ponekad zovu i laki procesi).
 
\end_layout

\begin_layout Standard
U Linuxu, niti se kreiraju kao standardni zadaci, sa izuzetkom da sistemski
 poziv 
\family typewriter
clone()
\family default
 postavlja flegove prema specifičnim resursima koji se dele:
\end_layout

\begin_layout Standard

\family typewriter
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);
\end_layout

\begin_layout Standard
Prethodni kôd daje isti rezultat kao i običan 
\family typewriter
fork()
\family default
, osim što su adresni prostor, resursi sistema datoteka, deskriptori datoteka
 i rukovaoci signalima deljeni.
 Suprotno, običan 
\family typewriter
fork()
\family default
 može da se implementira kao:
\end_layout

\begin_layout Standard

\family typewriter
clone(SIGCHLD, 0);
\end_layout

\begin_layout Standard
Sistemski poziv 
\family typewriter
vfork()
\family default
 je implementiran kao:
\end_layout

\begin_layout Standard

\family typewriter
clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0);
\family default
 
\end_layout

\begin_layout Standard
Sledeća tabela prikazuje flegove i odgovarajuće opise sistemskog poziva
 
\family typewriter
clone()
\family default
, koji su definisani u zaglavlju 
\family typewriter
<linux/sched.h>
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="21" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="50text%">
<row endhead="true">
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none" width="50text%">
\begin_inset Text

\begin_layout Plain Layout
Tabela 10.1: Flegovi funkcije 
\family typewriter
clone()
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fleg
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Značenje
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_FILES 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Roditelj i dete dele otvorene datoteke.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_FS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Roditelj i dete dele informacije o sistemu datoteka.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_IDLETASK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja PID na 0 (koristi se samo za zadatke koji se ne izvršavaju).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_NEWNS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kreiranje novog prostora imena za proces dete.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_PARENT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dete treba da ima istog roditelja kao njegov roditelj.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_PTRACE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nastavlja praćenje deteta.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_SETTID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Upisuje TID u korisnički prostor.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_SETTLS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pravi novi TLS (thread-local storage) za dete.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_SIGHAND
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Roditelj i dete dele rukovaoce signalima i blokirane signale.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_SYSVSEM
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Roditelj i dete dele System V SEM_UNDO semantiku.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_THREAD
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Roditelj i dete su u istoj grupi niti.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_VFORK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Korišćen je vfork() i roditelj će spavati dok ga dete ne probudi.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_UNTRACED
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ne dozvoliti da proces praćenja primora CLONE_PTRACE za dete.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_STOP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Proces treba da započne u stanju TASK_STOPPED.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_SETTLS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pravi nov TLS za dete.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_CHILD_CLEARTID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Briše TID u detetu.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_CHILD_SETTID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja TID u detetu.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_PARENT_SETTID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja TID u roditelju.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLONE_VM 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Roditelj i dete dele adresni prostor.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Niti jezgra
\end_layout

\begin_layout Standard
Veoma često kernel izvršava neke operacije u pozadini, koristeći nit
\begin_inset Index idx
status open

\begin_layout Plain Layout
nit!jezgra
\end_layout

\end_inset

i jezgra.
 To su standardni procesi koji postoje samo u prostoru kernela.
 Bitna razlika između niti jezgra i običnih procesa je u tome što niti jezgra
 nemaju adresni prostor (tj.
 njihov pokazivač ima vrednost NULL).
 One rade samo u prostoru kernela i ne menjaju kontekst u korisnički prostor.
 Niti jezgra se mogu raspoređivati i prinudno suspendovati kao svaki običan
 proces.
\end_layout

\begin_layout Section
Završetak procesa
\end_layout

\begin_layout Standard
Kada se proces završi, kernel oslobađa resurse koje koristi proces i obaveštava
 proces roditelj o završetku.
 Uništavanje procesa obično se dešava kada proces pozove 
\family typewriter
exit()
\family default
, eksplicitno kada je spreman za završetak ili implicitno na povratku iz
 glavnog potprograma bilo kog programa.
 Proces se može završiti i prinudno, ako primi signal ili izuzetak koji
 ne može da obradi ili ignoriše.
 Bez obzira kako se proces završava, posao završetka
\begin_inset Index idx
status open

\begin_layout Plain Layout
proces!završetak
\end_layout

\end_inset

 obavlja funkcija 
\family typewriter
do_exit()
\family default
, definisana u datoteci 
\family typewriter
kernel/exit.c
\family default
.
\end_layout

\begin_layout Subsection
Uklanjanje deskriptora procesa
\end_layout

\begin_layout Standard
Nakon izvršenja funkcije
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski pozivi!do_exit()
\end_layout

\end_inset

 
\family typewriter
do_exit()
\family default
, deskriptor završenog procesa još uvek postoji, ali je proces u 
\begin_inset Quotes eld
\end_inset

zombi
\begin_inset Quotes erd
\end_inset

 stanju i ne može da se izvršava.
 To dozvoljava sistemu da dobije informacije od procesa deteta nakon njegovog
 završetka.
 Porodica funkcija 
\family typewriter
wait()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski pozivi!wait()
\end_layout

\end_inset

 implementirana je preko jednog (vrlo složenog) sistemskog poziva 
\family typewriter
wait4()
\family default
.
 Standardno ponašanje je suspenzija izvršavanja pozvanog zadatka sve dok
 postoji barem jedan njegov proces dete, kada funkcija vraća PID procesa
 deteta koji se završava.
 
\end_layout

\begin_layout Section
Raspoređivanje procesa u Linuxu
\end_layout

\begin_layout Standard
Raspoređivač procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
procesi!raspoređivanje u Linuxu
\end_layout

\end_inset

 (scheduler) je modul kernela koji bira sledeći proces za izvršavanje.
 Raspoređivač deli konačne resurse procesorskog vremena između procesa u
 sistemu spremnih za izvršavanje.
 Raspoređivač je osnova multitasking operativnog sistema kao što je Linux.
 Odlukom koji proces može da počne izvršavanje, raspoređivač direktno utiče
 na najbolje iskorišćenje sistema i stvara privid da se više procesa izvršava
 istovremeno.
 
\end_layout

\begin_layout Standard
Multitasking operativni sistem istovremeno održava izvršavanje više od jednog
 procesa.
 Na jednoprocesorskoj mašini to stvara privid da se više procesa izvršava
 konkurentno.
 Na multiprocesorskoj mašini to omogućava da se procesi stvarno izvršavaju
 konkurentno, tj.
 paralelno na različitim procesorima.
 Postoji i veliki broj procesa koji se "izvršavaju" u pozadini, odnosno
 kernel ih blokira dok se ne desi neki događaj (ulaz sa tastature, podaci
 sa mreže itd.).
 Savremeni Linux sistemi mogu da imaju i po stotinak procesa u memoriji,
 ali samo jedan može biti u stanju izvršavanja.
 
\end_layout

\begin_layout Standard
Kao i sve UNIX varijante, i Linux primenjuje raspoređivanje sa prinudnom
 suspenzijom procesa (preemptive multitasking).
 U takvom načinu raspoređivanja, raspoređivač odlučuje kada proces prestaje
 da se izvršava, a novi proces nastavlja izvršavanje.
 Procesorsko vreme tokom koga se proces izvršava pre nego što se suspenduje
 je unapred definisano i zove se
\begin_inset Index idx
status open

\begin_layout Plain Layout
vremenski odsečak
\end_layout

\end_inset

 
\series bold
vremenski odsečak
\series default
 (timeslice).
 Upravljanje vremenskim odsečcima omogućuje raspoređivaču globalno raspoređivanj
e u sistemu, a procese sprečava da preuzmu monopol nad procesorom.
 
\end_layout

\begin_layout Standard
Većina operativnih sistema projektovanih u poslednjoj deceniji podržava
 raspoređivanje sa prinudnom suspenzijom procesa
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!sa prinudnom suspenzijom procesa
\end_layout

\end_inset

 (UNIX ga podržava od početka).
 U Linuxu je počev od razvojne serije kernela 2.6 definisan novi raspoređivač,
 nazvan O(1) koji ćemo u nastavku detaljno proučiti.
\end_layout

\begin_layout Subsection
U/I-ograničeni i procesorski ograničeni procesi
\end_layout

\begin_layout Standard
Kada procesi troše najviše vremena na U/I zahteve, kaže se da su U/I ograničeni
\begin_inset Index idx
status open

\begin_layout Plain Layout
procesi!U/I ograničeni
\end_layout

\end_inset

.
 Postoje i procesi koji provode dosta vremena izvršavajući kôd; za njih
 kažemo da su procesorski ograničeni.
 Ova klasifikacija nije međusobno isključiva.
 Politika raspoređivanja u sistemu mora da pokuša da zadovolji dva suprotstavlje
na cilja: kratko vreme odziva procesa (malo kašnjenje) i maksimalno iskorišćenje
 sistema (visoka propusnost).
 Da bi se zadovoljili ovi uslovi, raspoređivači često koriste složene algoritme
 da bi na osnovu zadatih kriterijuma odredili procese koji se izvršavaju.
 Politika raspoređivanja kod Linuxa optimizuje odziv procesa, tj.
 teži da ostvari minimalno kašnjenje favorizovanjem U/I ograničenih procesa
 u odnosu na procesorski ograničene procese.
\end_layout

\begin_layout Subsection
Prioritet procesa
\end_layout

\begin_layout Standard
Najprostiji tip algoritma raspoređivanja je raspoređivanje po prioritetu
\begin_inset Index idx
status open

\begin_layout Plain Layout
procesi!raspoređivanje po prioritetu
\end_layout

\end_inset

.
 Procesi se rangiraju na osnovu dodeljenog prioriteta i procesorskog vremena
 koje im je potrebno za izvršenje.
 Procesi sa većim prioritetom se prvo izvršavaju.
 Kada procesi imaju isti prioritet, koristi se kružno raspoređivanje (round-robi
n).
 U nekim sistemima procesi sa većim prioritetom dobijaju duži vremenski
 odsečak procesora.
 Linux koristi dinamičko raspoređivanje zasnovano na prioritetu.
 Linux kernel primenjuje dva odvojena opsega prioriteta.
 Prvi je vrednost 
\family typewriter
nice
\begin_inset Index idx
status open

\begin_layout Plain Layout
nice vrednost
\end_layout

\end_inset


\family default
, broj između -20 i +19 sa podrazumevanom (default) vrednošću 0.
 Veća vrednost 
\family typewriter
nice
\family default
 odgovara nižem prioritetu (jer to znači da proces ima dobar (nice) odnos
 prema drugim procesima u sistemu).
 Proces sa 
\family typewriter
nice
\family default
 vrednošću od -20 dobija maksimalni odsečak vremena.
 Drugi opseg je prioritet u realnom vremenu.
 Vrednosti prioriteta mogu da se podešavaju, ali je podrazumevani opseg
 od 0 do 99.
 Svi procesi u realnom vremenu imaju veći prioritet od običnih procesa.
 Linux primenjuje prioritete u realnom vremenu prema POSIX standardima.
 
\end_layout

\begin_layout Standard
Linuxov raspoređivač je definisan u datoteci 
\family typewriter
kernel/sched.c
\family default
.
 U nastavku je dat deo kôda kernela v3.0 koji se odnosi na vrednosti 
\family typewriter
nice
\family default
:
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1397/* 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1398 * Nice levels are multiplicative, with a gentle 10% change for every
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1399 * nice level changed.
 I.e.
 when a CPU-bound task goes from nice 0 to 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1400 * nice 1, it will get ~10% less CPU time than another CPU-bound task
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1401 * that remained on nice 0.
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1402 * 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1403 * The "10% effect" is relative and cumulative: from _any_ nice level,
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1404 * if you go up 1 level, it's -10% CPU usage, if you go down 1 level
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1405 * it's +10% CPU usage.
 (to achieve that we use a multiplier of 1.25.
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1406 * If a task goes up by ~10% and another task goes down by ~10% then
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1407 * the relative distance between them is ~25%.) 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1408 */ 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1409 static const int prio_to_weight[40] = { 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1410 /* -20 */ 88761, 71755, 56483, 46273, 36291, 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1411 /* -15 */ 29154, 23254, 18705, 14949, 11916, 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1412 /* -10 */ 9548, 7620, 6100, 4904, 3906, 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1413 /* -5 */ 3121, 2501, 1991, 1586, 1277, 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1414 /* 0 */ 1024, 820, 655, 526, 423, 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1415 /* 5 */ 335, 272, 215, 172, 137, 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1416 /* 10 */ 110, 87, 70, 56, 45, 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1417 /* 15 */ 36, 29, 23, 18, 15, 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
1418};
\end_layout

\begin_layout Subsection
Vremenski odsečak
\end_layout

\begin_layout Standard
Vremenski odsečak
\begin_inset Index idx
status open

\begin_layout Plain Layout
vremenski odsečak
\end_layout

\end_inset

 (timeslice) je numerička vrednost koja definiše koliko dugo zadatak može
 da se izvršava pre nego što bude prinudno suspendovan.
 Vremenski odsečak se ponekad naziva i kvantum
\begin_inset Index idx
status open

\begin_layout Plain Layout
kvantum
\end_layout

\end_inset

 ili procesorski odsečak.
 Određivanje podrazumevanog trajanja vremenskog odsečka nije trivijalan
 zadatak.
 Velika vrednost daje slabe interaktivne performanse sistema, pa nije pogodna
 za aplikacije koje se konkurentno izvršavaju.
 Mala vrednost prouzrokuje gubljenje mnogo procesorskog vremena na opšte
 troškove prebacivanja rada sa jednog procesa na drugi.
 Ponovo se pojavljuju suprotstavljeni ciljevi U/I-ograničenih procesa i
 procesorski ograničenih procesa: za razliku od U/I-ograničenih procesa
 koji ne zahtevaju duže vremenske odsečke, procesorski ograničeni procesi
 traže duže odsečke.
 Linux koristi činjenicu da procesi sa najvećim prioritetom uvek započinju
 izvršavanje prvi.
 Raspoređivač povećava prioritet interaktivnih zadataka omogućavajući im
 da se češće izvršavaju.
 Linuxov raspoređivač definiše relativno veliki podrazumevani vremenski
 odsečak (kvantum), odnosno dinamički određuje vrednost kvantuma procesa
 na osnovu prioriteta.
 Primena dinamičkih kvantuma
\begin_inset Index idx
status open

\begin_layout Plain Layout
kvantum!dinamički
\end_layout

\end_inset

 i prioriteta omogućuje robusno raspoređivanje (Slika 10.4).
 
\end_layout

\begin_layout Standard
Treba obratiti pažnju da proces ne mora da iskoristi ceo svoj kvantum odjednom.
 Kada "istekne" kvantum, proces dalje nije kandidat za izvršavanje sve dok
 svi ostali procesi ne "potroše" svoje kvantume.
 U tom trenutku kvantumi svih procesa se ponovo izračunavaju.
 
\end_layout

\begin_layout Standard
Linux primenjuje prinudnu suspenziju procesa (process preemption).
 Kada proces uđe u stanje TASK_RUNNING, kernel proverava da li je njegov
 prioritet veći od prioriteta procesa koji se u tom trenutku izvršava.
 Ako jeste, poziva se raspoređivač da prisilno suspenduje, odnosno prekine
 izvršavanje procesa koji se izvršava u tom trenutku i počne izvršavanje
 novog procesa.
 Takođe, kada kvantum procesa dostigne vrednost 0, proces se prekida i raspoređi
vač se poziva da izabere novi proces.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko7.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 10.4: Izračunavanje vremenskog odsečka (kvantuma) procesa.
\end_layout

\begin_layout Standard
Raspoređivač je projektovan tako da ostvari sledeće specifične ciljeve:
 
\end_layout

\begin_layout Standard
• Potpuna primena O(1) raspoređivanja.
 Svaki algoritam u novom raspoređivaču se izvršava za konstantno vreme bez
 obzira koliki je broj procesa koji se izvršavaju.
 
\end_layout

\begin_layout Standard
• Svaki procesor ima svoj sopstveni red čekanja (run queue).
 
\end_layout

\begin_layout Standard
• Obezbeđivanje dobrih karakteristika interaktivnosti.
 Čak i za vreme značajnih opterećenja, sistem treba da reaguje i trenutno
 rasporedi interaktivne zadatke.
 
\end_layout

\begin_layout Standard
• Obezbeđivanje pravednog odnosa prema procesima u odnosu na kvantum.
 
\end_layout

\begin_layout Standard
• Optimizacija za slučaj jednog ili dva procesa koji se izvršavaju na multiproce
soru.
 
\end_layout

\begin_layout Subsection
Redovi za čekanje
\end_layout

\begin_layout Standard
Osnovna struktura podataka kod raspoređivača je red za čekanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
procesi!red za čekanje
\end_layout

\end_inset

, definisana u datoteci 
\family typewriter
kernel/sched.c
\family default
 kao struktura 
\family typewriter
runqueue
\family default
.
 Red za čekanje je lista procesa koji se mogu izvršiti na datom procesoru.
 Za svaki procesor definiše se po jedan red.
 U nastavku je dat kôd strukture sa komentarima koji opisuju svako njeno
 polje: 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
struct runqueue { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
spinlock_t lock; /* spin lock that protects this runqueue */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
unsigned long nr_running; /* number of runnable tasks */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
unsigned long nr_switches; /* context switch count */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
unsigned long expired_timestamp; /* time of last array swap */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
unsigned long nr_uninterruptible; /* uninterruptible tasks */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
unsigned long long timestamp_last_tick; /* last scheduler tick */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
struct task_struct *curr; /* currently running task */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
struct task_struct *idle; /* this processor's idle task */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
struct mm_struct *prev_mm; /* mm_struct of last ran task */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
struct prio_array *active; /* active priority array */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
struct prio_array *expired; /* the expired priority array */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
struct prio_array arrays[2]; /* the actual priority arrays */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
struct task_struct *migration_thread; /* migration thread */ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
struct list_head migration_queue; /* migration queue*/ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
atomic_t nr_iowait; /* number of tasks waiting on I/O */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
};
\end_layout

\begin_layout Standard
S obzirom da su redovi za čekanje jezgro strukture podataka u raspoređivaču,
 za dobijanje reda za čekanje za dati procesor ili proces koristi se grupa
 makroa.
 Makro 
\family typewriter
cpu_rq(processor)
\family default
 vraća pokazivač na red za čekanje pridružen datom procesoru; makro 
\family typewriter
this_rq()
\family default
 vraća red za čekanje tekućeg procesora, a makro 
\family typewriter
task_rq(task)
\family default
 vraća pokazivač na red za čekanje u kome dati zadatak čeka.
 Pre nego što se počne sa radom sa redom za čekanje, on mora biti zaključan.
 Pošto je svaki red za čekanje jedinstven za određeni procesor, retko se
 dešava da procesor želi da zaključa redove za čekanje različitih procesora.
 Zaključavanje reda za čekanje zabranjuje bilo kakvu promenu u njemu sve
 dok se čitaju ili upisuju članovi datog reda.
 Najprostiji scenario zaključavanja reda za čekanje je kada želimo da zaključamo
 red na kome određeni zadatak radi.
 U tom slučaju koriste se funkcije 
\family typewriter
task_rq_lock()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!task_rq_lock()
\end_layout

\end_inset

 i 
\family typewriter
task_rq_unlock()
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!task_rq_unlock()
\end_layout

\end_inset


\family default
: 
\end_layout

\begin_layout LyX-Code

\size small
struct runqueue *rq; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long flags;
\end_layout

\begin_layout LyX-Code

\size small
rq = task_rq_lock(task, &flags); 
\end_layout

\begin_layout LyX-Code

\size small
/* manipulate the task's runqueue, rq */ 
\end_layout

\begin_layout LyX-Code

\size small
task_rq_unlock(rq, &flags);
\end_layout

\begin_layout Standard
Alternativno, metod 
\family typewriter
\size small
this_rq_lock()
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!this_rq_lock()
\end_layout

\end_inset


\family default
\size default
 zaključava tekući red za čekanje, a metod 
\family typewriter
\size small

\begin_inset Newline linebreak
\end_inset

rq_unlock()
\family default
\size default
 ga otključava:
\end_layout

\begin_layout Standard

\family typewriter
\size small
struct runqueue *rq;
\end_layout

\begin_layout Standard

\family typewriter
\size small
rq = this_rq_lock(); 
\end_layout

\begin_layout Standard

\family typewriter
\size small
/* manipulate this process's current runqueue, rq */ 
\end_layout

\begin_layout Standard

\family typewriter
\size small
rq_unlock(rq); 
\end_layout

\begin_layout Standard
Da bi se izbegao potpuni zastoj
\begin_inset Index idx
status open

\begin_layout Plain Layout
potpuni zastoj
\end_layout

\end_inset

 (deadlock), kôd koji želi da zaključa više redova za čekanje treba to uvek
 da čini po istom redosledu, tj.
 po rastućem nizu adresa redova za čekanje.
 Na primer: 
\end_layout

\begin_layout LyX-Code

\size small
/* to lock ...
 */ 
\end_layout

\begin_layout LyX-Code

\size small
if (rq1 == rq2) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
spinlock(&rq1->lock); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
if (rq1 < rq2) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
spin_lock(&rq1->lock); 
\end_layout

\begin_layout LyX-Code

\size small
spin_lock(&rq2->lock); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} else { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
spin_lock(&rq2->lock); 
\end_layout

\begin_layout LyX-Code

\size small
spin_lock(&rq1->lock); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
/* manipulate both runqueues ...
 */
\end_layout

\begin_layout LyX-Code

\size small
/* to unlock ...
 */ 
\end_layout

\begin_layout LyX-Code

\size small
spin_unlock(&rq1->lock); 
\end_layout

\begin_layout LyX-Code

\size small
if (rq1 != rq2) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
spin_unlock(&rq2->lock); 
\end_layout

\end_deeper
\begin_layout Standard
Ovi koraci se izvode automatski preko funkcija 
\family typewriter
\size small
double_rq_lock() 
\family default
\size default
i 
\family typewriter
\size small
double_rq_unlock()
\family default
\size default
.
 Prethodni koraci postaju:
\end_layout

\begin_layout LyX-Code

\size small
double_rq_lock(rq1, rq2);
\end_layout

\begin_layout LyX-Code

\size small
/* manipulate both runqueues ...
 */
\end_layout

\begin_layout LyX-Code

\size small
double_rq_unlock(rq1, rq2);
\size default
 
\end_layout

\begin_layout Subsection
Nizovi procesa sa prioritetima
\end_layout

\begin_layout Standard
Svaki red za čekanje sadrži dva niza procesa raspoređenih po prioritetu
\begin_inset Index idx
status open

\begin_layout Plain Layout
procesi!nizovi sa prioritetima
\end_layout

\end_inset

: aktivni niz i niz sa procesima čiji je kvantum istekao.
 Nizovi su definisani u datoteci
\begin_inset Newline linebreak
\end_inset

 
\family typewriter
\size small
kernel/sched.c
\family default
\size default
 kao 
\family typewriter
\size small
struct prio_array
\family default
\size default
.
 Ovi nizovi su strukture podataka složenosti algoritma raspoređivanja O(1).
 
\end_layout

\begin_layout LyX-Code

\size small
struct prio_array { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int nr_active; /* number of tasks in the queues */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long bitmap[BITMAP_SIZE]; /* priority bitmap */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head queue[MAX_PRIO]; /* priority queues */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout Standard

\family typewriter
MAX_PRIO
\family default
 je broj nivoa prioriteta u sistemu (standardna vrednost je 140).
 Za svaki prioritet postoji po jedna struktura 
\family typewriter
struct list_head
\family default
.
 
\family typewriter
BITMAP_SIZE
\family default
 je broj članova niza tipa 
\family typewriter
unsigned long
\family default
 koji definišu bitmapu prioriteta sa po jednim bitom za svaki važeći nivo
 prioriteta.
 Pošto ima 140 prioriteta, a reči su 32-bitne, sledi da niz 
\family typewriter
bitmap
\family default
 ima 5 elemenata (ukupno 160 bitova).
 Svaki niz procesa sa prioritetima takođe sadrži niz redova nazvan 
\family typewriter
queue
\family default
 definisanih strukturom 
\family typewriter
struct list_head
\family default
 (po jedan red za svaki prioritet).
 Unutar datog prioriteta, zadaci se raspoređuju po kružnom (round robin)
 algoritmu.
 Broj zadataka koji se mogu izvršiti u nizu procesa sa prioritetom je definisan
 celobrojnom promenljivom 
\family typewriter
nr_active
\family default
.
 
\end_layout

\begin_layout Subsection
Ponovno izračunavanje vremenskih kvantuma
\end_layout

\begin_layout Standard
Raspoređivač u Linuxu od verzije kernela 2.6 održava dva niza procesa sa
 prioritetima za svaki procesor: niz aktivnih procesa i niz procesa sa isteklim
 vremenskim kvantumom.
 Ponovno izračunavanje vremenskih kvantuma svodi se na preusmeravanje dva
 pokazivača na ove nizove, kao što je definisano u funkciji 
\family typewriter
schedule()
\family default
:
\end_layout

\begin_layout LyX-Code

\size small
struct prio_array *array = rq->active; 
\end_layout

\begin_layout LyX-Code

\size small
if (!array->nr_active) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
rq->active = rq->expired; 
\end_layout

\begin_layout LyX-Code

\size small
rq->expired = array; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Subsection
Funkcija schedule()
\end_layout

\begin_layout Standard
Ovu funkciju
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!schedule()
\end_layout

\end_inset

 eksplicitno poziva kôd kernela da bi odredio sledeći zadatak za izvršavanje,
 i ona se izvršava nezavisno za svaki procesor.
 Sledeći kôd određuje zadatak sa najvećim prioritetom:
\end_layout

\begin_layout LyX-Code

\size small
struct task_struct *prev, *next; 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head *queue; 
\end_layout

\begin_layout LyX-Code

\size small
struct prio_array *array; 
\end_layout

\begin_layout LyX-Code

\size small
int idx;
\end_layout

\begin_layout LyX-Code

\size small
prev = current; 
\end_layout

\begin_layout LyX-Code

\size small
array = rq->active; 
\end_layout

\begin_layout LyX-Code

\size small
idx = sched_find_first_bit(array->bitmap); 
\end_layout

\begin_layout LyX-Code

\size small
queue = array->queue + idx; 
\end_layout

\begin_layout LyX-Code

\size small
next = list_entry(queue->next, struct task_struct, run_list); 
\end_layout

\begin_layout Standard
Prvo se pretražuje niz sa aktivnim procesima sa prioritetom, da bi se pronašao
 prvi postavljen bit koji odgovara zadatku sa najvećim prioritetom koji
 se može izvršiti.
 Raspoređivač zatim bira prvi zadatak sa liste sa tim prioritetom (Slika
 10.5).
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko8.png
	scale 65

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 10.5: Linuxov algoritam raspoređivanja.
\end_layout

\begin_layout Standard
Postupak je veoma jednostavan i brz.
 Broj procesa u sistemu ne utiče na vreme izvršenja ovog kôda, koje je konstantn
o.
\end_layout

\begin_layout Subsection
Određivanje prioriteta i vremenskog kvantuma
\end_layout

\begin_layout Standard
Procesi imaju početni prioritet koji se zove 
\family typewriter
nice
\begin_inset Index idx
status open

\begin_layout Plain Layout
nice vrednost
\end_layout

\end_inset


\family default
 vrednost.
 Opseg vrednosti prioriteta je od -20 (najveći) do +19 (najmanji) sa podrazumeva
nom (default) vrednošću 0.
 Ova vrednost se čuva u članu 
\family typewriter
static_prio
\family default
 strukture procesora 
\family typewriter
task_struct
\family default
 i zove se statički prioritet.
 Dinamički prioritet 
\family typewriter
prio
\family default
 izračunava se kao funkcija statičkog prioriteta i interaktivnosti zadatka,
 a dobija se kao rezultat metoda 
\family typewriter
effective_prio()
\family default
.
 Metod počinje sa 
\family typewriter
nice
\family default
 vrednošću zadatka i dodaje ili oduzima prioritet u opsegu od -5 do +5 u
 zavisnosti od interaktivnosti zadatka.
 Raspoređivač na osnovu heuristike određuje interaktivnost procesa.
 Ako zadatak provodi najviše vremena stanju 
\begin_inset Quotes eld
\end_inset

spavanja
\begin_inset Quotes erd
\end_inset

, onda je on U/I ograničen, a ako troši više vremena na izvršavanje, onda
 sigurno nije interaktivan.
 Da bi primenio ovu heuristiku, Linux vodi računa o trajanju "spavanja"
 procesa i smešta to trajanje u član 
\family typewriter
sleep_avg
\family default
 strukture 
\family typewriter
task_struct
\family default
.
 Opseg vrednosti trajanja je od 0 do 
\family typewriter
MAX_SLEEP_AVG
\family default
, čija je podrazumevana vrednost 10 milisekundi.
 Član 
\family typewriter
sleep_avg
\family default
 se inkrementira dok zadatak 
\begin_inset Quotes eld
\end_inset

spava
\begin_inset Quotes erd
\end_inset

, sve dok se ne dostigne vrednost 
\family typewriter
MAX_SLEEP_AVG
\family default
.
 Sa svakim pokretanjem zadatka, 
\family typewriter
sleep_avg
\family default
 se smanjuje dok ne dostigne vrednost nula.
 Zadatak koji provodi dosta vremena spavajući, ali i kontinualno trošeći
 svoj vremenski kvantum, neće biti nagrađen velikim dodatkom na vrednost
 prioriteta, jer osim što se nagrađuju interaktivni zadaci, kažnjavaju se
 procesorski ograničeni zadaci.
 Na taj način obezbeđuje se brzi odziv.
 Nov interaktivni proces brzo dobija veliku vrednost za 
\family typewriter
sleep_avg
\family default
.
 Pošto se dodavanje ili oduzimanje vrednosti prioriteta primenjuje na početnu
 
\family typewriter
nice
\family default
 vrednost, korisnik može da utiče na odluke raspoređivanja sistema tako
 što će promeniti 
\family typewriter
nice
\family default
 vrednosti procesa.
 
\end_layout

\begin_layout Standard
Vremenski kvantum je lakše izračunati od 
\family typewriter
nice
\family default
 vrednosti jer se zasniva na statičkom prioritetu.
 Kada se proces prvi put kreira, novi procesi deca i proces roditelj dele
 preostalo vreme kvantuma roditelja.
 Na ovaj način se sprečava da korišćenjem sistemskog poziva 
\family typewriter
fork()
\family default
 procesi deca dobijaju neograničene vremenske kvantume.
 Funkcija 
\family typewriter
task_timeslice()
\family default
 vraća nove kvantume za dati zadatak.
 Maksimalna vrednost kvantuma dodeljuje se zadatku s najvećim prioritetom
 (čija je 
\family typewriter
nice
\family default
 vrednost -20) i iznosi 800 milisekundi.
 Zadatak sa najmanjim prioritetom (čija je 
\family typewriter
nice
\family default
 vrednost +19) dobija minimalnu vrednost kvantuma 
\family typewriter
MIN_TIMESLICE
\family default
 od 5 milisekundi.
 Zadaci sa standardnim prioritetom (čija je 
\family typewriter
nice
\family default
 vrednost 0) dobijaju kvantum od 100 milisekundi.
 
\end_layout

\begin_layout Subsection
Balanser opterećenja
\end_layout

\begin_layout Standard
Kako se definiše globalna politika raspoređivanja u multiprocesorskim sistemima?
 Šta se dešava ako u jednom redu za čekanje jednog procesora ima sedam procesa,
 a u drugom redu za čekanje samo jedan proces? Rešenje je tzv.
 
\series bold
balanser opterećenja
\series default
 (load balancer) koji pokušava da ravnomerno rasporedi procese u redove
 čekanja svih procesora.
 Balanser opterećenja
\begin_inset Index idx
status open

\begin_layout Plain Layout
balanser opterećenja
\end_layout

\end_inset

 je definisan u datoteci 
\family typewriter
kernel/sched.c
\family default
 kao funkcija 
\family typewriter
load_balance()
\family default
koja ima dva dela.
 Kada je tekući red za čekanje prazan, poziva se funkcija 
\family typewriter
schedule()
\family default
.
 Ova funkcija se poziva i preko tajmera, na svaki milisekund kada sistem
 ništa ne radi, u suprotnom na svakih 200 milisekundi.
 U jednoprocesorskim sistemima 
\family typewriter
load_balance()
\family default
 se nikada ne poziva.
 Balanser opterećenja se poziva sa tekućim redom za čekanje procesora koji
 je zaključan i sa onemogućenim prekidima da bi se redovi za čekanje zaštitili
 od konkurentnog pristupa.
 Kada 
\family typewriter
schedule()
\family default
 poziva 
\family typewriter
load_balance()
\family default
, posao funkcije 
\family typewriter
schedule()
\family default
 je lak jer je tekući red za čekanje prazan, pa je nalaženje bilo kog procesa
 koji će se dodati u red za čekanje jednostavno.
 Kada se balanser opterećenja pozove preko tajmera, njegov zadatak je da
 razreši loš balans između redova za čekanje.
\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
load_balance()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Funkcije!load_balance()
\end_layout

\end_inset

 i sa njom povezani metodi su definisani kroz sledeće korake:
\end_layout

\begin_layout Standard
1.
 
\family typewriter
load_balance()
\family default
 poziva 
\family typewriter
find_busiest_queue()
\family default
 da bi se odredio red za čekanje koji ima najveći broj procesa (tj.
 najuposleniji red).
 Ako ne postoji red za čekanje koji ima barem za četvrtinu više procesa
 od tekućeg, funkcija 
\family typewriter
find_busiest_queue()
\family default
 vraća NULL funkciji 
\family typewriter
load_balance()
\family default
.
 Ako postoji, najuposleniji red za čekanje se vraća.
 
\end_layout

\begin_layout Standard
2.
 
\family typewriter
load_balance()
\family default
 odlučuje iz kog niza prioriteta u najuposlenijem redu za čekanje funkcija
 želi da uzme zadatak.
 Niz sa isteklim vremenima je pogodniji zato što se zadaci koji su u njemu
 nisu izvršavali prilično dugo, pa nisu u kešu procesora.
 Ako je red procesa sa isteklim kvantumom prazan, jedini izbor je aktivan
 red.
 Keš memorija procesora je lokalno integrisana (na čipu) i nudi brzi pristup
 preko sistemske memorije.
 Ako se zadatak izvršava u procesoru, a podaci pridruženi zadatku dovedu
 u lokalni keš procesora, oni se posmatraju kao 
\begin_inset Quotes eld
\end_inset

vrući
\begin_inset Quotes erd
\end_inset

 (hot).
 Ako ovi podaci nisu u lokalnom kešu procesora, onda se za ovaj zadatak
 keš posmatra kao 
\begin_inset Quotes eld
\end_inset

hladan
\begin_inset Quotes erd
\end_inset

 (cold).
 
\end_layout

\begin_layout Standard
3.
 
\family typewriter
load_balance()
\family default
 nalazi listu zadataka sa najvećim prioritetom (najmanjom 
\family typewriter
nice
\family default
 vrednošću), zato što je osim zadataka sa visokim prioritetom važno da na
 red za izvršavanje dođu i zadaci sa malim prioritetom (da se ne bi desio
 problem 
\begin_inset Quotes eld
\end_inset

izgladnjivanja
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Standard
4.
 svaki zadatak sa datim prioritetom se analizira da bi se našao zadatak
 koji se ne izvršava, koji je sprečen da se kreće prema unapred određenom
 procesoru i koji nije u kešu.
 Ako zadatak zadovoljava ove kriterijume, poziva se funkcija 
\family typewriter
pull_task()
\family default
 da bi prebacila zadatak iz najuposlenijeg reda u tekući red za čekanje
 
\end_layout

\begin_layout Standard
5.
 Prethodni koraci se ponavljaju sve dok redovi za čekanje ne postanu balansirani.
 Kada se na kraju postignu balansirani redovi, tekući red se otključava,
 a funkcija 
\family typewriter
load_balance()
\family default
 završava.
\end_layout

\begin_layout Standard
U nastavku je prikazan kôd za funkciju 
\family typewriter
load_balance()
\family default
: 
\end_layout

\begin_layout LyX-Code

\size small
static int load_balance(int this_cpu, runqueue_t *this_rq, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct sched_domain *sd, enum idle_type idle) { 
\end_layout

\begin_layout LyX-Code

\size small
struct sched_group *group; 
\end_layout

\begin_layout LyX-Code

\size small
runqueue_t *busiest; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long imbalance; 
\end_layout

\begin_layout LyX-Code

\size small
int nr_moved; 
\end_layout

\begin_layout LyX-Code

\size small
spin_lock(&this_rq->lock);
\end_layout

\begin_layout LyX-Code

\size small
group = find_busiest_group(sd, this_cpu, &imbalance, idle); 
\end_layout

\begin_layout LyX-Code

\size small
if (!group) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
goto out_balanced;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
busiest = find_busiest_queue(group); 
\end_layout

\begin_layout LyX-Code

\size small
if (!busiest) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
goto out_balanced;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
nr_moved = 0; 
\end_layout

\begin_layout LyX-Code

\size small
if (busiest->nr_running > 1) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
double_lock_balance(this_rq, busiest); 
\end_layout

\begin_layout LyX-Code

\size small
nr_moved = move_tasks(this_rq, this_cpu, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
busiest, imbalance, sd, idle); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
spin_unlock(&busiest->lock); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
spin_unlock(&this_rq->lock);
\end_layout

\begin_layout LyX-Code

\size small
if (!nr_moved) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
sd->nr_balance_failed++;
\end_layout

\begin_layout LyX-Code

\size small
if (unlikely(sd->nr_balance_failed > sd->cache_nice_tries+2)) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int wake = 0;
\end_layout

\begin_layout LyX-Code

\size small
spin_lock(&busiest->lock); 
\end_layout

\begin_layout LyX-Code

\size small
if (!busiest->active_balance) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
busiest->active_balance = 1; 
\end_layout

\begin_layout LyX-Code

\size small
busiest->push_cpu = this_cpu; wake = 1; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
spin_unlock(&busiest->lock); 
\end_layout

\begin_layout LyX-Code

\size small
if (wake) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
wake_up_process(busiest->migration_thread); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
sd->nr_balance_failed = sd->cache_nice_tries; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} else sd->nr_balance_failed = 0;
\end_layout

\begin_layout LyX-Code

\size small
sd->balance_interval = sd->min_interval;
\end_layout

\begin_layout LyX-Code

\size small
return nr_moved;
\end_layout

\begin_layout LyX-Code

\size small
out_balanced: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
spin_unlock(&this_rq->lock);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
if (sd->balance_interval < sd->max_interval) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
sd->balance_interval *= 2;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Subsection
Raspoređivanje u realnom vremenu
\end_layout

\begin_layout Standard
Linux obezbeđuje dva načina raspoređivanja
\begin_inset Index idx
status open

\begin_layout Plain Layout
raspoređivanje!u realnom vremenu
\end_layout

\end_inset

 u realnom vremenu, 
\family typewriter
SCHED_FIFO
\family default
 i 
\family typewriter
SCHED_RR
\family default
, a za ostale slučajeve koristi se raspoređivanje 
\family typewriter
SCHED_NORMAL
\family default
.
 Funkcija 
\family typewriter
SCHED_FIFO
\family default
 implementira FIFO algoritam raspoređivanja bez vremenskih kvantuma.
 Zadatak koji se može izvršiti funkcija 
\family typewriter
SCHED_FIFO
\family default
 uvek raspoređuje pre svakog zadatka koji raspoređuje 
\family typewriter
SCHED_NORMAL
\family default
.
 Kada zadatak 
\family typewriter
SCHED_FIFO
\family default
 postane kandidat za izvršenje, on nastavlja da se izvršava dok se ne blokira
 ili mu se eksplicitno dodeli procesor; on nema dodeljen kvantum i može
 da se izvršava beskonačno.
 Samo zadatak većeg prioriteta 
\family typewriter
SCHED_FIFO
\family default
 ili 
\family typewriter
SCHED_RR
\family default
 može da suspenduje izvršavanje zadatka
\family typewriter
 SCHED_FIFO
\family default
.
 Nekoliko 
\family typewriter
SCHED_FIFO
\family default
 zadataka sa istim prioritetom raspoređuju se kružnim (round robin) algoritmom,
 ali ponovo dobijaju procesor tek kada sami eksplicitno to odluče.
 Sve dok se zadatak 
\family typewriter
SCHED_FIFO
\family default
 može izvršavati, svi zadaci sa nižim prioritetom čekaju da se on završi.
\end_layout

\begin_layout Chapter
Sistemski pozivi 
\end_layout

\begin_layout Standard
Kernel obezbeđuje skup interfejsa pomoću kojih proces koji se izvršava u
 korisničkom prostoru može da komunicira sa sistemom.
 Ti interfejsi omogućuju aplikacijama da pristupe hardveru i drugim resursima
 operativnog sistema.
 Linux ima mnogo manje sistemskih poziva u poređenju sa drugim operativnim
 sistemima (oko 250 sistemskih poziva za arhitekturu x86).
 Pri tom, svakoj arhitekturi je dozvoljeno da definiše sopstvene sistemske
 pozive.
 S tačke gledišta programera, sistemski pozivi nisu bitni; programer vidi
 samo interfejs za programiranje (API).
 S druge strane, kernel radi samo sa sistemskim pozivima, tj.
 ne zanima ga kako sistemske pozive koriste bibliotečki pozivi i aplikacije.
 
\end_layout

\begin_layout Standard
Sistemskim pozivima
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski pozivi
\end_layout

\end_inset

 (često zvanim syscalls u Linuxu) obično se pristupa preko funkcijskih poziva.
 Pozivi mogu da imaju jedan ili više argumenata (ulaza) i da kao rezultat
 daju nekoliko sporednih efekata (npr.
 upis u datoteku ili kopiranje podataka).
 Povratna vrednost sistemskih poziva je tipa 
\family typewriter
long
\family default
 i može da predstavlja uspešan završetak ili grešku.
 Negativna vrednost obično označava grešku, a nula uspešan završetak.
 Na primer, sistemski poziv 
\family typewriter
getpid()
\family default
 vraća ceo broj koji predstavlja PID tekućeg procesa.
 Implementacija ovog sistemskog poziva u kernelu je veoma jednostavna:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
asmlinkage long sys_getpid(void) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
return current->tgid; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size small
}
\end_layout

\begin_layout Standard
Obratite pažnju na modifikator 
\family typewriter
asmlinkage
\family default
 u definiciji funkcije.
 To je bit koji kaže kompajleru da argumente funkcije traži isključivo na
 steku i to je zahtevani modifikator za sve sistemske pozive.
 Sistemski poziv 
\family typewriter
getpid()
\family default
 je definisan u kernelu kao 
\family typewriter
sys_getpid()
\family default
.
 
\end_layout

\begin_layout Section
Brojevi sistemskih poziva
\end_layout

\begin_layout Standard
Svakom sistemskom pozivu
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski pozivi!brojevi u Linuxu
\end_layout

\end_inset

 u Linuxu se pridružuje jedinstven broj 
\family typewriter
syscall
\family default
.
 Procesi ne referenciraju sistemski poziv po imenu, već po broju koji se
 ne može menjati.
 Kernel održava listu svih registrovanih sistemskih poziva u tabeli sistemskih
 poziva, koja se nalazi u datoteci 
\family typewriter
sys_call_table
\family default
.
 Tabela sistemskih poziva je zavisna od arhitekture i obično definisana
 u datoteci 
\family typewriter
entry.S
\family default
, koja se za arhitekturu x86 nalazi u direktorijumu 
\family typewriter
arch/i386/kernel/
\family default
.
 
\end_layout

\begin_layout Section
Upravljač sistemskih poziva
\end_layout

\begin_layout Standard
Mehanizam koji signalizira kernelu da aplikacije korisničkog prostora žele
 da izvrše sistemski poziv
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski pozivi!upravljač
\end_layout

\end_inset

 je softverski prekid (interrupt).
 Nakon prekida, ulazi se u sistemski režim i poziva se upravljač sistemskih
 poziva (system call handler).
 Softverski prekid za arhitekturu x86 je instrukcija int $0x80; njenim izvršavan
jem prelazi se u sistemski režim i izvršava se vektor izuzetka (exception
 vector 128), tj.
 upravljač sistemskih poziva.
 Funkcija 
\family typewriter
system_call()
\family default
 zavisi od arhitekture i obično je implementirana u asembleru u datoteci
 
\family typewriter
entry.S
\family default
.
 Bez obzira kako se poziva upravljač sistemskih poziva, korisnički režim
 generiše izuzetak (trap) da bi se ušlo u sistemski režim (Slika 11.1).
 
\end_layout

\begin_layout Subsection
Označavanje odgovarajućeg sistemskog poziva
\end_layout

\begin_layout Standard
Kernelu mora da se prosledi broj sistemskog poziva
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski pozivi!označavanje
\end_layout

\end_inset

.
 U arhitekturi x86, broj sistemskog poziva se prosleđuje preko registra
 
\family typewriter
eax
\family default
.
 Upravljač sistemskih poziva čita vrednost iz registra eax.
 Funkcija 
\family typewriter
system_call()
\family default
 proverava ispravnost broja sistemskog poziva upoređujući ga sa vrednošću
 
\family typewriter
NR_syscalls
\family default
.
 Ako je broj sistemskog poziva veći ili jednak vrednosti 
\family typewriter
NR_syscalls
\family default
, funkcija vraća 
\family typewriter
ENOSYS
\family default
.
 Poziv se izvodi sledećom naredbom:
\end_layout

\begin_layout Standard

\family typewriter
call *sys_call_table(,%eax,4)
\end_layout

\begin_layout Standard
Pošto je svaki element u tabeli sistemskih poziva 32-bitni (4 bajta), kernel
 množi broj sistemskog poziva sa četiri da bi izračunao lokaciju poziva
 u tabeli sistemskih poziva.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko10.png
	scale 65

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 11.1: Poziv upravljača sistemskih poziva i izvršenje sistemskog poziva.
\end_layout

\begin_layout Subsection
Implementacija sistemskih poziva
\end_layout

\begin_layout Standard
Dodavanje novih sistemskih poziva
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski pozivi!implementacija
\end_layout

\end_inset

 Linuxu je relativno lako, ali se ne preporučuje.
 Posao projektovanja i primene sistemskog poziva je veoma težak, dok je
 sama registracija u kernelu veoma jednostavna.
 Prvi korak u implementaciji sistemskog poziva je definisanje njegove namene;
 sistemski poziv može da se koristi samo za jednu funkciju.
 Sistemski poziv treba da ima jasan i jednostavan interfejs sa što manjim
 brojem argumenata.
 Semantika i ponašanje sistemskog poziva su važni i ne smeju se menjati
 zato što će za njih biti programirane aplikacije.
 Sistemski poziv treba da bude projektovan tako da bude opšti, robustan,
 prenosiv i nezavisan od arhitekture.
 
\end_layout

\begin_layout Subsection
Provera parametara sistemskog poziva
\end_layout

\begin_layout Standard
Sistemski pozivi
\begin_inset Index idx
status open

\begin_layout Plain Layout
sistemski pozivi!provera parametara
\end_layout

\end_inset

 moraju pažljivo da provere sve svoje parametre zbog bezbednosti i stabilnosti
 kernela.
 Jedna od najvažnijih provera je ispravnost pokazivača koji stižu od korisnika.
 Kernel nudi dva metoda za proveravanje parametara i kopiranje u korisnički
 prostor.
 Za upis u korisnički prostor koristi se metod 
\family typewriter
copy_to_user()
\family default
 koji ima tri argumenta.
 Prvi je odredišna memorijska adresa u adresnom prostoru procesa.
 Drugi je izvorni pokazivač u prostoru kernela.
 Treći argument je veličina podataka koji se kopiraju u bajtovima.
 Za čitanje iz korisničkog prostora koristi se method 
\family typewriter
copy_from_user()
\family default
.
 Funkcija iz drugog parametra u prvi parametar učitava broj bajtova određen
 trećim parametrom.
 Obe funkcije u slučaju greške vraćaju broj bajtova koje ne mogu da kopiraju,
 a u slučaju uspeha vraćaju nulu.
 Kao primer proučićemo sistemski poziv 
\family typewriter
silly_copy()
\family default
 koji koristi oba metoda.
 
\end_layout

\begin_layout LyX-Code

\size small
/* * silly_copy - utterly worthless syscall 
\end_layout

\begin_layout LyX-Code

\size small
* that copies the len bytes from * 'src' to 'dst' 
\end_layout

\begin_layout LyX-Code

\size small
* using the kernel as an intermediary in the copy 
\end_layout

\begin_layout LyX-Code

\size small
* for no good reason.
 But it makes for a good example! */ 
\end_layout

\begin_layout LyX-Code

\size small
asmlinkage long sys_silly_copy(unsigned long *src, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
unsigned long *dst, unsigned long len) { 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long buf;
\end_layout

\begin_layout LyX-Code

\size small
/* fail if the kernel wordsize and user wordsize do not match */ 
\end_layout

\begin_layout LyX-Code

\size small
if (len != sizeof(buf)) return -EINVAL;
\end_layout

\begin_layout LyX-Code

\size small
/* copy src, which is in the user's address space, into buf */ 
\end_layout

\begin_layout LyX-Code

\size small
if (copy_from_user(&buf, src, len)) return -EFAULT;
\end_layout

\begin_layout LyX-Code

\size small
/* copy buf into dst, which is in the user's address space */ 
\end_layout

\begin_layout LyX-Code

\size small
if (copy_to_user(dst, &buf, len)) return -EFAULT;
\end_layout

\begin_layout LyX-Code

\size small
/* return amount of data copied */ 
\end_layout

\begin_layout LyX-Code

\size small
return len; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
Veoma je važna provera dozvola (ovlašćenja).
 Sistem proverava pristupe određenim resursima.
 Poziv 
\family typewriter
\size small
capable()
\family default
\size default
 sa važećim flegovima vraća broj različit od nule ako su korisniku dodeljena
 ovlašćenja, odnosno nulu ako nisu.
 Na primer, 
\family typewriter
capable(CAP_SYS_NICE)
\family default
 proverava da li korisnik koji poziva funkciju ima dozvolu da promeni 
\family typewriter
nice
\family default
 vrednost drugih procesa.
 Superkorisnik (superuser) standardno ima sve dozvole, a običan (non-root)
 korisnik ih nema.
 Evo još jednog primera kao ilustracije korišćenja dozvola:
\end_layout

\begin_layout LyX-Code

\size small
asmlinkage long sys_am_i_popular (void) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
/* check whether the user possesses the CAP_SYS_NICE capability */ 
\end_layout

\begin_layout LyX-Code

\size small
if (!capable(CAP_SYS_NICE)) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return EPERM;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
/* return zero for success */ 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
Sledi deo kôda iz zaglavlja  
\family typewriter
<linux/capability.h>
\family default
 za listu svih mogućnosti i odgovarajućih prava.
\end_layout

\begin_layout LyX-Code

\size small
166 /**
\end_layout

\begin_layout LyX-Code

\size small
167 ** Linux-specific capabilities 
\end_layout

\begin_layout LyX-Code

\size small
168 **/ 
\end_layout

\begin_layout LyX-Code

\size small
169 
\end_layout

\begin_layout LyX-Code

\size small
170 /* Without VFS support for capabilities: 
\end_layout

\begin_layout LyX-Code

\size small
171 * Transfer any capability in your permitted set to any pid, 
\end_layout

\begin_layout LyX-Code

\size small
172 * remove any capability in your permitted set from any pid 
\end_layout

\begin_layout LyX-Code

\size small
173 * With VFS support for capabilities (neither of above, but) 
\end_layout

\begin_layout LyX-Code

\size small
174 * Add any capability from current's capability bounding set 
\end_layout

\begin_layout LyX-Code

\size small
175 * to the current process' inheritable set 
\end_layout

\begin_layout LyX-Code

\size small
176 * Allow taking bits out of capability bounding set 
\end_layout

\begin_layout LyX-Code

\size small
177 * Allow modification of the securebits for a process 
\end_layout

\begin_layout LyX-Code

\size small
178 */ 
\end_layout

\begin_layout LyX-Code

\size small
179 
\end_layout

\begin_layout LyX-Code

\size small
180 #define CAP_SETPCAP 8 
\end_layout

\begin_layout LyX-Code

\size small
181 
\end_layout

\begin_layout LyX-Code

\size small
182 /* Allow modification of S_IMMUTABLE and S_APPEND file attributes */
 
\end_layout

\begin_layout LyX-Code

\size small
183 
\end_layout

\begin_layout LyX-Code

\size small
184 #define CAP_LINUX_IMMUTABLE 9 
\end_layout

\begin_layout LyX-Code

\size small
185 
\end_layout

\begin_layout LyX-Code

\size small
186 /* Allows binding to TCP/UDP sockets below 1024 */ 
\end_layout

\begin_layout LyX-Code

\size small
187 /* Allows binding to ATM VCIs below 32 */ 
\end_layout

\begin_layout LyX-Code

\size small
188 
\end_layout

\begin_layout LyX-Code

\size small
189 #define CAP_NET_BIND_SERVICE 10 
\end_layout

\begin_layout Subsection
Završni korak u povezivanju novog sistemskog poziva sa postojećim kôdom
\end_layout

\begin_layout Standard
Pošto je sistemski poziv napisan, on se veoma lako zvanično registruje:
 
\end_layout

\begin_layout Itemize
Prvo, treba dodati jedan upis na kraj tabele sistemskih poziva.
 To treba da se uradi za svaku arhitekturu koja podržava sistemski poziv.
 Pozicija u tabeli poziva počinje od nule.
 
\end_layout

\begin_layout Itemize
Za svaku podržanu arhitekturu broj sistemskog poziva treba da se definiše
 u zaglavlju 
\family typewriter
<asm/unistd.h>
\family default
.
 
\end_layout

\begin_layout Itemize
Sistemski poziv treba da bude kompajliran u sliku kernela (za razliku od
 kompajliranja modula).
 Sistemski poziv treba smestiti u odgovarajuću datoteku u poddirektorijumu
 
\family typewriter
kernel/
\family default
, kao što je 
\family typewriter
sys.c
\family default
.
 
\end_layout

\begin_layout Standard
Sada ove korake da možemo da izvršimo za izmišljeni poziv 
\family typewriter
foo()
\family default
.
 Prvo, treba dodati 
\family typewriter
sys_foo()
\family default
 u tabelu sistemskih poziva.
 Za većinu arhitektura tabela se nalazi u datoteci 
\family typewriter
entry.S
\family default
 i izgleda ovako: 
\end_layout

\begin_layout LyX-Code

\size small
ENTRY(sys_call_table) 
\end_layout

\begin_layout LyX-Code

\size small
.long sys_restart_syscall /* 0 */ 
\end_layout

\begin_layout LyX-Code

\size small
.long sys_exit 
\end_layout

\begin_layout LyX-Code

\size small
.long sys_fork 
\end_layout

\begin_layout LyX-Code

\size small
.long sys_read 
\end_layout

\begin_layout LyX-Code

\size small
.long sys_write 
\end_layout

\begin_layout LyX-Code

\size small
.long sys_open /* 5 */
\end_layout

\begin_layout LyX-Code

\size small
...
\end_layout

\begin_layout LyX-Code

\size small
.long sys_mq_unlink 
\end_layout

\begin_layout LyX-Code

\size small
.long sys_mq_timedsend 
\end_layout

\begin_layout LyX-Code

\size small
.long sys_mq_timedreceive /* 280 */ 
\end_layout

\begin_layout LyX-Code

\size small
.long sys_mq_notify 
\end_layout

\begin_layout LyX-Code

\size small
.long sys_mq_getsetattr 
\end_layout

\begin_layout Standard
Nov sistemski poziv se dodaje na kraj ove liste: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
.long sys_foo /* 283 */
\end_layout

\begin_layout Standard
Broj sistemskog poziva se razlikuje za različite arhitekture.
 Zatim se broj sistemskog poziva dodaje u zaglavlje 
\family typewriter
\size small
<asm/unistd.h>
\family default
\size default
: 
\end_layout

\begin_layout LyX-Code

\size small
/* * This file contains the system call numbers.
 */
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_restart_syscall 0 
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_exit 1 
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_fork 2 
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_read 3 
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_write 4 
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_open 5 ...
 
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_mq_unlink 278 
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_mq_timedsend 279 
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_mq_timedreceive 280 
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_mq_notify 281 
\end_layout

\begin_layout LyX-Code

\size small
#define __NR_mq_getsetattr 282 
\end_layout

\begin_layout Standard
sa poslednjim redom koji smo dodali:
\end_layout

\begin_layout Standard

\family typewriter
\size small
#define __NR_foo 283
\end_layout

\begin_layout Standard
Na kraju se dodaje implementacija sistemskog poziva foo().
 Sistemski poziv mora da bude kompajliran u slici kernela u svim konfiguracijama
; kôd se dodaje u kernel/sys.c.
 
\end_layout

\begin_layout LyX-Code

\size small
#include <asm/thread_info.h>
\end_layout

\begin_layout LyX-Code

\size small
/* * sys_foo everyone's favorite system call.
 
\end_layout

\begin_layout LyX-Code

\size small
* 
\end_layout

\begin_layout LyX-Code

\size small
* Returns the size of the per-process kernel stack.
 */ 
\end_layout

\begin_layout LyX-Code

\size small
asmlinkage long sys_foo(void) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return THREAD_SIZE; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
Kernel treba da se podigne i nakon toga korisnik može da upotrebi sistemski
 poziv 
\family typewriter
foo()
\family default
.
\end_layout

\begin_layout Section
Pristup sistemskom pozivu iz korisničkog prostora
\end_layout

\begin_layout Standard
C biblioteka obezbeđuje podršku za sistemske pozive.
 Korisničke aplikacije mogu da pročitaju prototipove funkcija iz standardnih
 zaglavlja i povežu se sa C bibliotekom da bi koristile nove sistemske pozive
 (ili bibliotečke rutine koje koriste sistemske pozive).
 Ako se sistemski poziv samo napiše, nije sigurno da ga 
\family typewriter
glibc
\family default
 podržava.
 Paket 
\family typewriter
glibc
\family default
 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
glibc
\end_layout

\end_inset


\family default
sadrži standardne biblioteke koje koriste različiti programi u sistemu,
 na primer standardnu C biblioteku i matematičku biblioteku, bez kojih Linux
 sistem ne funkcioniše.
 Ovaj paket sadrži i lokalnu podršku za različite nacionalne jezike.
 Srećom, Linux obezbeđuje skup makroa za pristup sistemskim pozivima bez
 eksplicitne bibliotečke podrške.
 
\end_layout

\begin_layout Chapter
Prekidi i upravljači prekida 
\end_layout

\begin_layout Standard
Prekid
\begin_inset Index idx
status open

\begin_layout Plain Layout
prekid
\end_layout

\end_inset

i (interrupts) omogućuju hardveru da komunicira sa procesorom.
 Prekid proizvodi električni signal koji generiše hardverski uređaj, a usmeren
 je ka ulaznim pinovima kontrolera prekida, koji sa svoje strane šalje signal
 procesoru.
 Procesor registruje signal i prekida sa tekućim poslom da bi upravljao
 prekidom.
 Procesor može da obavesti operativni sistem da je došlo do prekida da bi
 ga operativni sistem obradio na odgovarajući način.
 Različitim uređajima se pridružuju jedinstvene celobrojne vrednosti za
 svaki prekid.
 Te vrednosti se često zovu
\begin_inset Index idx
status open

\begin_layout Plain Layout
prekid!linije zahteva (IRQ)
\end_layout

\end_inset

 
\shape italic
linije zahteva za prekidom
\shape default
 (interrupt request, IRQ).
 Kada se govori o prekidima, važno je razlikovati prekide i izuzetke (exceptions
).
 Za razliku od prekida, izuzeci se pojavljuju sinhrono sa procesorskim taktom,
 pa se zato zovu i sinhroni prekidi.
 Izuzetke proizvodi procesor dok izvršava instrukcije, i to kao odziv na
 grešku u programiranju (npr.
 deljenje nulom) ili kao reakciju na neuobičajene uslove koje mora da razreši
 kernel (npr.
 pogrešne strane u algoritmu straničenja, page fault).
 
\end_layout

\begin_layout Section
Upravljači prekida 
\end_layout

\begin_layout Standard
Upravljač prekida
\begin_inset Index idx
status open

\begin_layout Plain Layout
upravljač prekida
\end_layout

\end_inset

 (interrupt handler) je specijalna servisna rutina za obradu prekida (interrupt
 service routine, ISR).
 Svakom uređaju koji generiše prekide pridružen je jedan upravljač prekida,
 koji je deo upravljačkog programa (driver), tj.
 kernel koda koji upravlja radom uređaja.
 U Linuxu su upravljači prekida obične C funkcije.
 Upravljač prekida treba da se izvršava brzo i da uradi složen posao; ta
 dva cilja su međusobno suprotstavljena.
 Zato je obrada prekida podeljena u dva dela.
 Upravljač prekida je prvi deo; on se poziva odmah nakon prijema prekida
 i izvršava samo vremenski kritične poslove, kao što su potvrda prijema
 prekida ili resetovanje hardvera.
 Posao koji se može izvršiti kasnije se odlaže za drugi deo.
 
\end_layout

\begin_layout Standard
Proučimo primer mrežne kartice.
 Kada mrežna kartica primi dolazne pakete sa mreže, ona treba da obavesti
 kernel veoma brzo, da optimizuje propusnost i kašnjenje i izbegne isticanje
 rokova.
 Zbog toga ona veoma brzo generiše prekid.
 Kernel odgovara izvršavajući registrovani prekid mrežne kartice.
 Prekid se izvršava uz potvrdu hardvera, kopiraju se novi mrežni paketi
 u glavnu memoriju, a mrežna kartica se priprema za još paketa.
 Ovi poslovi su važni, vremenski kritični i obavljaju se hardverski.
 Ostatak obrade i upravljanja paketima izvršava se kasnije, u tzv.
 donjoj polovini.
 
\end_layout

\begin_layout Subsection
Registracija upravljača prekida
\end_layout

\begin_layout Standard
Upravljački program uređaja (drajver) je odgovoran za upravljač prekida
 i registruje jedan prekid.
 Upravljački programi uređaja registruju upravljač prekida i uključuju liniju
 prekida za upravljanje preko sledeće funkcije: 
\end_layout

\begin_layout LyX-Code

\size small
/* request_irq: allocate a given interrupt line */ 
\end_layout

\begin_layout LyX-Code

\size small
int request_irq(unsigned int irq, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
 irqreturn_t (*handler)(int, void *, struct pt_regs *), 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
unsigned long irqflags, const char *devname, void *dev_id) 
\end_layout

\begin_layout Standard
Prvi parametar, 
\family typewriter
irq
\family default
, određuje broj prekida.
 Parametar 
\family typewriter
handler
\family default
 je funkcijski pokazivač na aktuelni upravljač prekida koji obrađuje ovaj
 prekid.
 Ova funkcija se poziva kad god operativni sistem primi prekid.
 Treći parametar, 
\family typewriter
irqflags
\family default
, može biti ili nula ili bit maske jednog ili više flegova: 
\end_layout

\begin_layout Standard
•	
\family typewriter
SA_INTERRUPT
\family default
 određuje da je dati upravljač prekida brz.
 
\end_layout

\begin_layout Standard
•	
\family typewriter
SA_SAMPLE_RANDOM
\family default
 određuje da li prekid koji generiše uređaj deterministički ili ne.
 
\end_layout

\begin_layout Standard
•	
\family typewriter
SA_SHIRQ
\family default
 određuje da linija prekida može biti deljena između više upravljača prekida.
 
\end_layout

\begin_layout Standard
Četvrti parametar 
\family typewriter
devname
\family default
 je ASCII tekstualna prezentacija uređaja sa datim prekidom.
  Peti parametar 
\family typewriter
dev_id
\family default
 koristi se prvenstveno za deljene linije prekida.
 Bez ovog parametra bilo bi nemoguće da kernel zna koji upravljač da ukloni
 sa određene linije prekida.
  
\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
request_irq()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!request_irq()
\end_layout

\end_inset

 vraća nulu ako se uspešno izvrši, a vrednost različitu od nule ako postoji
 greška.
 U upravljačkom programu, zahtevanje prekidne linije i instaliranje upravljača
 obavlja funkcija 
\family typewriter
request_irq()
\family default
 na sledeći način: 
\end_layout

\begin_layout LyX-Code

\size small
if (request_irq(irqn, my_interrupt, SA_SHIRQ, "my_device", dev)) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
printk(KERN_ERR "my_device: cannot register IRQ %d
\backslash
n", irqn); 
\end_layout

\begin_layout LyX-Code

\size small
return -EIO; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
U ovom primeru 
\family typewriter
\size small
irqn
\family default
\size default
 je zahtevana linija prekida, 
\family typewriter
\size small
my_interrupt
\family default
\size default
 je upravljač, linija može biti deljena, ime uređaja je 
\family typewriter
\size small
"my_device"
\family default
\size default
 i prosleđuje se 
\family typewriter
\size small
dev
\family default
\size default
 za 
\family typewriter
\size small
dev_id
\family default
\size default
.
\end_layout

\begin_layout Standard
Kada se drajver oslobodi, treba da se oslobodi registracija upravljača prekida
 i potencijalno onemogući linija prekida.
 To se radi pozivom:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void free_irq
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!free_irq()
\end_layout

\end_inset

(unsigned int irq, void *dev_id)
\end_layout

\begin_layout Standard
koji se izvodi iz konteksta procesa.
 
\end_layout

\begin_layout Subsection
Pisanje kôda upravljača prekida
\end_layout

\begin_layout Standard
Tipična deklaracija upravljača prekida je:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
static irqreturn_t intr_handler(int irq, void *dev_id, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
struct pt_regs *regs)
\end_layout

\end_deeper
\begin_layout Standard
Treba obratiti pažnju da ova deklaracija odgovara prototipu argumenta 
\family typewriter
handler
\family default
 funkcije 
\family typewriter
request_irq()
\family default
.
 Prvi parametar 
\family typewriter
irq
\family default
 je numerička vrednost linije prekida upravljača.
 Drugi parametar 
\family typewriter
dev_id
\family default
 je generički pokazivač na isti 
\family typewriter
dev_id
\family default
 u funkciji 
\family typewriter

\begin_inset Newline linebreak
\end_inset

request_irq()
\family default
 kada je upravljač prekida bio registrovan.
 Ako je ova vrednost jedinstvena (što se preporučuje zbog podrške deljenju),
 može da se koristi da bi se razlikovali uređaji koji potencijalno mogu
 da koriste isti upravljač prekida.
 Poslednji parametar 
\family typewriter
regs
\family default
 sadrži pokazivač na strukturu koja sadrži stanje procesorskih registara
 pre usluživanja prekida.
 Funkcija vraća vrednost tipa 
\family typewriter
irqreturn_t
\family default
.
 Upravljač prekida je označen kao 
\family typewriter
static
\family default
 zato što se nikad ne poziva direktno iz druge datoteke.
 
\end_layout

\begin_layout Subsection
Primer upravljača prekida
\end_layout

\begin_layout Standard
Posmatrajmo realan upravljač prekida sata RTC (real-time clock) koji se
 može naći u datoteci 
\family typewriter
drivers/char/rtc.c
\family default
.
 Sistemski sat (RTC) se nalazi u mnogim mašinama, uključujući PC.
 To je uređaj odvojen od sistemskog tajmera, a koristi se za postavljanje
 sistemskog sata, alarma itd.
 U većini arhitektura sistemski sat se postava upisivanjem odgovarajućeg
 vremena u određeni registar.
 Svaki alarm ili periodični tajmer implementira se preko prekida.
 Kada se učita upravljački program za RTC, poziva se funkcija 
\family typewriter
rtc_init()
\family default
 da ga inicijalizuje.
 Jedan od zadataka funkcije 
\family typewriter
rtc_init()
\family default
 je i registracija upravljača prekida: 
\end_layout

\begin_layout LyX-Code

\size small
/* register rtc_interrupt on RTC_IRQ */ 
\end_layout

\begin_layout LyX-Code

\size small
if (request_irq(RTC_IRQ, rtc_interrupt, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
SA_INTERRUPT, "rtc", NULL) { 
\end_layout

\begin_layout LyX-Code

\size small
printk(KERN_ERR "rtc: cannot register IRQ %d
\backslash
n", RTC_IRQ); 
\end_layout

\begin_layout LyX-Code

\size small
return -EIO; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
Treba obratiti pažnju da je se linija prekida čuva u parametru 
\family typewriter
RTC_IRQ
\family default
.
 Za PC arhitekturu, RTC se uvek nalazi na prekidnoj liniji 
\family typewriter
IRQ 8
\family default
.
 Drugi parametar je upravljač prekida 
\family typewriter
rtc_interrupt
\family default
 koji radi sa svim prekidima koji su omogućeni, zahvaljujući flegu 
\family typewriter
SA_INTERRUPT
\family default
.
 Četvrti parametar određuje ime upravljačkog programa: 
\family typewriter
"rtc"
\family default
.
 Pošto ovaj uređaj ne može da deli liniju prekida, a upravljač ne koristi
 neku posebnu vrednost, za 
\family typewriter
dev_id
\family default
 se prosleđuje vrednost NULL.
 Sledi kôd za upravljač:
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
/* 
\end_layout

\begin_layout LyX-Code

\size small
* A very tiny interrupt handler.
 It runs with SA_INTERRUPT set, 
\end_layout

\begin_layout LyX-Code

\size small
* but there is a possibility of conflicting with the set_rtc_mmss() 
\end_layout

\begin_layout LyX-Code

\size small
* call (the rtc irq and the timer irq can easily run at the same 
\end_layout

\begin_layout LyX-Code

\size small
* time in two different CPUs).
 So we need to serialize 
\end_layout

\begin_layout LyX-Code

\size small
* accesses to the chip with the rtc_lock spinlock that each 
\end_layout

\begin_layout LyX-Code

\size small
* architecture should implement in the timer code.
 
\end_layout

\begin_layout LyX-Code

\size small
* (See ./arch/XXXX/kernel/time.c for the set_rtc_mmss() function.) */ 
\end_layout

\begin_layout LyX-Code

\size small
static irqreturn_t rtc_interrupt(int irq, void *dev_id, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct pt_regs *regs) { 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
/* 
\end_layout

\begin_layout LyX-Code

\size small
* Can be an alarm interrupt, update complete interrupt, 
\end_layout

\begin_layout LyX-Code

\size small
* or a periodic interrupt.
 We store the status in the 
\end_layout

\begin_layout LyX-Code

\size small
* low byte and the number of interrupts received since 
\end_layout

\begin_layout LyX-Code

\size small
* the last read in the remainder of rtc_irq_data.
 */
\end_layout

\begin_layout LyX-Code

\size small
spin_lock (&rtc_lock);
\end_layout

\begin_layout LyX-Code

\size small
rtc_irq_data += 0x100; 
\end_layout

\begin_layout LyX-Code

\size small
rtc_irq_data &= ~0xff; 
\end_layout

\begin_layout LyX-Code

\size small
rtc_irq_data |= (CMOS_READ(RTC_INTR_FLAGS) & 0xF0);
\end_layout

\begin_layout LyX-Code

\size small
if (rtc_status & RTC_TIMER_ON) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
mod_timer(&rtc_irq_timer, jiffies + HZ/rtc_freq + 2*HZ/100);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
spin_unlock (&rtc_lock);
\end_layout

\begin_layout LyX-Code

\size small
/* 
\end_layout

\begin_layout LyX-Code

\size small
* Now do the rest of the actions 
\end_layout

\begin_layout LyX-Code

\size small
*/ 
\end_layout

\begin_layout LyX-Code

\size small
spin_lock(&rtc_task_lock); 
\end_layout

\begin_layout LyX-Code

\size small
if (rtc_callback) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
rtc_callback->func(rtc_callback->private_data); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
spin_unlock(&rtc_task_lock); 
\end_layout

\begin_layout LyX-Code

\size small
wake_up_interruptible(&rtc_wait); 
\end_layout

\begin_layout LyX-Code

\size small
kill_fasync (&rtc_async_queue, SIGIO, POLL_IN);
\end_layout

\begin_layout LyX-Code

\size small
return IRQ_HANDLED; 
\end_layout

\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
Ova funkcija se poziva kad god mašina primi RTC prekid.
 Funkcija vraća 
\family typewriter
IRQ_HANDLED
\family default
 za ispravan završetak.
 
\end_layout

\begin_layout Standard
Kada se izvršava donja polovina prekidne rutine, kernel je u kontekstu prekida.
 Podsetimo se da je kontekst procesa režim kernela.
 Kontekst prekida nije pridružen procesu.
 Upravljač prekida zaustavlja izvršavanje drugog kôda (čak i drugog upravljača
 prekida na drugoj liniji).
 Zbog asinhrone prirode prekida, važno je da svi upravljači prekida budu
 brzi i jednostavni.
 
\end_layout

\begin_layout Section
Primena upravljanja prekidima
\end_layout

\begin_layout Standard
Primena sistema upravljanja prekidima zavisi od arhitekture sistema, tj.
 od procesora, tipa kontrolera prekida i same mašine.
 Na Slici 12.1 prikazan je dijagram putanje prekida od hardvera do kernela.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko11.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 12.1: Putanja prekida od hardvera do kernela.
\end_layout

\begin_layout Standard
Uređaj izdaje prekid slanjem električnog signala kontroleru prekida preko
 magistrale.
 Ako linija prekida nije maskirana, kontroler prekida šalje prekid procesoru.
 Kada se prekidi omoguće u procesoru, procesor odmah zaustavlja tekući posao,
 onemogućuje rad sistema prekida, 
\begin_inset Quotes eld
\end_inset

skače
\begin_inset Quotes erd
\end_inset

 na unapred određenu lokaciju u memoriji i izvršava kôd koji se tu nalazi.
 Unapred definisana lokacija u memoriji je ulazna tačka za upravljač prekida
 i postavlja je kernel.
 Kernel zna IRQ broj dolazećeg prekida; početna ulazna tačka u prekidnoj
 rutini samo sačuva IRQ broj i tekuće vrednosti registara (koje pripadaju
 prekinutom zadatku) na steku.
 Zatim kernel poziva funkciju 
\family typewriter
do_IRQ()
\family default
.
 Iako je najveći deo kôda upravljača prekida napisan u jeziku C, ipak je
 zavisan od arhitekture.
 Funkcija 
\family typewriter
do_IRQ()
\family default
 se deklariše na sledeći način:
\end_layout

\begin_layout Standard

\family typewriter
\size small
unsigned int do_IRQ(struct pt_regs regs)
\end_layout

\begin_layout Standard
Pošto poziv funkcije u jeziku C standardno smešta argumente funkcije na
 vrh steka, struktura 
\family typewriter
\size small
pt_regs
\family default
\size default
 sadrži početne vrednosti registara koje su prethodno sačuvane u asemblerskoj
 ulaznoj rutini.
 Pošto je i vrednost prekida takođe sačuvana, 
\family typewriter
\size small
do_IRQ()
\family default
\size default
 može da je iskoristi.
 Kôd za arhitekturu x86 je:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int irq = regs.orig_eax & 0xff;
\end_layout

\begin_layout Standard
Nakon izračunavanja linije prekida, funkcija 
\family typewriter
\size small
do_IRQ()
\family default
\size default
 potvrđuje prijem prekida i onemogućuje pristizanje novih prekida na liniji.
 Na PC mašini, ove operacije izvodi funikcija 
\family typewriter
\size small
mask_and_ack_8259A()
\family default
\size default
, koju poziva 
\family typewriter
\size small
do_IRQ()
\family default
\size default
.
 Zatim 
\family typewriter
\size small
do_IRQ()
\family default
\size default
 omogućuje da se odgovarajući upravljač prekida registruje na liniji, proverava
 da li je omogućen i da li se već ne izvršava.
 Ako je sve u redu, poziva se funkcija 
\family typewriter
\size small
handle_IRQ_event()
\family default
\size default
 koja pokreće instalirane upravljače prekida za liniju.
 Za arhitekturu x86 funkcija handle_IRQ_event() izgleda ovako:
\end_layout

\begin_layout LyX-Code

\size small
asmlinkage int handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct irqaction *action) { 
\end_layout

\begin_layout LyX-Code

\size small
int status = 1; 
\end_layout

\begin_layout LyX-Code

\size small
int retval = 0;
\end_layout

\begin_layout LyX-Code

\size small
if (!(action->flags & SA_INTERRUPT)) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
local_irq_enable();
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
do { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
status |= action->flags; 
\end_layout

\begin_layout LyX-Code

\size small
retval |= action->handler(irq, action->dev_id, regs); 
\end_layout

\begin_layout LyX-Code

\size small
action = action->next; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} while (action);
\end_layout

\begin_layout LyX-Code

\size small
if (status & SA_SAMPLE_RANDOM) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
add_interrupt_randomness(irq);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
local_irq_disable();
\end_layout

\begin_layout LyX-Code

\size small
return retval; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
Prvo, pošto je procesor onemogućio prekide, oni se ponovo omogućuju osim
 ako 
\family typewriter
\size small
SA_INTERRUPT
\family default
\size default
 nije bio određen tokom registracije upravljača.
 Podsetimo se da 
\family typewriter
\size small

\begin_inset Newline linebreak
\end_inset

SA_INTERRUPT
\family default
\size default
 određuje da li upravljač prekida treba da se pokrene sa onemogućenim prekidima.
 Zatim se svaki potencijalni upravljač prekida izvršava u petlji.
 Ako se prekidna linija ne deli, petlja se završava nakon prve iteracije;
 u suprotnom, izvršavaju se svi upravljači.
 Nakon toga, poziva se funkcija 
\family typewriter
\size small
add_interrupt_randomness()
\family default
\size default
 ako je vrednost 
\family typewriter
\size small
SA_SAMPLE_RANDOM
\family default
\size default
 bila određena tokom registracije.
 Ova funkcija koristi vreme prekida da bi generisala entropiju za generator
 slučajnih brojeva.
 Na kraju, prekidi se opet onemogućavaju (
\family typewriter
\size small
do_IRQ()
\family default
\size default
 i dalje očekuje da bude isključena) i funkcija se završava.
 Funkcija 
\family typewriter
\size small
do_IRQ()
\family default
\size default
vraća se na početnu ulaznu tačku, a zatim skače na funkciju 
\family typewriter
\size small
ret_from_intr()
\family default
\size default
.
 Rutina 
\family typewriter
\size small
ret_from_intr()
\family default
\size default
 je napisana u asembleru, kao i početni ulazni kôd.
 Ova rutina proverava da li je predviđeno preraspoređivanje; ako jeste,
 i ako se kontrola iz kernela vraća u korisnički prostor (kada prekid prekine
 izvršenje korisničkog procesa), poziva se funkcija 
\family typewriter
\size small
schedule()
\family default
\size default
.
 Ako se kernel vraća u kernel prostor (prekid prekida sâm kernel), funkcija
 
\family typewriter
\size small
schedule()
\family default
\size default
 se poziva samo ako je vrednost 
\family typewriter
\size small
preempt_count
\family default
\size default
 nula (inače nije bezbedno prinudno suspendovati kernel).
 Nakon završetka funkcije 
\family typewriter
\size small
schedule()
\family default
\size default
, ili ako nema nezavršenog posla, vraćaju se početne vrednosti registara
 i kernel nastavlja proces koji je bio prekinut.
 Za arhitekturu x86, početne asemblerske rutine su locirane u datoteci 
\family typewriter
\size small
arch/i386/kernel/entry.S
\family default
\size default
, dok se C metodi nalaze u 
\family typewriter
\size small
arch/i386/kernel/irq.c
\family default
\size default
.
 Slično je kod drugih arhitektura.
 
\end_layout

\begin_layout Subsection
Kontrola prekida
\end_layout

\begin_layout Standard
Jezgro Linuxa implementira familiju interfejsa za rad sa prekidima na mašini.
 Ovi interfejsi omogućuju korisniku da onemogući sistem prekida za tekući
 procesor ili da maskira liniju prekida za celu mašinu.
 Sve pomenute rutine su zavisne od arhitekture i nalaze se u zaglavljima
 
\family typewriter
\size small
<asm/system.h>
\family default
\size default
 i 
\family typewriter
\size small
<asm/irq.g>
\family default
\size default
.
 Razlozi za kontrolu sistema prekida generalno se svode na potrebu da se
 obezbedi sinhronizacija.
 Onemogućavanje prekida garantuje da upravljač prekida neće prinudno suspendovat
i tekući kôd.
 Šta više, onemogućavanje prekida istovremeno onemogućava i prinudno suspendovan
je kernela (kernel preemption).
 Međutim, to nije zaštita od konkurentnog pristupa drugih procesora.
 Pošto Linux podržava multiprocesorski rad, kôd kernela treba na neki način
 da bude 
\begin_inset Quotes eld
\end_inset

zaključan
\begin_inset Quotes erd
\end_inset

 da bi se sprečio konkurentni pristup deljenim podacima drugih 
\begin_inset Index idx
status open

\begin_layout Plain Layout
prekid!kontrola()
\end_layout

\end_inset

procesora.
 Zaključavanje se često dešava u kombinaciji sa onemogućavanjem lokalnih
 prekida.
 
\end_layout

\begin_layout Standard
Da bi se prekidi onemogućili lokalno za tekući procesor (i samo za njega),
 a kasnije ponovo omogućili, treba uraditi sledeće: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
local_irq_disable();
\end_layout

\begin_layout Standard

\family typewriter
\size small
/* interrupts are disabled ..
 */ 
\end_layout

\begin_layout Standard

\family typewriter
\size small
local_irq_enable(); 
\end_layout

\begin_layout Standard
Često se samo specifične linije prekida onemogućavaju za ceo sistem; to
 se zove 
\shape italic
maskiranje linije prekida
\shape default
.
 Na primer, korisnik možda želi da onemogući prekide za uređaj pre nego
 što utvrdi njegovo stanje.
 Linux obezbeđuje četiri interfejsa za ovaj zadatak:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void disable_irq(unsigned int irq); 
\end_layout

\begin_layout Standard

\family typewriter
\size small
void disable_irq_nosync(unsigned int irq); 
\end_layout

\begin_layout Standard

\family typewriter
\size small
void enable_irq(unsigned int irq); 
\end_layout

\begin_layout Standard

\family typewriter
\size small
void synchronize_irq(unsigned int irq);
\end_layout

\begin_layout Standard
Upravljački programi za nove uređaje ne koriste ove interfejse.
 U modernim računarima, skoro sve linije prekida mogu biti deljene.
 
\end_layout

\begin_layout Subsection
Status sistema prekida
\end_layout

\begin_layout Standard
Makro 
\family typewriter
\size small
irqs_disabled()
\family default
\size default
, definisan u zaglavlju 
\family typewriter
\size small
<asm/system.h>
\family default
\size default
, vraća vrednost različitu od nule kada je sistem prekida lokalnog procesora
 onemogućen.
 Ako to nije slučaj, makro vraća nulu.
 Dva makroa definisana u zaglavlju 
\family typewriter
\size small
<asm/hardirg.h>
\family default
\size default
 obezbeđuju interfejs za proveru tekućeg konteksta kernela:
\end_layout

\begin_layout Standard

\family typewriter
\size small
in_interrupt() 
\end_layout

\begin_layout Standard

\family typewriter
\size small
in_irq()
\end_layout

\begin_layout Standard
Prvi makro vraća vrednost različitu od nule ako je kernel u kontekstu prekida,
 a nulu kada je kernel u kontekstu procesa.
 Makro 
\family typewriter
\size small
in_irq()
\family default
\size default
 vraća vrednost različitu od nule samo kada kernel izvršava upravljač prekida.
\end_layout

\begin_layout Subsection
Donja polovina upravljača i odložen posao 
\end_layout

\begin_layout Standard
Zbog različitih ograničenja, upravljači prekida mogu da obave samo prvu
 polovinu obrade prekida.
 Ta ograničenja su sledeća:
\end_layout

\begin_layout Description
• Upravljači prekida rade asinhrono i prekidaju drugi potencijalno važan
 kôd.
 Zbog toga moraju da budu veoma brzi.
 
\end_layout

\begin_layout Standard
• Upravljači prekida rade sa tekućim nivoom prekida koji je u najboljem
 slučaju onemogućen (ako vrednost 
\family typewriter
\size small
SA_INTERRUPT
\family default
\size default
 nije postavljena), a u najgorem slučaju rade sa svim prekidima koji su
 onemogućeni na tekućem procesoru (ako je vrednost 
\family typewriter
\size small

\begin_inset Newline linebreak
\end_inset

SA_INTERRUPT
\family default
\size default
 postavljena).
 
\end_layout

\begin_layout Standard
• Upravljači prekida su često vremenski ograničeni zato što rade sa hardverom.
 
\end_layout

\begin_layout Standard
• Upravljači prekida ne rade u kontekstu procesa, pa se stoga ne mogu blokirati.
 
\end_layout

\begin_layout Standard
Očigledno je da su upravljači prekida samo deo kompletnog rešenja upravljanja
 hardverskim prekidima.
 Upravljanje prekidima je podeljeno na dva dela, ili polovine.
 Prvi deo (gornju polovinu) asinhrono izvršava kernel kao trenutni odziv
 na hardverski prekid.
 Zadatak donje polovine je da odloži i izvrši bilo koji posao koji nije
 vremenski ograničen.
 Verzija Linuxovog kernela 2.6 ima tri mehanizma rada u donjoj polovini:
 
\family typewriter
\size small
softirqs
\family default
\size default
, 
\family typewriter
\size small
tasklets
\family default
\size default
 i 
\family typewriter
\size small
work queues
\family default
\size default
 (pri čemu su prva dva veoma slična).
 Mehanizam 
\family typewriter
\size small
work queue
\family default
\size default
 zasniva se na nitima jezgra i najviše se koristi, zatim se koristi mehanizam
 
\family typewriter
\size small
tasklets
\family default
\size default
 i na kraju 
\family typewriter
\size small
softirqs
\family default
\size default
.
 
\end_layout

\begin_layout Chapter
Sinhronizacija u kernelu 
\end_layout

\begin_layout Standard
U aplikacijama koje rade sa deljenom memorijom mora se voditi računa o tome
 da deljeni resursi budu zaštićeni od konkurentnog pristupa.
 U tome ni kernel nije izuzetak.
 Deljeni resursi zahtevaju zaštitu od konkurentnog pristupa jer ako više
 niti pristupa podacima u istom trenutku, one mogu da promene postojeće
 rezultate ili da pristupe podacima koji su u nekonzistentnom stanju.
 Termin 
\shape italic
nit izvršenja
\shape default
 predstavlja bilo koju instancu kôda koji se izvršava (npr.
 zadatak u kernelu, upravljač prekida, mehanizme donje polovine upravljanja
 prekidima ili kernel niti).
 U verziji kernela 2.0 uvedena je podrška za simetrično multiprocesiranje,
 tj.
 mogućnost da kôd kernela može istovremeno da radi sa dva ili više procesora.
 Od verzije 2.6 kernel je moguće prinudno suspendovati, što znači da raspoređivač
 u kernelu može da prekine izvršavanje kôda kernela i dodeli procesoru
\begin_inset Index idx
status open

\begin_layout Plain Layout
sinhronizacija!u kernelu Linuxa
\end_layout

\end_inset

 drugi zadatak.
\end_layout

\begin_layout Section
Kritične sekcije i stanje trke 
\end_layout

\begin_layout Standard
Kôd u kome se pristupa deljenim podacima i radi sa njima zove se kritična
 sekcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
kritična sekcija
\end_layout

\end_inset

.
 Da bi se izbegao konkurentan pristup kritičnim sekcijama, programer mora
 da obezbedi da se kôd izvršava bez prekida, tj.
 treba da se izvrši bez prekida kao da je cela kritična sekcija jedna nedeljiva
 instrukcija.
 Bila bi greška kada bi se dve niti istovremeno izvršavale u istoj kritičnoj
 sekciji; takav slučaj nazivamo stanje trke
\begin_inset Index idx
status open

\begin_layout Plain Layout
stanje trke
\end_layout

\end_inset

 (race condition).
 Izbegavanje konkurentnosti i stanja trke naziva se sinhronizacija.
 
\end_layout

\begin_layout Section
Zaključavanje
\end_layout

\begin_layout Standard
U određenom trenutku samo jedna nit može da radi sa strukturama podataka.
 Dakle, pristup tim strukturama podataka treba zaključati (lock) dok je
 druga nit izvršenja u označenoj sekciji.
 Mehanizam zaključavanja
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaključavanje
\end_layout

\end_inset

 radi kao brava na vratima.
 Ako se zamisli soba kao kritična sekcija, u sobi može da bude prisutna
 samo jedna nit izvršenja u određenom trenutku.
 Kada nit uđe u sobu, ona zaključa vrata za sobom.
 Kada nit završi rad sa deljenim podacima, ona napušta sobu i otključava
 vrata.
 Ako druga nit stigne do zaključanih vrata, mora da čeka da nit u sobi napusti
 sobu i otključa vrata.
 Niti drže brave (locks); brave štite podatke, odnosno zaključavaju podatke,
 a ne kôd.
 Zaključavanje štiti i redove od stanja trke.
 
\end_layout

\begin_layout Standard
U Linuxu su implementirani različiti mehanizmi zaključavanja.
 Oni se razlikuju po tome kako se zadaci ponašaju kada se primeni zaključavanje:
 neki zadaci su u stanju 
\begin_inset Quotes eld
\end_inset

uposlenog čekanja
\begin_inset Quotes erd
\end_inset

 (busy wait), tj.
 vrte se u beskonačnoj petlji čekajući da se sekcija otključa, a drugi su
 u stanju „spavanja“ (sleep).
 Konkurentnost u kojoj se dve stvari ne dešavaju u isto vreme, ali se međusobno
 prepliću zove se pseudo konkurentnost.
 Na mašini sa simetričnim multiprocesiranjem, dva procesa mogu zaista da
 se izvršavaju u kritičnoj sekciji u istom trenutku.
 To je stvarna konkurentnost.
 Obe vrste konkurentnosti kao rezultat daju iste stanje trke i zahtevaju
 istu vrstu zaštite.
\end_layout

\begin_layout Section
Metodi sinhronizacije u kernelu 
\end_layout

\begin_layout Standard
Nedeljive (atomic) operacije sadrže instrukcije koje se izvršavaju bez prekida.
 Kernel obezbeđuje dva skupa interfejsa za nedeljive operacije, jedan koji
 radi sa celim brojevima i drugi koji radi sa pojedinačnim bitovima.
 
\end_layout

\begin_layout Subsection
Nedeljive operacije sa celim brojevima
\end_layout

\begin_layout Standard
Metodi nedeljivog celog broja
\begin_inset Index idx
status open

\begin_layout Plain Layout
nedeljive operacije!sa celim brojevima
\end_layout

\end_inset

 rade sa specijalnim podacima tipa 
\family typewriter
\size small
atomic_t
\family default
\size default
.
 Ovaj tip se koristi umesto funkcija koje rade direktno sa tipom 
\family typewriter
\size small
int
\family default
\size default
 iz C jezika, i to iz sledećih razloga: rad sa nedeljivim funkcijama koje
 prihvataju samo tip 
\family typewriter
\size small
atomic_t
\family default
\size default
 omogućuje da se nedeljive operacije koriste isključivo sa ovim specijalnim
 tipovima.
 Takođe, omogućuje da se tipovi podataka ne prosleđuju ni jednoj drugoj
 funkciji koja nije nedeljiva.
 Korišćenje tipa 
\family typewriter
\size small
atomic_t
\family default
\size default
 omogućava da kompajler ne optimizuje pristup vrednosti; važno je da nedeljive
 operacije prime odgovarajuću memorijsku adresu, a ne neku prethodnu.
 Konačno, korišćenje tipa 
\family typewriter
\size small
atomic_t
\family default
\size default
 može da sakrije sve razlike u njegovoj primeni zavisne od arhitekture.
 Deklaracije koje koriste nedeljive celobrojne operacije definisane su u
 zaglavlju 
\family typewriter
\size small
<asm/atomic.h>
\family default
\size default
.
 Kada korisnik piše kôd za kernel, treba da omogući da su ove operacije
 ispravno implementirane na svim arhitekturama.
 Definisanje tipa 
\family typewriter
\size small
atomic_t
\family default
\size default

\begin_inset Index idx
status open

\begin_layout Plain Layout
atomic_t, tip
\end_layout

\end_inset

 je uobičajen način, a može da se postavi i početna vrednost: 
\end_layout

\begin_layout LyX-Code

\size small
atomic_t v; /* define v */ 
\end_layout

\begin_layout LyX-Code

\size small
atomic_t u = ATOMIC_INIT(0); 
\end_layout

\begin_layout LyX-Code

\size small
/* define u and initialize it to zero */
\end_layout

\begin_layout Standard
Sve operacije su jednostavne: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
atomic_set(&v, 4); /* v = 4 (atomically) */ 
\end_layout

\begin_layout Standard

\family typewriter
\size small
atomic_add(2, &v); /* v = v + 2 = 6 (atomically) */ 
\end_layout

\begin_layout Standard

\family typewriter
\size small
atomic_inc(&v); /* v = v + 1 = 7 (atomically) */ 
\end_layout

\begin_layout Standard
Ako je potrebno da se izvrši konverzija tipa 
\family typewriter
\size small
atomic_t
\family default
\size default
 u tip 
\family typewriter
\size small
int
\family default
\size default
, treba upotrebiti funkciju 
\family typewriter
\size small
atomic_read()
\family default
\size default
:
\end_layout

\begin_layout Standard

\family typewriter
\size small
printk("%d
\backslash
n", atomic_read(&v)); /* will print "7" */
\end_layout

\begin_layout Standard
Potpun spisak standardnih nedeljivih operacija sa celim brojevima dat je
 u zaglavlju 
\family typewriter
\size small
<asm/atomic.h>
\family default
\size default
, a u nastavku prikazujemo samo deo funkcija:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="30text%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedeljive celobrojne operacije
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ATOMIC_INIT(int i) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U deklaraciji, inicijalizacija 
\family typewriter
\size small
atomic_t
\family default
\size default
 na 
\family typewriter
\size small
i
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
int atomic_read(atomic_t *v)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedeljivo čitanje celobrojne vrednosti 
\family typewriter
\size small
v
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
void atomic_set(atomic_t *v, int i)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedeljivo postavljanje 
\family typewriter
\size small
v
\family default
\size default
 na 
\family typewriter
\size small
i
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
void atomic_add(int i, atomic_t *v)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedeljivo sabiranje 
\family typewriter
\size small
i
\family default
\size default
 sa 
\family typewriter
\size small
v
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
void atomic_sub(int i, atomic_t *v)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedeljivo oduzimanje 
\family typewriter
\size small
i
\family default
\size default
 od 
\family typewriter
\size small
v
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
void atomic_inc(atomic_t *v)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedeljivo inkrementiranje 
\family typewriter
\size small
v
\family default
\size default
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Nedeljive operacije su obično implementirane kao inline funkcije.
 Kada određena funkcija nasleđuje osobinu nedeljivosti, ona je samo makro.
 Korišćenje nedeljivih operacija umesto složenih mehanizama zaključavanja
 (locking) je uobičajeno.
 
\end_layout

\begin_layout Subsection
Nedeljive operacije sa bitovima
\end_layout

\begin_layout Standard
Nedeljive operacije za rad sa bitovima
\begin_inset Index idx
status open

\begin_layout Plain Layout
nedeljive operacije!sa bitovima
\end_layout

\end_inset

 nalaze se u zaglavlju 
\family typewriter
\size small
<asm/bitops.h>
\family default
\size default
.
 Funkcije koje rade sa bitovima koriste generičke memorijske adrese, a argumenti
 su im pokazivači i bitovi brojeva.
 Bit nula je najmanje značajan bit adrese.
 Pošto funkcije rade sa generičkim pokazivačima, ne postoji ekvivalent nedeljivo
m celobrojnom tipu 
\family typewriter
\size small
atomic_t
\family default
\size default
, već programer može da radi sa pokazivačem na bilo koje podatke.
 Sledi primer: 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long word = 0;
\end_layout

\begin_layout LyX-Code

\size small
set_bit(0, &word); /* bit zero is now set (atomically) */ 
\end_layout

\begin_layout LyX-Code

\size small
set_bit(1, &word); /* bit one is now set (atomically) */ 
\end_layout

\begin_layout LyX-Code

\size small
printk("%ul
\backslash
n", word); /* will print "3" */ 
\end_layout

\begin_layout LyX-Code

\size small
clear_bit(1, &word); /* bit one is now unset (atomically) */ 
\end_layout

\begin_layout LyX-Code

\size small
change_bit(0, &word); /* bit zero is flipped; */
\end_layout

\begin_layout LyX-Code

\size small
/* atomically sets bit zero and returns the previous value (zero) */ 
\end_layout

\begin_layout LyX-Code

\size small
if (test_and_set_bit(0, &word)) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
/* never true */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
/* the following is legal; 
\end_layout

\begin_layout LyX-Code

\size small
* you can mix atomic bit instructions with normal C */ 
\end_layout

\begin_layout LyX-Code

\size small
word = 7;
\end_layout

\begin_layout Standard
U produžetku je dat listing nekoliko standardnih nedeljivih operacija sa
 bitovima: 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="40text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedeljiva operacija sa bitovima
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
void set_bit(int nr, void *addr)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedeljivo postavljanje nr-tog bita počev od addr
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
void clear_bit(int nr, void *addr)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedeljivo brisanje nr-tog bita počev od addr
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Postoje i verzije funkcija koje rade sa bitovima ali nisu nedeljive.
 One su istog oblika kao nedeljive funkcije, ali počinju dvostrukom podvučenom
 linijom.
 Ako je kôd koji se piše u kernelu bezbedan od uslova trke, mogu se koristiti
 verzije koje nisu nedeljive jer mogu biti brže (zavisno od arhitekture).
 
\end_layout

\begin_layout Section
Spinlok
\end_layout

\begin_layout Standard
Spinlok
\begin_inset Index idx
status open

\begin_layout Plain Layout
spinlok
\end_layout

\end_inset

 je brava koju može da drži samo jedna nit izvršenja.
 Ako nit izvršenja pokuša da zaključa podatke koji su već zauzeti, ona se
 uposleno vrti u petlji čekajući da se podaci otključaju.
 Ako podaci nisu zaključani, nit može odmah da im pristupi, zaključa ih
 i nastavi sa radom.
 Na taj način sprečava se da nekoliko niti izvršenja istovremeno uđe u kritičnu
 sekciju
\begin_inset Index idx
status open

\begin_layout Plain Layout
kritična sekcija
\end_layout

\end_inset

.
 Treba obratiti pažnju da ista 
\begin_inset Quotes eld
\end_inset

brava
\begin_inset Quotes erd
\end_inset

 može da se iskoristi na više lokacija, pa svi pristupi datoj strukturi
 podataka, na primer, mogu biti zaštićeni i sinhronizovani.
 Ako se ponovo prisetimo analogije vrata i ključa, spinlok je vratar koji
 sedi ipred sobe, čekajući da osoba u sobi izađe i preda ključ.
 Ako stignete do vrata i nema nikog unutra, vratar će vam dati ključ da
 uđete u sobu.
 Ako ima nekog u sobi, moraćete da čekate ključ ispred sobe, a vratar će
 s vremena na vreme proveravati da li ima nekog u sobi.
 Kada je soba prazna, dobićete ključ i moći ćete da uđete unutra.
 Zahvaljujući ključu (spinlok), samo jedna osoba (nit izvršenja) u jednom
 trenutku može biti u sobi (kritičnoj sekciji).
 Činjenica da zauzet spin lock prouzrokuje da se niti vrte dok čekaju da
 se ključ oslobodi je veoma važna, jer se gubi procesorsko vreme.
 Laki spinlok koji drži jedna nit treba da traje što kraće.
 Alternativa je da se tekuće niti blokiraju (
\begin_inset Quotes eld
\end_inset

spavaju
\begin_inset Quotes erd
\end_inset

) sve dok se ne oslobodi brava, kada se bude.
 Tada procesor može da izvrši drugi kôd.
 Ovo unosi dodatne opšte troškove, tj.
 dve promene konteksta za prebacivanje i vraćanje blokiranih niti, što je
 sigurno mnogo zahtevnije od primene spin locka.
 Spinlok treba da traje kraće od promene konteksta niti.
 U nastavku će biti objašnjeni semafori koji obezbeđuju bravu tako da nit
 koja čeka prelazi u stanje spavanja dok čeka da se brava oslobodi.
\end_layout

\begin_layout Standard
Spinlok je zavisan od arhitekture i implementiran u asembleru 
\begin_inset Newline linebreak
\end_inset

(
\family typewriter
\size small
<asm/spinlock.h>
\family default
\size default
).
 Korisni interfejsi su definisani u zaglavlju 
\family typewriter
\size small
<linux/spinlock.h>
\family default
\size default
.
 Osnovni način korišćenja spinloka je: 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size small
spinlock_t mr_lock = SPIN_LOCK_UNLOCKED;
\end_layout

\begin_layout Standard

\family typewriter
\size small
spin_lock(&mr_lock); /* critical region */ 
\end_layout

\begin_layout Standard

\family typewriter
\size small
spin_unlock(&mr_lock); 
\end_layout

\begin_layout Standard
Bravu u određenom trenutku može držati samo jedna nit izvršenja.
 Sledi, samo jedna nit izvršenja može biti u jednom trenutku u kritičnoj
 sekciji.
 Ovo zahteva zaštitu niti od konkurentnog pristupa u multiprocesorskim mašinama.
 U jednoprocesorskim mašinama brave se ne koriste.
 Spinlok se može koristiti u upravljačima prekida, u kojima se semafori
 ne mogu koristiti zato što su blokirani, tj.
 uspavani.
 Ako se brava
\begin_inset Index idx
status open

\begin_layout Plain Layout
brava
\end_layout

\end_inset

 koristi u upravljaču prekida, pre zaključavanja moraju se onemogućiti lokalni
 prekidi (zahtevi za prekidom u tekućem procesoru), jer bi u suprotnom bilo
 moguće da upravljač prekida suspenduje kôd kernela dok je brava aktivna
 i pokuša da zahteva zaključavanje.
 Upravljač prekida se vrti u petlji, čekajući da zaključavanje postane moguće.
 Međutim, nit koja čuva bravu se ne izvršava dok upravljač prekida ne obavi
 svoj zadatak.
 Ovo je primer dvostrukog zahteva u slučaju potpunog zastoja
\begin_inset Index idx
status open

\begin_layout Plain Layout
potpuni zastoj
\end_layout

\end_inset

 (deadlock).
 Obratite pažnju na to da prekidi treba da se onemoguće samo na tekućem
 procesoru.
 Ako se prekid pojavi na drugom procesoru, a vrti se u petlji sa sa istom
 bravom, to neće sprečiti nit koja čuva bravu (u drugom procesoru) da otključa
 kritičnu sekciju.
 Kernel obezbeđuje interfejs pogodan za onemogućavanje prekida i zahteva
 zaključavanje na sledeći način: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
spinlock_t mr_lock = SPIN_LOCK_UNLOCKED; 
\end_layout

\begin_layout Standard

\family typewriter
\size small
unsigned long flags;
\end_layout

\begin_layout Standard

\family typewriter
\size small
spin_lock_irqsave(&mr_lock, flags); 
\end_layout

\begin_layout Standard

\family typewriter
\size small
/* critical region ...
 */ 
\end_layout

\begin_layout Standard

\family typewriter
\size small
spin_unlock_irqrestore(&mr_lock, flags); 
\end_layout

\begin_layout Standard
Rutina 
\family typewriter
\size small
spin_lock_irqsave()
\family default
\size default
 čuva trenutno stanje prekida, onemogućavajući ih lokalno, a zatim dobija
 bravu.
 Obrnuto, funkcija 
\family typewriter
\size small
spin_unlock_irqrestore()
\family default
\size default
 otključava bravu i vraća prekide u njihovo prethodno stanje.
 Na taj način, ako su prekidi u početku onemogućeni, kôd ih neće greškom
 omogućiti, već će ih održavati onemogućenim.
 Obratite pažnju da se promenljiva 
\family typewriter
\size small
flags
\family default
\size default
 naizgled prosleđuje po vrednosti, zato što su rutine za zaključavanje delimično
 implementirane kao makroi.
 Kako veličina i složenost kernela rastu, sve je teže održavati prekide
 stalno onemogućenim na putanjama kôda u kernelu.
 Zbog toga se korišćenje funkcije 
\family typewriter
\size small
spin_lock_irq()
\family default
\size default
 ne preporučuje.
 
\end_layout

\begin_layout Subsection
Spinlok metodi
\end_layout

\begin_layout Standard
Metod 
\family typewriter
\size small
spin_lock_init()
\family default
\size default
 može da se koristi za inicijalizaciju dinamički kreiranih brava (tip 
\family typewriter
\size small
spinlock_t
\begin_inset Index idx
status open

\begin_layout Plain Layout
spinlock_t, tip
\end_layout

\end_inset


\family default
\size default
 kome se može pristupiti samo preko pokazivača).
 Metod 
\family typewriter
\size small
spin_trylock()
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcija!spin_trylock()
\end_layout

\end_inset


\family default
\size default
 pokušava da dobije bravu (spinlok).
 Ako brava već postoji, funkcija odmah vraća nulu umesto da se vrti i čeka
 da se brava oslobodi.
 Ako zaključavanje uspe, funkcija 
\family typewriter
\size small
spin_trylock()
\family default
\size default
 vraća vrednost različitu od nule.
 Slično, metoda 
\family typewriter
\size small
spin_is_locked()
\family default
\size default
 vraća vrednost različitu od nule ako se ostvari zaključavanje, a u suprotnom
 vraća nulu.
 Početni deo liste standardnih spinlok metoda je: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
spin_lock()
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcija!spin_lock()
\end_layout

\end_inset

 /*Acquires lock */
\end_layout

\begin_layout Standard

\family typewriter
\size small
spin_lock_irq() /* Disables local interrupts and acquires lock */
\end_layout

\begin_layout Section
Semafori
\end_layout

\begin_layout Standard
Semafori
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori!u Linuxu
\end_layout

\end_inset

 u Linuxu su "uspavane brave
\begin_inset Quotes erd
\end_inset

 (sleeping locks): kada zadatak pokuša da dobije semafor koji drugi zadatak
 već drži, semafor smešta zadatak u red za čekanje i ostavlja ga da 
\begin_inset Quotes eld
\end_inset

spava
\begin_inset Quotes erd
\end_inset

.
 Procesor je tada slobodan da izvršava drugi kôd.
 Kada proces koji ga drži oslobodi semafor, jedan od zadataka u redu za
 čekanje se budi da bi dobio semafor.
 Dakle, više procesa može istovremeno da drži semafor, ako je to potrebno.
 Ako primenimo analogiju vrata i ključa, kada osoba stigne do vrata, ona
 može da uzme ključ i uđe u sobu.
 Kada druga osoba dođe do vrata, a ključ nije na raspolaganju, umesto da
 se 
\begin_inset Quotes eld
\end_inset

vrti
\begin_inset Quotes erd
\end_inset

, osoba upiše svoje ime u listu čekanja.
 Kada osoba koja se nalazi u sobi napusti sobu, soba proverava listu, i
 ako ima upisanih imena 
\begin_inset Quotes eld
\end_inset

budi
\begin_inset Quotes erd
\end_inset

 prvu osobu sa liste i dozvoljava joj da uđe u sobu.
 Na ovaj način ključ (semafor) obezbeđuje da je u određenom trenutku samo
 jedna osoba (nit izvršenja) u sobi (kritičnoj sekciji).
 Semafori omogućuju bolje iskorišćenje procesora od spinloka zato što se
 procesorsko vreme ne troši na uposleno čekanje u petlji, ali s druge strane
 imaju veće opšte troškove.
 Semafori dozvoljavaju da proizvoljan broj zadataka istovremeno drži bravu.
 Broj takvih procesa se zadaje tokom deklarisanja i zove se broj korišćenja
 ili samo 
\shape italic
broj
\shape default
.
 Ako je 
\shape italic
broj
\shape default
 1, semafor se naziva binarni semafor ili muteks (pošto dovoljava međusobno
 isključenje, mutual exclusion).
 Ako je 
\shape italic
broj
\shape default
 veći od 1, semafor se zove brojački semafor (counting semaphore) i dozvoljava
 da bravu u određenom trenutku drži najviše zadati 
\shape italic
broj
\shape default
 zadataka.
 Brojački semafori ne koriste međusobno isključenje zato što dozvoljavaju
 da više niti izvršenja istovremeno bude u kritičnoj sekciji.
 Semafor podržava dve nedeljive operacije: 
\family typewriter
\size small
down()
\family default
\size default
 i 
\family typewriter
\size small
up()
\family default
\size default
.
 Metod 
\family typewriter
\size small
down()
\family default
\size default
 se koristi za dobijanje semafora pri čemu se 
\shape italic
broj
\shape default
 umanjuje za jedan.
 Ako je 
\shape italic
broj
\shape default
 nula ili veći od nule, omogučava se zaključavanje i zadatak može da uđe
 u kritičnu sekciju.
 Ako je 
\shape italic
broj
\shape default
 negativan, zadatak se smešta u red za čekanje, a procesor se pomera na
 drugi posao.
 Metod 
\family typewriter
\size small
up()
\family default
\size default
 se koristi za oslobađanje semafora nakon završetka korišćenja kritične
 sekcije i povećava vrednost 
\shape italic
broja
\shape default
.
 
\end_layout

\begin_layout Subsection
Kreiranje i inicijalizacija semafora
\end_layout

\begin_layout Standard
Primena semafora
\begin_inset Index idx
status open

\begin_layout Plain Layout
semafori!kreiranje i inicijalizacija
\end_layout

\end_inset

 zavisi od arhitekture, a definisana je u zaglavlju 
\family typewriter
\size small

\begin_inset Newline linebreak
\end_inset

<asm/semaphore.h>
\family default
\size default
 kao struktura 
\family typewriter
\size small
struct semaphore
\family default
\size default
.
 Statički deklarisani semafori kreiraju se na sledeći način:
\end_layout

\begin_layout Standard

\family typewriter
\size small
static DECLARE_SEMAPHORE_GENERIC(name, count)
\end_layout

\begin_layout Standard
gde je 
\family typewriter
\size small
name
\family default
\size default
 ime promenljive, a 
\family typewriter
\size small
count
\family default
\size default
 je broj semafora.
 Za kreiranje muteks promenljive koristi se naredba:
\end_layout

\begin_layout Standard

\family typewriter
\size small
static DECLARE_MUTEX(name);
\end_layout

\begin_layout Standard
gde je 
\family typewriter
\size small
name 
\family default
\size default
ime promenljive datog semafora.
 Najčešće se semafori kreiraju dinamički, kao deo veće strukture:
\end_layout

\begin_layout Standard

\family typewriter
\size small
sema_init(sem, count);
\end_layout

\begin_layout Standard
gde je 
\family typewriter
\size small
sem
\family default
\size default
 pokazivač, a 
\family typewriter
\size small
count
\family default
\size default
 je broj korišćenja semafora.
 Slično, da bi se inicijalizovao dinamički kreiran muteks može se koristiti:
\end_layout

\begin_layout Standard

\family typewriter
\size small
init_MUTEX(sem); 
\end_layout

\begin_layout Subsection
Korišćenje semafora
\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
\size small
down_interruptible() 
\family default
\size default
pokušava da dobije semafor; ako ne uspe, 
\begin_inset Quotes eld
\end_inset

spava
\begin_inset Quotes erd
\end_inset

 u stanju 
\family typewriter
\size small
TASK_INTERRUPTIBLE
\family default
\size default
.
 Ovo stanje procesa ne dozvoljava da signal probudi zadatak.
 Ako zadatak primi signal dok čeka na semafor, budi se, a funkcija 
\family typewriter
\size small

\begin_inset Newline linebreak
\end_inset

down_interruptible()
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!down_interruptible()
\end_layout

\end_inset


\family default
\size default
 vraća 
\family typewriter
\size small
EINTR
\family default
\size default
.
 Slično, funkcija 
\family typewriter
\size small
down()
\family default
\size default
 smešta zadatak u stanje 
\family typewriter
\size small
TASK_UNINTERRUPTIBLE
\family default
\size default
 ako 
\begin_inset Quotes eld
\end_inset

spava
\begin_inset Quotes erd
\end_inset

.
 Ovo u nekim slučajevima nije željeno ponašanje jer proces koji čeka na
 semafor ne odgovara na signale.
 Zbog toga se funkcija 
\family typewriter
\size small
down_interruptible()
\family default
\size default
 češće koristi nego funkcija 
\family typewriter
\size small
down()
\family default
\size default
.
 Funkcija 
\family typewriter
\size small
down_trylock()
\family default
\size default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!down_trylock()
\end_layout

\end_inset

 se može upotrebiti za pokušaj dobijanja semafora sa blokiranjem.
 Ako je semafor zauzet, funkcija odmah vraća broj različit od nule, u suprotnom
 vraća nulu i proces uspešno držite bravu.
 Da bi se oslobodio dati semafor, poziva se funkcija 
\family typewriter
\size small
up()
\family default
\size default
.
 Posmatrajmo primer: 
\end_layout

\begin_layout LyX-Code

\size small
/* define and declare a semaphore, named mr_sem, 
\end_layout

\begin_layout LyX-Code

\size small
* with a count of one */ 
\end_layout

\begin_layout LyX-Code

\size small
static DECLARE_MUTEX(mr_sem);
\end_layout

\begin_layout LyX-Code

\size small
/* attempt to acquire the semaphore ...
 */ 
\end_layout

\begin_layout LyX-Code

\size small
if (down_interruptible(&mr_sem)) { 
\end_layout

\begin_layout LyX-Code

\size small
/* signal received, semaphore not acquired ...
 */ 
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
/* critical region ...
 */
\end_layout

\begin_layout LyX-Code

\size small
/* release the given semaphore */ 
\end_layout

\begin_layout LyX-Code

\size small
up(&mr_sem); 
\end_layout

\begin_layout Standard
U nastavku su opisane metode koje se koriste u radu sa semaforima:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="40text%">
<column alignment="center" valignment="top" width="40text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Metod
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
sema_init(struct semaphore *, int)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inicijalizuje dinamički kreiran semafor za dati broj semafora
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
init_MUTEX(struct semaphore *)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inicijalizuje dinamički kreiran semafor sa count=1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
init_MUTEX_LOCKED(struct semaphore *)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inicijalizuje dinamički kreiran semafor sa count=0 (inicijalno je zaključan)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Poređenje spinlok
\begin_inset Index idx
status open

\begin_layout Plain Layout
spinlok!poređenje sa semaforima u Linuxu
\end_layout

\end_inset

a i semafora 
\end_layout

\begin_layout Standard
Spinlok se može iskoristiti u kontekstu prekida, dok se semafor može iskoristiti
 kada je zadatak blokiran i 
\begin_inset Quotes eld
\end_inset

spava
\begin_inset Quotes erd
\end_inset

.
 Poređenje je dato u sledećoj tabeli: 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zahtevi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preporučuje se
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Malo troškovi zaključavanja
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
spinlok
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kratko vreme držanja brave
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
spinlok
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dugo vreme držanja brave
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
semafor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Potreba za zaključavanjem iz konteksta prekida
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
spinlok
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Potreba za 
\begin_inset Quotes eld
\end_inset

spavanjem
\begin_inset Quotes erd
\end_inset

 dok se drži brava
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
semafor
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Barijere 
\end_layout

\begin_layout Standard
Kada se sinhronizuje više procesora ili hardverski uređaji, ponekad se zahteva
 da se iz memorije učitava i u memoriju upisuje po redosledu koji je određen
 programskim kôdom.
 Međutim, i kompajler i procesor mogu da promene čitanje i upis da bi poboljšali
 performanse.
 Svi procesori koji menjaju redosled čitanja ili upisa podržavaju mašinske
 instrukcije kojima se to postiže.
 Takođe, kompajleru je moguće dati instrukcije da ne menja redosled; te
 instrukcije se zovu
\begin_inset Index idx
status open

\begin_layout Plain Layout
barijere
\end_layout

\end_inset

 
\series bold
barijere
\series default
.
 Intelovi procesori iz familije x86 nikada ne menjaju redosled upisa, dok
 drugi procesori to rade.
\end_layout

\begin_layout Chapter
Upravljanje memorijom 
\end_layout

\begin_layout Standard
Ovo poglavlje opisuje metode koje se koriste za upravljanje memorijom
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!upravljanje u Linuxu
\end_layout

\end_inset

 unutar Linuxovog kernela.
 
\end_layout

\begin_layout Section
Stranice
\end_layout

\begin_layout Standard
Fizičke stranice
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice
\end_layout

\end_inset

 su osnovne jedinice upravljanja memorijom u kernelu.
 Iako je najmanja jedinica adresiranja procesora obično reč (ili bajt),
 jedinica za upravljanje memorijom (memory management unit, MMU
\begin_inset Index idx
status open

\begin_layout Plain Layout
MMU
\end_layout

\end_inset

) koja prevodi virtuelne adrese u fizičke po pravilu radi sa stranicama.
 MMU upravlja tabelom stranica u sistemu.
 Različite arhitekture definišu različite veličine stranice, a mnoge podržavaju
 i više veličina stranice.
 Po pravilu, 32-bitne arhitekture koriste stranice veličine 4KB, a većina
 64-bitnih arhitektura ima stranice veličine 8KB.
 Na osnovu toga se izračunava da je u mašini koja radi sa stranicama veličine
 4KB i veličinom fizičke memorije od 1GB, fizička memorija podeljena u 262
 144 različite stranice.
 Kernel svaku fizičku stranicu u sistemu modelira strukturom 
\family typewriter
\size small
struct page
\family default
\size default
 definisanom u zaglavlju 
\family typewriter
\size small
<linux/mm.h>
\family default
\size default
: 
\end_layout

\begin_layout LyX-Code

\size small
struct page { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
page_flags_t flags; 
\end_layout

\begin_layout LyX-Code

\size small
atomic_t _count; 
\end_layout

\begin_layout LyX-Code

\size small
atomic_t _mapcount; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long private; 
\end_layout

\begin_layout LyX-Code

\size small
struct address_space *mapping; 
\end_layout

\begin_layout LyX-Code

\size small
pgoff_t index; 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head lru; 
\end_layout

\begin_layout LyX-Code

\size small
void *virtual; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Polje 
\family typewriter
\size small
flags
\family default
\size default
 čuva status stranice, npr.
 da li je strana 
\begin_inset Quotes eld
\end_inset

dirty
\begin_inset Quotes erd
\end_inset

 ili je zaključana u memoriji.
 Na raspolaganju su istovremeno najmanje 32 različite vrednosti za promenljivu
 
\family typewriter
\size small
flags
\family default
\size default
, definisane u zaglavlju 
\family typewriter
\size small
<linux/page-flags.h>
\family default
\size default
.
 Polje 
\family typewriter
\size small
_count
\family default
\size default
 sadrži broj referenci na stranicu.
 Polje 
\family typewriter
\size small
virtual
\family default
\size default
 je adresa strane u virtuelnoj memoriji.
 Važno je razumeti da je struktura stranice pridružena fizičkim stranama,
 a ne virtuelnim.
 Cilj je da strukture podataka opišu fizičku memoriju, a ne podatke koji
 se nalaze u njima.
 Kernel koristi ovu strukturu za praćenje svih stranica u sistemu.
 Kernel treba da zna da li je stranica slobodna (nije alocirana, tj.
 dodeljena), a ako nije, treba da zna ko je njen vlasnik (korisnik, dinamički
 alocirani kernel podaci, statički kernel kod, keš strana itd).
 Pretpostavimo da struktura stranice troši 40 bajtova memorije, fizička
 stranica u sistemu 4KB i da sistem ima 128MB fizičke memorije.
 U tom slučaju sve strukture stranica u sistemu troše oko 1MB memorije,
 što nisu veliki troškovi.
 
\end_layout

\begin_layout Section
Zone 
\end_layout

\begin_layout Standard
Zbog hardverskih ograničenja, kernel ne može prema svim stranicama da se
 odnosi na isti način.
 Neke stranice zbog fizičkih adresa u memoriji ne mogu da se koriste za
 određene zadatke.
 Zbog toga kernel deli stranice po sličnim osobinama u različite zone
\begin_inset Index idx
status open

\begin_layout Plain Layout
straničenje!i zone u Linuxu
\end_layout

\end_inset

.
 Linux radi sa hardverom sa sledećim adresiranjem u memoriji: 
\end_layout

\begin_layout Itemize
Neki hardverski uređaji su sposobni da direktno pristupe memoriji (uz pomoć
 DMA) sa određene memorijske adrese.
 
\end_layout

\begin_layout Itemize
Neke arhitekture su sposobne da fizički adresiraju veći adresni prostor
 memorije nego što mogu virtuelne adrese.
 Zbog toga u njima postoji memorija koja nije trajno mapirana u adresni
 prostor kernela.
 
\end_layout

\begin_layout Standard
Pomenuta ograničenja diktiraju postojanje tri memorijske zone u Linuxu:
 
\end_layout

\begin_layout Itemize

\family typewriter
\size small
ZONE_DMA
\family default
\size default
: sadrži stranice koje su sposobne za DMA.
 
\end_layout

\begin_layout Itemize

\family typewriter
\size small
ZONE_NORMAL
\family default
\size default
: sadrži normalne, standardno mapirane stranice.
 
\end_layout

\begin_layout Itemize

\family typewriter
\size small
ZONE_HIGHMEM
\family default
\size default
: sadrži visoku memoriju, tj.
 stranice koje nisu trajno mapirane u adresni prostor kernela.
 
\end_layout

\begin_layout Standard
Zone su definisane u zaglavlju 
\family typewriter
\size small
<linux/mmzone.h>
\family default
\size default
 u strukturi 
\family typewriter
\size small
struct zone
\family default
\size default
: 
\end_layout

\begin_layout LyX-Code

\size small
struct zone { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
spinlock_t lock; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long free_pages; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long pages_min; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long pages_low; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long pages_high; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long protection[MAX_NR_ZONES]; 
\end_layout

\begin_layout LyX-Code

\size small
spinlock_t lru_lock; 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head active_list; 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head inactive_list; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long nr_scan_active; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long nr_scan_inactive; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long nr_active; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long nr_inactive; 
\end_layout

\begin_layout LyX-Code

\size small
int all_unreclaimable; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long pages_scanned; 
\end_layout

\begin_layout LyX-Code

\size small
int temp_priority; 
\end_layout

\begin_layout LyX-Code

\size small
int prev_priority; 
\end_layout

\begin_layout LyX-Code

\size small
struct free_area free_area[MAX_ORDER]; 
\end_layout

\begin_layout LyX-Code

\size small
wait_queue_head_t *wait_table; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long wait_table_size; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long wait_table_bits; 
\end_layout

\begin_layout LyX-Code

\size small
struct per_cpu_pageset pageset[NR_CPUS]; 
\end_layout

\begin_layout LyX-Code

\size small
struct pglist_data *zone_pgdat; 
\end_layout

\begin_layout LyX-Code

\size small
struct page *zone_mem_map; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long zone_start_pfn; 
\end_layout

\begin_layout LyX-Code

\size small
char *name; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long spanned_pages; 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long present_pages;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout Standard
Struktura je velika, ali pošto postoje samo tri zone u sistemu, ima samo
 tri strukture.
 Polje 
\family typewriter
\size small
lock
\family default
\size default
 je spinlok koji štiti strukturu od konkurentnog pristupa.
 Treba obratiti pažnju da se štiti samo struktura, a ne sve stranice u zoni.
 Polje 
\family typewriter
\size small
free_pages
\family default
\size default
 je broj slobodnih stranica u zoni.
 Kernel pokušava da održi najmanje 
\family typewriter
\size small
pages_min
\family default
\size default
 stranica slobodnim (kroz zamenu, tj.
 swapping), ako je to moguće.
 Polje 
\family typewriter
\size small
name
\family default
\size default
 je string završen nulom koji predstavlja ime zone.
 Kernel inicijalizuje ovu vrednost tokom podizanja sistema (boot) u datoteci
 
\family typewriter
\size small
mm/page_alloc.c
\family default
\size default
 i daje imena zonama 
\family typewriter
\size small
"DMA"
\family default
\size default
, 
\family typewriter
\size small
"Normal"
\family default
\size default
 i 
\family typewriter
\size small
"HighMem"
\family default
\size default
.
 
\end_layout

\begin_layout Section
Učitavanje stranica 
\end_layout

\begin_layout Standard
Kernel koristi mehanizam niskog nivoa kada zahteva memoriju, zajedno sa
 nekoliko interfejsa za pristup memoriji.
 Svi interfejsi alociranja memorije sa granularnošću strane deklarisani
 su u zaglavlju 
\family typewriter
\size small
<linux/gfp.h>
\family default
\size default
.
 Glavna funkcija je:
\end_layout

\begin_layout Standard

\family typewriter
\size small
struct page * alloc_pages(unsigned int gfp_mask, unsigned int order)
\end_layout

\begin_layout Standard
Ova funkcija alocira 2
\family typewriter
\size small

\begin_inset script superscript

\begin_layout Plain Layout

\family typewriter
\size small
order
\end_layout

\end_inset


\family default
\size default
 neprekidnih fizičkih stranica (pri čemu je 
\family typewriter
\size small
order
\family default
\size default
 >> 1) i vraća pokazivač na prvu strukturu stranice 
\family typewriter
\size small
page
\family default
\size default
; ako se desi greška vraća NULL.
 Stranica može da se konvertuje u logičku adresu pomoću funkcije: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
void * page_address(struct page *page)
\end_layout

\begin_layout Standard
Ova funkcija vraća pokazivač na logičku adresu na kojoj se trenutno nalazi
 fizička stranica
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!učitavanje
\end_layout

\end_inset

.
 Ako tekuća struktura 
\family typewriter
\size small
page
\family default
\size default
 nije potrebna, može se pozvati:
\end_layout

\begin_layout Standard

\family typewriter
\size small
unsigned long __get_free_pages(unsigned int gfp_mask, unsigned int order)
\end_layout

\begin_layout Standard
Ova funkcija radi isto kao i 
\family typewriter
\size small
alloc_pages()
\family default
\size default
, osim što direktno vraća logičku adresu prve zahtevane stranice.
 Pošto su stranice susedne, druge stranice prosto slede prvu.
 Ako je potrebna samo jedna stranica, koriste se dve funkcije:
\end_layout

\begin_layout Standard

\family typewriter
\size small
struct page * alloc_page(unsigned int gfp_mask)
\end_layout

\begin_layout Standard

\family typewriter
\size small
unsigned long __get_free_page(unsigned int gfp_mask) 
\end_layout

\begin_layout Section
Oslobađanje stranica
\end_layout

\begin_layout Standard
Familija funkcija koja omogućuje oslobađanje alociranih stranica
\begin_inset Index idx
status open

\begin_layout Plain Layout
stranice!oslobađanje
\end_layout

\end_inset

 kada više nisu potrebne je:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void __free_pages(struct page *page, unsigned int order) 
\end_layout

\begin_layout Standard

\family typewriter
\size small
void free_pages(unsigned long addr, unsigned int order) 
\end_layout

\begin_layout Standard

\family typewriter
\size small
void free_page(unsigned long addr)
\end_layout

\begin_layout Standard
Prilikom oslobađanja treba biti pažljiv jer oslobađate samo stranice koje
 ste vi alocirali.
 Prosleđivanje pogrešne strukture stranice (ili adrese) ili neispravan redosled
 mogu da prouzrokuju oštećenje podataka.
 Pogledajmo primer kada želimo da alociramo osam stranica:
\end_layout

\begin_layout LyX-Code

\size small
unsigned long page;
\end_layout

\begin_layout LyX-Code

\size small
page = __get_free_pages(GFP_KERNEL, 3); 
\end_layout

\begin_layout LyX-Code

\size small
if (!page) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
/* nema dovoljno memorije: 
\end_layout

\begin_layout LyX-Code

\size small
* morate obraditi ovu gresku! */ 
\end_layout

\begin_layout LyX-Code

\size small
return ENOMEM;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
/* 'page' je sada adresa 
\end_layout

\begin_layout LyX-Code

\size small
* prve od osam uzastopnih stranica ...
 */
\end_layout

\begin_layout LyX-Code

\size small
free_pages(page, 3);
\end_layout

\begin_layout LyX-Code

\size small
/* * stranice su sada oslobodjene 
\end_layout

\begin_layout LyX-Code

\size small
* i vise ne bi trebalo  
\end_layout

\begin_layout LyX-Code

\size small
* pristupati adresi koja se
\end_layout

\begin_layout LyX-Code

\size small
* cuva u 'page' */
\end_layout

\begin_layout Standard
Parametar GFP_KERNEL je primer flega 
\family typewriter
\size small
gfp_mask
\family default
\size default
.
 Pomenute funkcije su korisne kada su potrebni delovi memorije veličine
 jedne stranice, posebno ako je potrebna tačno jedna ili dve stranice.
 Za opštije alokacije veličine bajta kernel obezbeđuje funkciju 
\family typewriter
\size small
kmalloc()
\family default
\size default
.
 
\end_layout

\begin_layout Section
Funkcija kmalloc() 
\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
\size small
kmalloc()
\family default
\size default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!kmalloc()
\end_layout

\end_inset

 radi slično rutini iz korisničkog prostora malloc(), sa izuzetkom dodatnih
 parametara.
 Funkcija 
\family typewriter
\size small
kmalloc()
\family default
\size default
 je jednostavan interfejs za dobijanje kernel memorije veličine bajtova,
 a deklarisana je u zaglavlju 
\family typewriter
\size small
<linux/slab.h>
\family default
\size default
:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void * kmalloc(size_t size, int flags)
\end_layout

\begin_layout Standard
Funkcija vraća pokazivač na oblast u memoriji koja je najmanje veličine
 
\family typewriter
\size small
size
\family default
\size default
 bajtova i koja je fizički susedna.
 Ako postoji greška, funkcija vraća NULL.
 Alokacija memorije kernelu polazi za rukom sve dok ima dovoljno slobodne
 memorije; ako je više nema, na osnovu povratne vrednosti funkcije 
\family typewriter
\size small
kmalloc()
\family default
\size default
 koja je u tom slučaju NULL treba reagovati na grešku na odgovarajući način.
 
\end_layout

\begin_layout Standard
Metod 
\family typewriter
\size small
kfree()
\family default
\size default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!kfree()
\end_layout

\end_inset

 je deklarisan u zaglavlju 
\family typewriter
\size small
<linux/slab.h>
\family default
\size default
 na sledeći način:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void kfree(const void *ptr)
\end_layout

\begin_layout Standard
Ovaj metod oslobađa blok memorije prethodno alocirane funkcijom 
\family typewriter
\size small
kmalloc()
\family default
\size default
.
 
\end_layout

\begin_layout Section
Funkcija vmalloc() 
\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
\size small
vmalloc()
\family default
\size default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!vmalloc()
\end_layout

\end_inset

 radi na sličan način kao i 
\family typewriter
\size small
kmalloc()
\family default
\size default
, osim što alocira memoriju koja je samo virtuelno susedna (nije neophodno
 da je fizički susedna).
 Strane koje vraća 
\family typewriter
\size small
malloc()
\family default
\size default
 su susedne unutar virtuelnog adresnog prostora procesora, ali nema garancije
 da su one susedne i u fizičkoj memoriji.
 Funkcija 
\family typewriter
\size small
kmalloc()
\family default
\size default
 garantuje da su strane i fizički i virtuelno susedne.
 Memorija koja se pojavljuje u kernelu je logički susedna.
 Uprkos činjenici da se fizički susedna memorija zahteva samo u određenim
 slučajevima, kôd kernela uglavnom koristi funkciju 
\family typewriter
\size small
kmalloc()
\family default
\size default
 a ne 
\family typewriter
\size small
vmalloc()
\family default
\size default
 za dobijanje memorije.
 Funkcija 
\family typewriter
\size small
vmalloc()
\family default
\size default
 se koristi samo kada je to neophodno, tj.
 za dobijanje veoma velikih regiona memorije.
 Na primer, kada se moduli dinamički učitavaju u kernel, oni se učitavaju
 u memoriju kreiranu pomoću funkcije 
\family typewriter
\size small
vmalloc()
\family default
\size default
.
 Ova funkcija postiže slabije rezultate pri radu sa TLB-om.
 TLB (translation lookaside buffer) je hardverski keš koji koriste mnoge
 arhitekture da bi keširale mapiranje virtuelnih adresa u fizičke adrese.
 Pošto se većina pristupa memoriji obavlja preko virtuelnog adresiranja,
 time se poboljšavaju karakteristike sistema.
 Funkcija 
\family typewriter
\size small
vmalloc()
\family default
\size default
 je deklarisana u zaglavlju 
\family typewriter
\size small
<linux/vmalloc.h>
\family default
\size default
 i definisana u 
\family typewriter
\size small
mm/vmalloc.c
\family default
\size default
.
 Koristi se isto kao C funkcija 
\family typewriter
\size small
malloc()
\family default
\size default
 iz korisničkog prostora:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void * vmalloc(unsigned long size)
\end_layout

\begin_layout Standard
Funkcija vraća pokazivač na najmanje 
\family typewriter
\size small
size
\family default
\size default
 bajtova virtuelnog susednog prostora u memoriji.
 U slučaju greške, funkcija vraća NULL.
 Funkcija može da „spava“ i tada ne može biti pozvana iz konteksta prekida
 ili iz drugih situacija u kojima blokiranje nije dozvoljeno.
 Za oslobađanje memorije dobijene preko funkcije 
\family typewriter
\size small
vmalloc()
\family default
\size default
 koristi se funkcija 
\family typewriter
\size small
vfree()
\family default
\size default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!vfree()
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void vfree(void *addr)
\end_layout

\begin_layout Standard
Ova funkcija oslobađa blok memorije koji počinje na adresi 
\family typewriter
\size small
addr
\family default
\size default
.
 Funkcija takođe može da „spava“ i tada ne može biti pozvana iz konteksta
 prekida.
 Korišćenje funkcije je veoma jednostavno: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
char *buf;
\end_layout

\begin_layout Standard

\family typewriter
\size small
buf = vmalloc(16 * PAGE_SIZE); 
\end_layout

\begin_layout Standard

\family typewriter
\size small
/* get 16 pages */ 
\end_layout

\begin_layout Standard

\family typewriter
\size small
if (!buf) /* error! failed to allocate memory */
\end_layout

\begin_layout Standard

\family typewriter
\size small
/* * buf now points to at least a 16*PAGE_SIZE bytes 
\end_layout

\begin_layout Standard

\family typewriter
\size small
* of virtually contiguous block of memory */ 
\end_layout

\begin_layout Standard
Nakon završetka korišćenja, memoriju treba osloboditi pozivom funkcije 
\family typewriter
\size small
vfree(buf)
\family default
\size default
.
\end_layout

\begin_layout Section
Statičko alociranje na steku 
\end_layout

\begin_layout Standard
U korisničkom prostoru moguće je alocirati prostor na steku
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!statičko alociranje na steku
\end_layout

\end_inset

 zato što je veličina prostora koji treba da bude alociran poznata unapred.
 Stek kernela je mali i fiksne veličine.
 Kada se svakom procesu dodeli mali stek fiksne veličine, potrošnja memorije
 se minimizira, a kernel se ne opterećuje kôdom koji upravlja radom steka.
 Veličina steka kernela po procesu zavisi od arhitekture i opcija definisanih
 u vreme kompajliranja operativnog sistema.
 Pre verzije 2.6 kernela, veličina kernel steka je bila dve stranice po procesu
 (obično 8KB za 32-bitnu arhitekturu, odnosno 16KB za 64-bitnu arhitekturu
 zato što su veličine strana 4KB i 8KB, redom).
 Počev od verzije kernela 2.6, stek se postavlja na jednu stranu, i to iz
 dva razloga.
 Prvo, procesi troše malo strana.
 Drugi, važniji razlog je to što sa povećanjem vremena rada postaje veoma
 teško pronaći dve fizički susedne nealocirane strane.
 Fizička memorija postaje fragmentirana, pa alokacija usamljenog novog procesa
 virtuelne mašine postaje veoma skupa.
 Tada se uvode stekovi prekida koji obezbeđuju stek za upravljače prekida
 jednog procesora; takvi stekovi više ne dele kernel stek prekinutog procesa
 već imaju sopstvene stekove.
\end_layout

\begin_layout Section
Mapiranje stranica u memoriji sa velikim adresama 
\end_layout

\begin_layout Standard
Stranice u memoriji na višim adresama ne moraju da budu stalno mapirane
 u adresni prostor kernela.
 To znači da stranice dobijene preko funkcije 
\family typewriter
\size small
alloc_pages()
\family default
\size default
 sa flegom 
\family typewriter
\size small
__GFP_HIGHMEM
\family default
\size default
 možda nemaju logičku adresu.
 U arhitekturi x86 cela fizička memorija iznad 896MB je visoka memorija
 i nije stalno niti automatski mapirana u adresni prostor kernela, uprkos
 tome što su x86 procesori sposobni da fizički adresiraju vrednosti adresa
 iznad 4GB fizičke memorije.
 Nakon alociranja, stranica mora da bude mapirana u logički adresni prostor
 kernela.
 U arhitekturi x86, stranice u visokoj memoriji su mapirane negde između
 3 i 4GB.
\end_layout

\begin_layout Standard
Za mapiranje strukture stranice u adresni prostor kernela koristi se funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!kmap()
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size small
void *kmap(struct page *page)
\end_layout

\begin_layout Standard
Ova funkcija radi ili u visokoj ili niskoj
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!niska
\end_layout

\end_inset

 memoriji
\begin_inset Index idx
status open

\begin_layout Plain Layout
memorija!visoka
\end_layout

\end_inset

.
 Ako struktura strane pripada strani u niskoj memoriji, funkcija vraća virtuelnu
 adresu strane.
 Ako se strana nalazi u visokoj memoriji, mapiranje je trajno i funkcija
 vraća adresu.
 Funkcija može da 
\begin_inset Quotes eld
\end_inset

spava
\begin_inset Quotes erd
\end_inset

; tada 
\family typewriter
\size small
kmap()
\family default
\size default
 radi samo u kontekstu procesa.
 Pošto je broj trajnih mapiranja ograničen, visoka memorija ne treba da
 bude mapirana kada više nije potrebna.
 To se postiže preko funkcije
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!kunmap()
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size small
void kunmap(struct page *page)
\end_layout

\begin_layout Standard
Kada treba obaviti mapiranje, ali tekući kontekst nije u mogućnosti da 
\begin_inset Quotes eld
\end_inset

spava
\begin_inset Quotes erd
\end_inset

, kernel obezbeđuje privremeno mapiranje (koje se takođe zove i nedeljivo
 mapiranje).
 Radi se o skupu rezervnih mapiranja za privremene svrhe.
 Kenel može nedeljivo da mapira stranicu u visokoj memoriji u neko rezervisano
 mapiranje.
 Privremeno mapiranje dakle može da se koristi u slučajevima kada nema 
\begin_inset Quotes eld
\end_inset

spavanja
\begin_inset Quotes erd
\end_inset

, npr.
 za upravljače prekida, zato što mapiranje ne može da bude blokirano.
 Privremeno mapiranje postiže se funkcijom
\end_layout

\begin_layout Standard

\family typewriter
\size small
void *kmap_atomic(struct page *page, enum km_type type)
\end_layout

\begin_layout Standard
Parametar 
\family typewriter
\size small
type
\family default
\size default
 je nabrajanje koje opisuje svrhu privremenog mapiranja i definisano je
 u zaglavlju 
\family typewriter
\size small
<asm/kmap_types.h>
\family default
\size default
.
 Ova funkcija ne blokira, pa može da se koristi u kontekstu prekida i za
 druge slučajeve gde nema ponovnog raspoređivanja.
 Ona onemogućuje i prinudnu suspenziju kernela, što je važno zato što je
 mapiranje jedinstveno za svaki procesor.
 Ponovno raspoređivanje moglo bi da promeni redosled izvršavanja zadataka
 u različitim procesorima.
 Mapiranje se poništava na sledeći način:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void kunmap_atomic(void *kvaddr, enum km_type type)
\end_layout

\begin_layout Subsection
Koji alokacioni metod iskoristiti? 
\end_layout

\begin_layout Standard
Ako su potrebne neprekidne fizičke stranice, treba upotrebiti neki alokator
 stranica niskog nivoa ili 
\family typewriter
\size small
kmalloc()
\family default
\size default
.
 To je standardan način alociranja memorije unutar kernela.
 Ako treba alocirati stranice iz više memorije, upotrebite 
\family typewriter
\size small
alloc_pages()
\family default
\size default
.
 Funkcija 
\family typewriter
\size small
alloc_pages()
\family default
\size default
 vraća strukturu stranice, a ne pokazivač na logičku adresu.
 Pošto visoka memorija možda nije mapirana, jedini način da joj se pristupi
 može biti preko odgovarajuće strukture stranice.
 Da biste dobili stvarni pokazivač, koristite 
\family typewriter
\size small
kmap()
\family default
\size default
 za mapiranje visoke memorije u logički adresni prostor kernela.
 Ako nisu potrebne fizičke susedne stranice, već samo virtuelno susedne,
 treba upotrebiti 
\family typewriter
\size small
vmalloc()
\family default
\size default
, mada uvek treba imati na umu slabe karakteristike funkcije 
\family typewriter
\size small
vmalloc()
\family default
\size default
 u poređenju sa funkcijom 
\family typewriter
\size small
kmalloc()
\family default
\size default
.
 Funkcija 
\family typewriter
\size small
vmalloc()a
\family default
\size default
locira kao u korisničkom prostoru, mapirajući velike delove fizičke memorije
 u susedni logički adresni prostor.
 
\end_layout

\begin_layout Chapter
Virtuelni sistem datoteka
\end_layout

\begin_layout Standard
Virtuelni sistem datoteka (Virtual File System, VFS) je podsistem kernela
 koji implementira interfejse sistema datoteka za programe korisničkog prostora.
 Svi sistemi datoteka se oslanjaju na VFS da bi im se dozvolilo ne samo
 da postoje, nego i da sarađuju.
 To omogućuje programima da koriste standardne UNIX sistemske pozive 
\family typewriter
read()
\family default
 i 
\family typewriter
write()
\family default
 za različite sisteme datoteka na različitim medijumima, kao što je prikazano
 na slici 15.1.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko12.png
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 15.1: Virtuelni sistem datoteka: Korišćenje cp(1) karakteristika za
 premeštanje podataka sa diska sa sistemom ext3 na prenosivi disk sa sistemom
 ext2 (dva različita sistema datoteka, dva različita medijuma i jedan VFS).
\end_layout

\begin_layout Section
Interfejs sistema datoteka
\end_layout

\begin_layout Standard
Virtuelni sistem datoteka je “lepak” koji omogućuje sistemskim pozivima
 kao što su 
\family typewriter
open()
\family default
, 
\family typewriter
read()
\family default
 i 
\family typewriter
write()
\family default
 da rade bez obzira na sistem datoteka koji se koristi ili na fizički medijum.
 Moderni operativni sistemi apstrahuju pristup sistemima datoteka preko
 virtuelnog interfejsa koji omogućuje saradnju i uopšten pristup.
 
\end_layout

\begin_layout Standard
Opšti interfejs za bilo koji tip sistema datoteka je ostvarljiv samo zato
 što sâm kernel primenjuje sloj apstrakcije oko svog interfejsa sistema
 datoteka niskog nivoa.
 Taj sloj apstrakcije omogućuje Linuxu podršku za različite sisteme datoteka,
 čak i ako se oni veoma razlikuju u podržanim karakteristikama ili ponašanju.
 Kao primer, razmotrimo izvršenje programa u korisničkom prostoru:
\end_layout

\begin_layout Standard

\family typewriter
write(f, &buf, len);
\end_layout

\begin_layout Standard
Ova naredba upisuje 
\family typewriter
len
\family default
 bajtova na koje pokazuje pokazivač 
\family typewriter
buf
\family default
 u tekuću poziciju u datoteci predstavljenoj deskriptorom 
\family typewriter
f
\family default
.
 Ovim sistemskim pozivom prvo rukuje generički sistemski poziv 
\family typewriter
sys_write()
\family default
 koji određuje aktuelni metod upisivanja u datoteku u sistemu datoteka u
 kome se nalazi 
\family typewriter
f
\family default
.
 Generički sistemski poziv za upis tada poziva ovaj metod da upiše podatke
 na medijum, što je deo implementacije sistema datoteka.
 Na Slici 15.2 prikazan je dijagram toka od korisničkog poziva 
\family typewriter
write()
\family default
 preko podataka do fizičkog medijuma.
 Sa jedne strane sistemskog poziva je generički VFS interfejs, koji obezbeđuje
 vezu ka korisničkom prostoru; sa druge strane sistemskog poziva je deo
 sistema datoteka koji se bavi implementacijom detalja.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Ranko13.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 15.2: Tok podataka od korisničkog prostora iz koga se izdaje sistemski
 poziv 
\family typewriter
write()
\family default
, kroz generički poziv virtuelnog sistema datoteka (VFS), preko specifičnog
 metoda 
\family typewriter
write()
\family default
 sistema datoteka do fizičkog medijuma.
\end_layout

\begin_layout Section
UNIX sistem datoteka
\end_layout

\begin_layout Standard
UNIX obezbeđuje četiri osnovne apstrakcije u odnosu na sistem datoteka:
 datoteke, direktorijumske upise, inode i tačke montiranja.
 Sistemi datoteka sadrže datoteke, direktorijume i pridružene kontrolne
 informacije.
 Tipične operacije u sistemu su kreiranje, brisanje i montiranje datoteka
 i direktorijuma.
 U UNIX-u, sistemi datoteka su montirani u određenim tačkama globalne hijerarhij
e, poznatim kao prostor imena.
 To omogućuje da se svi montirani sistemi datoteka prikažu kao upisi u prostom
 stablu.
 Datoteka je uređeni niz, tj.
 string bajtova.
 Prvi bajt označava početak datoteke, a poslednji bajt označava njen kraj.
 Svakoj datoteci je pridruženo ime za identifikaciju i sistema i korisnika.
 Tipične operacije sa datotekom su čitanje (read), upis (write), kreiranje
 (create) i brisanje (delete).
 Datoteke su organizovane u direktorijume, koji mogu da sadrže poddirektorijume.
 Direktorijumi mogu biti ugnježđeni čime se formiraju putanje.
 Svaka komponenta putanje zove se unos direktorijuma (directory entry).
 Primer putanje je 
\family typewriter
/home/korisnik/ime_datoteke
\family default
; u ovom slučaju korenski (root) direktorijum je /, direktorijumi 
\family typewriter
home
\family default
 i 
\family typewriter
korisnik
\family default
 i datoteka 
\family typewriter
ime_datoteke
\family default
 su unosi direktorijuma nazvani 
\series bold
dentry
\series default
 (skraćenica od directory entry).
 UNIX direktorijumi su zapravo standardne datoteke koje sadrže listu datoteka
 u tom direktorijumu i sa njima se mogu obavljati iste operacije se kao
 sa datotekama.
 Informacije o datoteci kao što su dozvole pristupa, veličina, vlasništvo,
 vreme kreiranja itd.
 nazivaju se metapodacima (metadata) i smeštaju se u posebne strukture zvane
 
\series bold
inode
\series default
 (skraćenica od index node).
 Sve te informacije zajedno sa kontrolnim informacijama sistema datoteka
 nalaze se u superbloku.
 To je struktura podataka koja sadrži informacije o sistemu datoteka kao
 celini.
 
\end_layout

\begin_layout Standard
Linux podržava brojne sisteme datoteka (preko 50 u zvaničnoj verziji kernela),
 od izvornih kao što su ext2 i ext3, do mrežnih sistema datoteka (kao što
 su NFS i Coda).
 VFS sloj obezbeđuje sistemima datoteka radno okruženje za primenu i interfejs
 za rad sa standardnim sistemskim pozivima.
 
\end_layout

\begin_layout Section
Objekti sistema datoteka i njihove strukture podataka
\end_layout

\begin_layout Standard
VFS je objektno orijentisan.
 Familija struktura podataka predstavlja zajednički model datoteke.
 Ove strukture podataka su slične objektima.
 Pošto je kernel programiran u jeziku C, bez pogodnosti jezika koji su objektno
 orijentisani, strukture podataka su predstavljene kao C strukture.
 Strukture sadrže i podatke i pokazivače na funkcije implementirane u sistemu
 datoteka.
 Četiri osnovna tipa VFS objekata su: 
\end_layout

\begin_layout Itemize
superblok (određena montirana datoteka sistema)
\end_layout

\begin_layout Itemize
inode (predstavlja određenu datoteku)
\end_layout

\begin_layout Itemize
dentry (unos u direktorijum, tj.
 prosta komponenta putanje)
\end_layout

\begin_layout Itemize
otvorena datoteka pridružena procesu
\end_layout

\begin_layout Standard
Pošto VFS tretira direktorijume kao standardne datoteke, ne postoji objekat
 direktorijum.
 Svaki objekat nalazi se unutar nekog od prethodno navedenih primarnih objekata.
 Najvažniji primarni objekti za koje kernel poziva određene metode su:
\end_layout

\begin_layout Itemize
super_operations (sadrži metode koje kernel može da pozove u specifičnom
 sistemu datoteka, npr.
 
\family typewriter
read_inode()
\family default
 i 
\family typewriter
sync_fs()
\family default
) 
\end_layout

\begin_layout Itemize
inode_operations (sadrži metode koje kernel može da pozove u specifičnoj
 datoteci, npr.
 
\family typewriter
create()
\family default
 i 
\family typewriter
link()
\family default
)
\end_layout

\begin_layout Itemize
dentry_operations (sadrži metode koje kernel može da pozove za određen dentry,
 npr.
 
\family typewriter
d_compare()
\family default
 i 
\family typewriter
d_delete()
\family default
)
\end_layout

\begin_layout Itemize
file (sadrži metode koje proces može da pozove za otvorenu datoteku, npr.
 
\family typewriter
read()
\family default
 i 
\family typewriter
write()
\family default
).
\end_layout

\begin_layout Standard
Primarni objekti su implementirani kao strukture pokazivača na funkcije
 koje rade sa roditeljskim objektom.
 Za mnoge metode objekti mogu da naslede generičku funkciju ako je njena
 osnovna funkcionalnost dovoljna.
 U suprotnom, specifična instanca određenog sistema datoteka dopunjuje pokazivač
e njihovim metodama specifičnim za taj sistem datoteka.
 Objekti povezani sa strukturama nisu standardni objekti, poput onih u jezicima
 C++ ili Java.
 Ove strukture predstavljaju određene instance objekata, njihovih pridruženih
 podataka i metoda koji rade sa njima.
 
\end_layout

\begin_layout Standard
Svaki registrovani sistem datoteka je predstavljen strukturom 
\family typewriter
file_system_type
\family default
.
 Ovaj objekat opisuje sistem datoteka i njegove mogućnosti.
 Svaka tačka montiranja je predstavljena strukturom 
\family typewriter
vfsmount
\family default
.
 Strukture koje opisuju sistem datoteka i datoteke pridružene svakom procesu
 su: 
\family typewriter
file_struct
\family default
, 
\family typewriter
fs_struct
\family default
 i 
\family typewriter
namespace
\family default
.
 
\end_layout

\begin_layout Section
Objekat superblok
\end_layout

\begin_layout Standard
Svaki sistem datoteka implementira objekat superblok i u njemu čuva informacije
 koje ga opisuju.
 Ovaj objekat obično odgovara superbloku ili kontrolnom bloku sistema datoteka
 koji je smešten u specijalnom sektoru na disku.
 Objekat superblok je predstavljen strukturom 
\family typewriter
super_block
\family default
 i definisan u zaglavlju 
\family typewriter
<linux/fs.h>
\family default
.
 Sledi njegov kôd: 
\end_layout

\begin_layout LyX-Code

\size small
struct super_block { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct list_head s_list; /* list of all superblocks */ 
\end_layout

\begin_layout LyX-Code

\size small
dev_t s_dev; /* identifier */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long s_blocksize; /* block size in bytes */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long s_old_blocksize; /* old block size in bytes */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned char s_blocksize_bits; /* block size in bits */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned char s_dirt; /* dirty flag */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long long s_maxbytes; /* max file size */ 
\end_layout

\begin_layout LyX-Code

\size small
struct file_system_type s_type; /* filesystem type */ 
\end_layout

\begin_layout LyX-Code

\size small
struct super_operations s_op; /* superblock methods */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dquot_operations *dq_op; /* quota methods */ 
\end_layout

\begin_layout LyX-Code

\size small
struct quotactl_ops *s_qcop; /* quota control methods */ 
\end_layout

\begin_layout LyX-Code

\size small
struct export_operations *s_export_op; /* export methods */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long s_flags; /* mount flags */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long s_magic; /* filesystem's magic number */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry *s_root; /* directory mount point */ 
\end_layout

\begin_layout LyX-Code

\size small
struct rw_semaphore s_umount; /* unmount semaphore */ 
\end_layout

\begin_layout LyX-Code

\size small
struct semaphore s_lock; /* superblock semaphore */ 
\end_layout

\begin_layout LyX-Code

\size small
int s_count; /* superblock ref count */ 
\end_layout

\begin_layout LyX-Code

\size small
int s_syncing; /* filesystem syncing flag */ 
\end_layout

\begin_layout LyX-Code

\size small
int s_need_sync_fs; /* not-yet-synced flag */ 
\end_layout

\begin_layout LyX-Code

\size small
atomic_t s_active; /* active reference count */ 
\end_layout

\begin_layout LyX-Code

\size small
void *s_security; /* security module */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head s_dirty; /* list of dirty inodes */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head s_io; /* list of writebacks */ 
\end_layout

\begin_layout LyX-Code

\size small
struct hlist_head s_anon; /* anonymous dentries */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head s_files; /* list of assigned files */ 
\end_layout

\begin_layout LyX-Code

\size small
struct block_device *s_bdev; /* associated block device */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head s_instances; /* instances of this fs */ 
\end_layout

\begin_layout LyX-Code

\size small
struct quota_info s_dquot; /* quota-specific options */ 
\end_layout

\begin_layout LyX-Code

\size small
char s_id[32]; /* text name */ 
\end_layout

\begin_layout LyX-Code

\size small
void *s_fs_info; /* filesystem-specific info */ 
\end_layout

\begin_layout LyX-Code

\size small
struct semaphore s_vfs_rename_sem; /* rename semaphore */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout Standard
Kôd za kreiranje, upravljanje i uništavanje superblokova nalazi se u datoteci
 
\family typewriter
fs/super.c
\family default
.
 Objekat superblok se kreira i inicijalizuje pomoću funkcije 
\family typewriter
alloc_super()
\family default
.
\end_layout

\begin_layout Subsection
Operacije sa superblokom
\end_layout

\begin_layout Standard
Najvažniji član u objektu superblok je 
\family typewriter
s_op
\family default
; to je zapravo tabela operacija sa superblokom, predstavljena strukturom
 
\family typewriter
super_operations
\family default
 i definisana u zaglavlju 
\family typewriter

\begin_inset Newline linebreak
\end_inset

<linux/fs.h>
\family default
.
 Sledi njen kôd: 
\end_layout

\begin_layout LyX-Code

\size small
struct super_operations { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct inode *(*alloc_inode) (struct super_block *sb); 
\end_layout

\begin_layout LyX-Code

\size small
void (*destroy_inode) (struct inode *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*read_inode) (struct inode *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*dirty_inode) (struct inode *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*write_inode) (struct inode *, int); 
\end_layout

\begin_layout LyX-Code

\size small
void (*put_inode) (struct inode *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*drop_inode) (struct inode *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*delete_inode) (struct inode *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*put_super) (struct super_block *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*write_super) (struct super_block *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*sync_fs) (struct super_block *, int); 
\end_layout

\begin_layout LyX-Code

\size small
void (*write_super_lockfs) (struct super_block *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*unlockfs) (struct super_block *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*statfs) (struct super_block *, struct statfs *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*remount_fs) (struct super_block *, int *, char *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*clear_inode) (struct inode *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*umount_begin) (struct super_block *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*show_options) (struct seq_file *, struct vfsmount *); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout Standard
Svaki član ove strukture je pokazivač na funkciju koja radi sa superblok
 objektom.
 Operacije sa superblokom su operacije niskog nivoa i izvršavaju se u sistemu
 datoteka i njegovim inodovima.
 U nastavku je nabrojano nekoliko operacija sa superblokom koje rade sa
 strukturom 
\family typewriter
super_operations
\family default
:
\end_layout

\begin_layout Itemize

\family typewriter
struct inode * alloc_inode(struct super_block *sb)
\family default
: funkcija koja kreira i inicijalizuje novi inode objekat pod datim superblokom.
 
\end_layout

\begin_layout Itemize

\family typewriter
void destroy_inode(struct inode *inode)
\family default
: funkcija koja dealocira dati inode.
 
\end_layout

\begin_layout Itemize

\family typewriter
void read_inode(struct inode *inode)
\family default
: funkcija koja čita datoteku inode određenu sa inode->i_ino sa diska i
 popunjava ostatak strukture inode.
 
\end_layout

\begin_layout Itemize

\family typewriter
void dirty_inode(struct inode *inode)
\family default
: funkcija koju poziva VFS kada je inode „prljav“ (modifikovan).
 
\end_layout

\begin_layout Standard
Sve pomenute funkcije se pozivaju u virtuelnom sistemu datoteka u kontekstu
 procesa i mogu se po potrebi blokirati.
 
\end_layout

\begin_layout Section
Objekat inode
\end_layout

\begin_layout Standard
Objekat inode predstavlja sve informacije koje su kernelu potrebne za rad
 sa datotekom ili direktorijumom.
 Za UNIX-olike sisteme datoteka, informacija se dobija čitanjem inoda sa
 diska.
 Objekat inode je predstavljen strukturom 
\family typewriter
inode
\family default
 i definisan u zaglavlju 
\family typewriter
<linux/fs.h>
\family default
: 
\end_layout

\begin_layout LyX-Code

\size small
struct inode { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct hlist_node i_hash; /* hash list */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head i_list; /* list of inodes */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head i_dentry; /* list of dentries */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long i_ino; /* inode number */ 
\end_layout

\begin_layout LyX-Code

\size small
atomic_t i_count; /* reference counter */ 
\end_layout

\begin_layout LyX-Code

\size small
umode_t i_mode; /* access permissions */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned int i_nlink; /* number of hard links */ 
\end_layout

\begin_layout LyX-Code

\size small
uid_t i_uid; /* user id of owner */ 
\end_layout

\begin_layout LyX-Code

\size small
gid_t i_gid; /* group id of owner */ 
\end_layout

\begin_layout LyX-Code

\size small
kdev_t i_rdev; /* real device node */ 
\end_layout

\begin_layout LyX-Code

\size small
loff_t i_size; /* file size in bytes */ 
\end_layout

\begin_layout LyX-Code

\size small
struct timespec i_atime; /* last access time */ 
\end_layout

\begin_layout LyX-Code

\size small
struct timespec i_mtime; /* last modify time */ 
\end_layout

\begin_layout LyX-Code

\size small
struct timespec i_ctime; /* last change time */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned int i_blkbits; /* block size in bits */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long i_blksize; /* block size in bytes */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long i_version; /* version number */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long i_blocks; /* file size in blocks */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned short i_bytes; /* bytes consumed */ 
\end_layout

\begin_layout LyX-Code

\size small
spinlock_t i_lock; /* spinlock */ 
\end_layout

\begin_layout LyX-Code

\size small
struct rw_semaphore i_alloc_sem; /* nests inside of i_sem */ 
\end_layout

\begin_layout LyX-Code

\size small
struct semaphore i_sem; /* inode semaphore */ 
\end_layout

\begin_layout LyX-Code

\size small
struct inode_operations *i_op; /* inode ops table */ 
\end_layout

\begin_layout LyX-Code

\size small
struct file_operations *i_fop; /* default inode ops */ 
\end_layout

\begin_layout LyX-Code

\size small
struct super_block *i_sb; /* associated superblock */ 
\end_layout

\begin_layout LyX-Code

\size small
struct file_lock *i_flock; /* file lock list */ 
\end_layout

\begin_layout LyX-Code

\size small
struct address_space *i_mapping; /* associated mapping */ 
\end_layout

\begin_layout LyX-Code

\size small
struct address_space i_data; /* mapping for device */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dquot *i_dquot[MAXQUOTAS]; /* disk quotas for inode */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head i_devices; /* list of block devices */ 
\end_layout

\begin_layout LyX-Code

\size small
struct pipe_inode_info *i_pipe; /* pipe information */ 
\end_layout

\begin_layout LyX-Code

\size small
struct block_device *i_bdev; /* block device driver */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long i_dnotify_mask; /* directory notify mask */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dnotify_struct *i_dnotify; /* dnotify */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long i_state; /* state flags */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long dirtied_when; /* first dirtying time */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned int i_flags; /* filesystem flags */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned char i_sock; /* is this a socket? */ 
\end_layout

\begin_layout LyX-Code

\size small
atomic_t i_writecount; /* count of writers */ 
\end_layout

\begin_layout LyX-Code

\size small
void *i_security; /* security module */
\end_layout

\begin_layout LyX-Code

\size small
__u32 i_generation; /* inode version number */ 
\end_layout

\begin_layout LyX-Code

\size small
union { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
void *generic_ip; /* filesystem-specific info */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} u; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout Subsection
Operacije sa inodom
\end_layout

\begin_layout Standard
Kao u slučaju operacija sa superblokom, član 
\family typewriter
\size small
inode_operations
\family default
\size default
 je veoma važan.
 On opisuje implementirane funkcije sistema datoteka koje VFS može da pozove
 za inode.
 Inode operacije se pozivaju na sledeći način:
\end_layout

\begin_layout Standard

\family typewriter
\size small
i->i_op->truncate(i)
\end_layout

\begin_layout Standard
gde je 
\family typewriter
\size small
i
\family default
\size default
 referenca na određeni inode.
 U ovom slučaju za dati inode poziva se operacija 
\family typewriter
\size small
truncate()
\family default
\size default
 definisana za sistem datoteka u kome postoji 
\family typewriter
\size small
i
\family default
\size default
.
 Struktura
\begin_inset Newline linebreak
\end_inset

 
\family typewriter
\size small
inode_operations
\family default
\size default
 je definisana u zaglavlju 
\family typewriter
\size small
<linux/fs.h>
\family default
\size default
: 
\end_layout

\begin_layout LyX-Code

\size small
struct inode_operations { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int (*create) (struct inode *, struct dentry *,int); 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry * (*lookup) (struct inode *, struct dentry *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*link) (struct dentry *, struct inode *, struct dentry *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*unlink) (struct inode *, struct dentry *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*symlink) (struct inode *, struct dentry *, const char *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*mkdir) (struct inode *, struct dentry *, int); 
\end_layout

\begin_layout LyX-Code

\size small
int (*rmdir) (struct inode *, struct dentry *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*mknod) (struct inode *, struct dentry *, int, dev_t); 
\end_layout

\begin_layout LyX-Code

\size small
int (*rename) (struct inode *, struct dentry *, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct inode *, struct dentry *); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
int (*readlink) (struct dentry *, char *, int); 
\end_layout

\begin_layout LyX-Code

\size small
int (*follow_link) (struct dentry *, struct nameidata *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*put_link) (struct dentry *, struct nameidata *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*truncate) (struct inode *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*permission) (struct inode *, int); 
\end_layout

\begin_layout LyX-Code

\size small
int (*setattr) (struct dentry *, struct iattr *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*getattr) (struct vfsmount *, struct dentry *, struct kstat *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*setxattr) (struct dentry *, const char *, const void *, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
size_t, int); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t); 
\end_layout

\begin_layout LyX-Code

\size small
ssize_t (*listxattr) (struct dentry *, char *, size_t); 
\end_layout

\begin_layout LyX-Code

\size small
int (*removexattr) (struct dentry *, const char *); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Virtuelni sistem datoteka između ostalih nudi i sledeće funkcije za inode:
\end_layout

\begin_layout Itemize

\family typewriter
\size small
int create(struct inode *dir, struct dentry *dentry, int mode)
\family default
\size default
: VFS poziva ovu funkciju iz sistemskih poziva 
\family typewriter
\size small
create()
\family default
\size default
 i 
\family typewriter
\size small
open()
\family default
\size default
 za kreiranje novog inoda pridruženog objektu dentry u zadatom početnom
 režimu.
\end_layout

\begin_layout Itemize

\family typewriter
\size small
struct dentry * lookup(struct inode *dir, struct dentry *dentry)
\family default
\size default
: funkcija koja pretražuje direktorijum za jedan inode prema imenu datoteke
 zadatom u dentry.
\end_layout

\begin_layout Itemize

\family typewriter
\size small
int link(struct dentry *old_dentry, struct inode *dir, 
\begin_inset Newline linebreak
\end_inset

struct dentry *dentry)
\family default
\size default
: funkcija koja se poziva sistemskim pozivom 
\family typewriter
\size small
link()
\family default
\size default
 za kreiranje hard linka do datoteke 
\family typewriter
\size small
old_dentry
\family default
\size default
 u direktorijumu 
\family typewriter
\size small
dir
\family default
\size default
 sa novim imenom datoteke dentry.
 
\end_layout

\begin_layout Section
Objekat dentry
\end_layout

\begin_layout Standard
Već smo saznali da virtuelni sistem datoteka tretira direktorijume kao datoteke.
 U putanji 
\family typewriter
/bin/vi
\family default
, 
\family typewriter
bin
\family default
 i 
\family typewriter
vi
\family default
 su datoteke; 
\family typewriter
bin
\family default
 je specijalna datoteka direktorijum, a 
\family typewriter
vi
\family default
 je standardna datoteka.
 Objekat inode predstavlja obe ove komponente.
 VFS koristi koncept stavki direktorijuma (directory entry, dentry).
 To su određene komponente putanje kao i sama datoteka.
 Koristeći prethodni primer, 
\family typewriter
/
\family default
, 
\family typewriter
bin
\family default
 i 
\family typewriter
vi
\family default
 su dentry objekti.
 Objekti dentry su predstavljeni strukturom 
\family typewriter
dentry
\family default
 i definisani u zaglavlju 
\family typewriter
<linux/dcache.h>
\family default
.
 Sledi struktura sa komentarima koji opisuju svaki član: 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
atomic_t d_count; /* usage count */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long d_vfs_flags; /* dentry cache flags */ 
\end_layout

\begin_layout LyX-Code

\size small
spinlock_t d_lock; /* per-dentry lock */ 
\end_layout

\begin_layout LyX-Code

\size small
struct inode *d_inode; /* associated inode */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head d_lru; /* unused list */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head d_child; /* list of dentries within */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head d_subdirs; /* subdirectories */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head d_alias; /* list of alias inodes */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long d_time; /* revalidate time */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry_operations *d_op; /* dentry operations table */ 
\end_layout

\begin_layout LyX-Code

\size small
struct super_block *d_sb; /* superblock of file */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned int d_flags; /* dentry flags */ 
\end_layout

\begin_layout LyX-Code

\size small
int d_mounted; /* is this a mount point? */ 
\end_layout

\begin_layout LyX-Code

\size small
void *d_fsdata; /* filesystem-specific data */ 
\end_layout

\begin_layout LyX-Code

\size small
struct rcu_head d_rcu; /* RCU locking */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dcookie_struct *d_cookie; /* cookie */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry *d_parent; /* dentry object of parent */ 
\end_layout

\begin_layout LyX-Code

\size small
struct qstr d_name; /* dentry name */ 
\end_layout

\begin_layout LyX-Code

\size small
struct hlist_node d_hash; /* list of hash table entries */ 
\end_layout

\begin_layout LyX-Code

\size small
struct hlist_head *d_bucket; /* hash bucket */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned char d_iname[DNAME_INLINE_LEN_MIN]; /* short name */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Ispravan objekat dentry može biti u jednom od sledećih stanja: korišćen,
 neiskorišćen ili negativan.
 Objekat dentry može biti i oslobođen, tj.
 nalaziti se kao objekat u kešu, kada ne postoji validna referenca na objekat
 dentry u bilo kom virtuelnom sistemu datoteka niti bilo gde u kôdu sistema
 datoteka.
\end_layout

\begin_layout Standard
Kernel kešira dentry objekat u dentry keš (dcache).
 Dentry keš se sastoji od tri dela: 
\end_layout

\begin_layout Itemize
Liste "korišćenih" dentrija povezanih sa pridruženim inodom preko polja
 
\family typewriter
i_dentry
\family default
 objekta inode.
 Pošto dati inode može da ima više linkova, može biti više dentry objekata,
 pa se koristi lista.
 
\end_layout

\begin_layout Itemize
Dvostruko ulančane liste najmanje korišćenih (least recently used, LRU)
 i negativnih dentry objekata.
 Lista je sa umetanjem i sortirana po vremenu, tj.
 upisi na početku liste su noviji.
 Kada kernel mora da ukloni upise da bi oslobodio memoriju, upisi se uklanjaju
 sa liste sa kraja, jer se tu nalaze najstariji upisi za koje je najmanje
 verovatno da će se koristiti u bliskoj budućnosti 
\end_layout

\begin_layout Itemize
Heš tabele u kojoj se funkcije heširanja koriste za brzo rešavanje date
 putanje u pridruženom dentry objektu.
 Tabele su predstavljene nizom 
\family typewriter
dentry_hashtable
\family default
.
 Svaki elemenat je pokazivač na listu upisa (dentries) koji heširaju istu
 vrednost.
 Veličina ovog niza zavisi od količine fizičke RAM memorije u sistemu.
 
\end_layout

\begin_layout Subsection
Operacije sa objektom dentry
\end_layout

\begin_layout Standard
Struktura 
\family typewriter
dentry_operations
\family default
 zadaje metode koje VFS poziva za stavke direktorijuma (dentry) u datom
 sistemu datoteka.
 Struktura 
\family typewriter
dentry_operations
\family default
 je definisana u zaglavlju 
\family typewriter
<linux/dcache.h>
\family default
:
\end_layout

\begin_layout LyX-Code

\size small
struct dentry_operations { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int (*d_revalidate) (struct dentry *, int); 
\end_layout

\begin_layout LyX-Code

\size small
int (*d_hash) (struct dentry *, struct qstr *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*d_compare) (struct dentry *, struct qstr *, struct qstr *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*d_delete) (struct dentry *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*d_release) (struct dentry *); 
\end_layout

\begin_layout LyX-Code

\size small
void (*d_iput) (struct dentry *, struct inode *); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Metodi za rad sa objektom dentry su sledeći: 
\end_layout

\begin_layout Itemize

\family typewriter
int d_revalidate(struct dentry *dentry, int flags)
\family default
: određuje da li je dati dentry objekat ispravan.
 
\end_layout

\begin_layout Itemize

\family typewriter
int d_hash(struct dentry *dentry, struct qstr *name)
\family default
: kreira heš vrednost za dati dentry.
 
\end_layout

\begin_layout Itemize

\family typewriter
int d_compare(struct dentry *dentry, struct qstr *name1, 
\begin_inset Newline linebreak
\end_inset

struct qstr *name2)
\family default
: VFS poziva ovu funkciju da bi uporedio datoteke name1 i name2.
 
\end_layout

\begin_layout Section
Objekat file
\end_layout

\begin_layout Standard
Objekat file se koristi za predstavljanje datoteke koju je otvorio proces.
 Procesi rade direktno sa objektom file, a ne sa superblokom, inodom ili
 dentrijima.
 Objekat file je predstava otvorene datoteke u memoriji.
 Objekat (ali ne fizička datoteka) se kreira kao odziv na sistemski poziv
 
\family typewriter
open()
\family default
, a uništava kao rezultat sistemskog poziva 
\family typewriter
close()
\family default
.
 Ovi sistemski pozivi su definisani u tabeli operacija sa datotekama.
 Pošto više procesa mogu da otvore datoteku i rade sa njom u isto vreme,
 može da postoji više objekata file za istu datoteku.
 Objekat file predstavlja pogled procesa na otvorenu datoteku.
 Objekat pokazuje na dentry (koji sa svoje strane pokazuje na inode) koji
 stvarno predstavlja otvorenu datoteku.
 Objekti inode i dentry su jedinstveni.
 Objekat file je predstavljen strukturom 
\family typewriter
file
\family default
 i definisan u zaglavlju 
\family typewriter
<linux/fs.h>
\family default
.
 Sledi kôd strukture sa odgovarajućim komentarima: 
\end_layout

\begin_layout LyX-Code

\size small
struct file { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct list_head f_list; /* list of file objects */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry *f_dentry; /* associated dentry object */ 
\end_layout

\begin_layout LyX-Code

\size small
struct vfsmount *f_vfsmnt; /* associated mounted fs */ 
\end_layout

\begin_layout LyX-Code

\size small
struct file_operations *f_op; /* file operations table */ 
\end_layout

\begin_layout LyX-Code

\size small
atomic_t f_count; /* file object's usage count */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned int f_flags; /* flags specified on open */ 
\end_layout

\begin_layout LyX-Code

\size small
mode_t f_mode; /* file access mode */ 
\end_layout

\begin_layout LyX-Code

\size small
loff_t f_pos; /* file offset (file pointer) */ 
\end_layout

\begin_layout LyX-Code

\size small
struct fown_struct f_owner; /* owner data for signals */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned int f_uid; /* user's UID */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned int f_gid; /* user's GID */ 
\end_layout

\begin_layout LyX-Code

\size small
int f_error; /* error code */ 
\end_layout

\begin_layout LyX-Code

\size small
struct file_ra_state f_ra; /* read-ahead state */ 
\end_layout

\begin_layout LyX-Code

\size small
unsigned long f_version; /* version number */ 
\end_layout

\begin_layout LyX-Code

\size small
void *f_security; /* security module */ 
\end_layout

\begin_layout LyX-Code

\size small
void *private_data; /* tty driver hook */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head f_ep_links; /* list of eventpoll links */ 
\end_layout

\begin_layout LyX-Code

\size small
spinlock_t f_ep_lock; /* eventpoll lock */ 
\end_layout

\begin_layout LyX-Code

\size small
struct address_space *f_mapping; /* page cache mapping */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout Standard
Slično objektu dentry, objekat file u stvari ne odgovara bilo kom podatku
 na disku.
 Zbog toga ne postoji fleg u objektu koji određuje da li je objekat izmenjen
 i da li treba da bude upisan na disk.
 Objekat file pokazuje na pridružen objekat dentry preko pokazivača f_dentry.
 Objekat dentry pokazuje na pridruženi inode, na osnovu koga se može zaključiti
 da li je datoteka izmenjena (dirty).
\end_layout

\begin_layout Subsection
Operacije sa objektima file
\end_layout

\begin_layout Standard
Kao i u slučaju ostalih VFS objekata, veoma je važna tabela operacija sa
 objektima file.
 Odgovarajući metodi se nalaze u strukturi 
\family typewriter
file_operations
\family default
, definisanoj u zaglavlju 
\family typewriter
<linux/fs.h>
\family default
: 
\end_layout

\begin_layout LyX-Code

\size small
struct file_operations { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct module *owner; 
\end_layout

\begin_layout LyX-Code

\size small
loff_t (*llseek) (struct file *, loff_t, int); 
\end_layout

\begin_layout LyX-Code

\size small
ssize_t (*read) (struct file *, char *, size_t, loff_t *); 
\end_layout

\begin_layout LyX-Code

\size small
ssize_t (*aio_read) (struct kiocb *, char *, size_t, loff_t); 
\end_layout

\begin_layout LyX-Code

\size small
ssize_t (*write) (struct file *, const char *, size_t, loff_t *); 
\end_layout

\begin_layout LyX-Code

\size small
ssize_t (*aio_write) (struct kiocb *, const char *, size_t, loff_t); 
\end_layout

\begin_layout LyX-Code

\size small
int (*readdir) (struct file *, void *, filldir_t); 
\end_layout

\begin_layout LyX-Code

\size small
unsigned int (*poll) (struct file *, struct poll_table_struct *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*ioctl) (struct inode *, struct file *, unsigned int, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
unsigned long); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
int (*mmap) (struct file *, struct vm_area_struct *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*open) (struct inode *, struct file *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*flush) (struct file *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*release) (struct inode *, struct file *); 
\end_layout

\begin_layout LyX-Code

\size small
int (*fsync) (struct file *, struct dentry *, int); 
\end_layout

\begin_layout LyX-Code

\size small
int (*aio_fsync) (struct kiocb *, int); 
\end_layout

\begin_layout LyX-Code

\size small
int (*fasync) (int, struct file *, int); 
\end_layout

\begin_layout LyX-Code

\size small
int (*lock) (struct file *, int, struct file_lock *); 
\end_layout

\begin_layout LyX-Code

\size small
ssize_t (*readv) (struct file *, const struct iovec *, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
unsigned long, loff_t *); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
ssize_t (*writev) (struct file *, const struct iovec *, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
unsigned long, loff_t *); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
ssize_t (*sendfile) (struct file *, loff_t *, size_t, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
read_actor_t, void *); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
ssize_t (*sendpage) (struct file *, struct page *, int, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
size_t, loff_t *, int); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
unsigned long (*get_unmapped_area) 
\end_layout

\begin_layout LyX-Code

\size small
(struct file *, unsigned long, unsigned long, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
unsigned long, unsigned long); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
int (*check_flags) (int flags); 
\end_layout

\begin_layout LyX-Code

\size small
int (*dir_notify) (struct file *filp, unsigned long arg); 
\end_layout

\begin_layout LyX-Code

\size small
int (*flock) (struct file *filp, int cmd, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct file_lock *fl); 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Sistemi datoteka mogu da primene jedinstvene funkcije za svaku od ovih operacija
, ali i da koriste generički metod ako on postoji.
 U nastavku je dat spisak funkcija koje se mogu primeniti na objekat file:
 
\end_layout

\begin_layout Itemize

\family typewriter
loff_t llseek(struct file *file, loff_t offset, int origin)
\family default
: ažurira pokazivač na datoteku za dati pomeraj (
\family typewriter
offset
\family default
).
 Poziva se preko sistemskog poziva llseek().
 
\end_layout

\begin_layout Itemize

\family typewriter
ssize_t read(struct file *file, char *buf, size_t count, 
\begin_inset Newline linebreak
\end_inset

loff_t *offset)
\family default
: učitava 
\family typewriter
count
\family default
 bajtova iz date datoteke na poziciji 
\family typewriter
offset
\family default
 u 
\family typewriter
buf
\family default
.
 Pokazivač na datoteku se zatim ažurira.
 Ovu funkciju poziva sistemski poziv 
\family typewriter
read()
\family default
.
 
\end_layout

\begin_layout Itemize

\family typewriter
ssize_t aio_read(struct kiocb *iocb, char *buf, size_t count, 
\begin_inset Newline linebreak
\end_inset

loff_t offset)
\family default
: počinje asinhrono čitanje 
\family typewriter
count
\family default
 bajtova u datoteku 
\family typewriter
buf
\family default
 opisanu u 
\family typewriter
iocb
\family default
.
 Poziva je sistemski poziv 
\family typewriter
aio_read()
\family default
.
 
\end_layout

\begin_layout Section
Strukture podataka pridružene sistemima datoteka
\end_layout

\begin_layout Standard
Uz osnovne VFS objekte, kernel za upravljanje podacima koristi druge standardne
 strukture podataka.
 Prvi objekat se koristi za opisivanje specifičnih varijanti sistema datoteka,
 kao što su ext3 ili XFS.
 Druga struktura podataka se koristi za opisivanje montirane instance sistema
 datoteka.
 Pošto Linux podržava veliki broj sistema datoteka, neophodna je specijalna
 struktura u kernelu za opis karakteristika i ponašanja svakog sistema datoteka.
 
\end_layout

\begin_layout LyX-Code

\size small
struct file_system_type { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
const char *name; /* filesystem's name */ 
\end_layout

\begin_layout LyX-Code

\size small
struct subsystem subsys; /* sysfs subsystem object */ 
\end_layout

\begin_layout LyX-Code

\size small
int fs_flags; /* filesystem type flags */
\end_layout

\begin_layout LyX-Code

\size small
/* the following is used to read the superblock off the disk */ 
\end_layout

\begin_layout LyX-Code

\size small
struct super_block *(*get_sb) (struct file_system_type *, 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int, char *, void *);
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
/* the following is used to terminate access to the superblock */ 
\end_layout

\begin_layout LyX-Code

\size small
void (*kill_sb) (struct super_block *);
\end_layout

\begin_layout LyX-Code

\size small
struct module *owner; /* module owning the filesystem */ 
\end_layout

\begin_layout LyX-Code

\size small
struct file_system_type *next; /* next file_system_type in list */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head fs_supers; /* list of superblock objects */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Struktura 
\family typewriter
vfsmount
\family default
 je definisana u zaglavlju 
\family typewriter
<linux/mount.h>
\family default
 sledećim kôdom:
\end_layout

\begin_layout LyX-Code

\size small
struct vfsmount { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
struct list_head mnt_hash; /* hash table list */ 
\end_layout

\begin_layout LyX-Code

\size small
struct vfsmount *mnt_parent; /* parent filesystem */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry *mnt_mountpoint; /* dentry of this mount point */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry *mnt_root; /* dentry of root of this fs */ 
\end_layout

\begin_layout LyX-Code

\size small
struct super_block *mnt_sb; /* superblock of this filesystem */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head mnt_mounts; /* list of children */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head mnt_child; /* list of children */ 
\end_layout

\begin_layout LyX-Code

\size small
atomic_t mnt_count; /* usage count */ 
\end_layout

\begin_layout LyX-Code

\size small
int mnt_flags; /* mount flags */ 
\end_layout

\begin_layout LyX-Code

\size small
char *mnt_devname; /* device file name */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head mnt_list; /* list of descriptors */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head mnt_fslink; /* fs-specific expiry list */ 
\end_layout

\begin_layout LyX-Code

\size small
struct namespace *mnt_namespace /* associated namespace */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Section
Strukture podataka pridružene procesu
\end_layout

\begin_layout Standard
Svaki proces u sistemu ima svoju sopstvenu listu otvorenih datoteka, korenski
 direktorijum sistema datoteka, tekući radni direktorijum, tačke montiranja
 itd.
 VFS sloj i procese u sistemu povezuju tri strukture podataka: 
\family typewriter
files_struct
\family default
, 
\family typewriter
fs_struct
\family default
 i 
\family typewriter
namespace
\family default
.
 Struktura 
\family typewriter
files_struct
\family default
 je definisana u zaglavlju 
\family typewriter
<linux/file.h>
\family default
.
 Sve informacije procesa su definisane sledećim kôdom:
\end_layout

\begin_layout LyX-Code

\size small
struct files_struct { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
atomic_t count; /* structure's usage count */ 
\end_layout

\begin_layout LyX-Code

\size small
spinlock_t file_lock; /* lock protecting this structure */ 
\end_layout

\begin_layout LyX-Code

\size small
int max_fds; /* maximum number of file objects */ 
\end_layout

\begin_layout LyX-Code

\size small
int max_fdset; /* maximum number of file descriptors */ 
\end_layout

\begin_layout LyX-Code

\size small
int next_fd; /* next file descriptor number */ 
\end_layout

\begin_layout LyX-Code

\size small
struct file **fd; /* array of all file objects */ 
\end_layout

\begin_layout LyX-Code

\size small
fd_set *close_on_exec; /* file descriptors to close on exec() */ 
\end_layout

\begin_layout LyX-Code

\size small
fd_set *open_fds; /* pointer to open file descriptors */ 
\end_layout

\begin_layout LyX-Code

\size small
fd_set close_on_exec_init; /* initial files to close on exec() */ 
\end_layout

\begin_layout LyX-Code

\size small
fd_set open_fds_init; /* initial set of file descriptors */ 
\end_layout

\begin_layout LyX-Code

\size small
struct file *fd_array[NR_OPEN_DEFAULT]; 
\end_layout

\begin_layout LyX-Code

\size small
/* default array of file objects */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout Standard
Niz 
\family typewriter
fd
\family default
 pokazuje na listu otvorenih fajl objekata.
 Standardno je to niz 
\family typewriter
fd_array
\family default
.
 Druga struktura je 
\family typewriter
fs_struct
\family default
 i sadrži informacije o sistemu datoteka; na nju pokazuje polje 
\family typewriter
fs
\family default
 u deskriptoru procesa.
 Struktura je definisana u zaglavlju 
\family typewriter
<linux/fs_struct.h>
\family default
 i prikazana ovde sa odgovarajućim komentarima: 
\end_layout

\begin_layout LyX-Code

\size small
struct fs_struct { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
atomic_t count; /* structure usage count */ 
\end_layout

\begin_layout LyX-Code

\size small
rwlock_t lock; /* lock protecting structure */ 
\end_layout

\begin_layout LyX-Code

\size small
int umask; /* default file permissions*/ 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry *root; /* dentry of the root directory */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry *pwd; /* dentry of the current directory */ 
\end_layout

\begin_layout LyX-Code

\size small
struct dentry *altroot; /* dentry of the alternative root */ 
\end_layout

\begin_layout LyX-Code

\size small
struct vfsmount *rootmnt; /* mount object of the root directory */ 
\end_layout

\begin_layout LyX-Code

\size small
struct vfsmount *pwdmnt; /* mount object of the current directory */ 
\end_layout

\begin_layout LyX-Code

\size small
struct vfsmount *altrootmnt; 
\end_layout

\begin_layout LyX-Code

\size small
/* mount object of the alternative root */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Ova struktura drži tekući radni direktorijum (
\family typewriter
pwd
\family default
) i korenski (root) direktorijum tekućeg procesa.
 Treća struktura je 
\family typewriter
namespace
\family default
, definisana u zaglavlju 
\family typewriter
<linux/namespace.h>
\family default
 na koju pokazuje polje 
\family typewriter
namespace
\family default
 u deskriptoru procesa.
 Ova struktura omogućuje da svaki proces ima jedinstven pogled na montirani
 sistem datoteka.
 Sledi kôd strukture sa odgovarajućim komentarima:
\end_layout

\begin_layout LyX-Code

\size small
struct namespace { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
atomic_t count; /* structure usage count */ 
\end_layout

\begin_layout LyX-Code

\size small
struct vfsmount *root; /* mount object of root directory */ 
\end_layout

\begin_layout LyX-Code

\size small
struct list_head list; /* list of mount points */ 
\end_layout

\begin_layout LyX-Code

\size small
struct rw_semaphore sem; /* semaphore protecting the namespace */ 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Član strukture 
\family typewriter
list
\family default
 određuje dvostruko ulančanu listu montiranog sistema datoteka koji čini
 prostor imena (
\family typewriter
namespace
\family default
).
 Ova struktura podataka je povezana sa svakim deskriptorom procesa.
 Svi procesi dele isti prostor imena, tj.
 vide istu hijerarhiju sistema datoteka u istoj tabeli montiranja.
\end_layout

\begin_layout Part
Primeri operativnih sistema
\end_layout

\begin_layout Chapter*
Instaliranje i praktična primena virtuelnih mašina
\end_layout

\begin_layout Standard
Virtuelizacija u računarskim naukama predstavlja kreiranje virtuelne verzije
 hardverske platforme, operativnog sistema, mrežnih resursa itd.
 Virtuelizacija može biti hardverska, softverska, mrežna, aplikativna i
 virtuelizacija skladištenja podataka: 
\end_layout

\begin_layout Itemize
virtuelizacija skladištenja podataka (storage virtualization): povezivanje
 više fizičkih uređaja za skladištenje u jedan virtuelni), 
\end_layout

\begin_layout Itemize
mrežna virtuelizacija (network virtualization): omogućuje razdvajanje dostupnih
 propusnih opsega u zasebne kanale da bi mogli da se dodeljuju pojedinim
 resursima), 
\end_layout

\begin_layout Itemize
serverska virtuelizacija (server virtualization): često se zove i hardverska
 virtuelizacija.
 Prikriva fizičke karakteristike servera, virtuelni serveri dele resurse
 fizičkog servera), 
\end_layout

\begin_layout Itemize
desktop virtuelizacija (desktop virtualization): radne stanice su tzv.
 „tanki klijenti" (thin clients) jer nemaju svoj operativni sistem već se
 on u potpunosti izvršava na serveru), 
\end_layout

\begin_layout Itemize
aplikativna virtuelizacija (application virtualization): poslovne aplikacije
 se pokreću virtuelno sa radnih stanica ali zapravo troše resurse servera).
 
\end_layout

\begin_layout Standard
Slika 1 ilustruje primere primene Microsoft Hyper-V virtuelizacije.
 Uz pomoć virtuelizacije moguće je mnogo poboljšati efikasnost iskorišćenja
 računarskih resursa u odnosu na mašinu bez virtuelizacije (približno kao
 u mainframe okruženju).
 Istovremeno je moguće smanjiti broj fizičkih servera za 8 do 30 puta.
 Usled toga znatno se smanjuje i utrošak električne energije u računarskom
 centru (koja se, zapravo, pretvara u toplotu) i fizički prostor potreban
 za instalaciju.
 Napredne opcije omogućavaju da servis (kako ga vide krajnji korisnici)
 bude mnogo raspoloživiji od hardvera na kome je instaliran.
 Neki servisi bez prekida rade gotovo hiljadu dana, s tim što su u međuvremenu
 više desetina puta prebačeni sa hosta na host.
 Stavljanje novog virtuelnog servera na raspolaganje IT odeljenju ili korisnicim
a je postupak koji traje nekoliko minuta (podrazumeva kloniranje, kreiranje
 na osnovu šablona), u poređenju sa tri do četiri nedelje koliko je potrebno
 za nabavku i instalaciju fizičkog servera.
 Arhitektura rezervnog računskog centra (koji se koristi u slučaju zakazivanja)
 može biti vrlo kompaktna i ekonomična, tj.
 potpuno virtuelizovana.
 Štaviše, ova infrastruktura može da se deli sa drugim korisnicima, pa je
 jeftinija nego sopstvena.
 Uprošćava se i instalacija i administracija operativnih sistema i aplikacija
 koje oni podržavaju (iskustvo pokazuje da se potrebni ljudski i vremenski
 resursi smanjuju na trećinu).
 Distribucija, testiranje i procena kvaliteta novog softvera koji se isporučuje
 u obliku virtuelnih mašina je znatno ubrzana i olakšana.
 Na Web lokaciji vmware.com može se naći preko 300 takvih mašina, a isti
 pristup su prihvatili i ostali isporučioci softvera.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M1.PNG
	scale 45

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 1: Mogućnosti primene tehnologije Microsoft Hyper-V
\end_layout

\begin_layout Standard
U SAD, procenat virtuelizovanog dela infrastrukture računskih centara je
 vrlo visok, preko 40%.
 IT analitičari procenjuju da za dve do tri godine neće postojati fizički
 server bez instaliranog softvera za virtuelizaciju, i da će to promeniti
 koncepciju operativnog sistema opšte namene i modele licenciranja softvera.
\end_layout

\begin_layout Subsection*
Hardverska podrška 
\end_layout

\begin_layout Standard
Savremena virtuelizacija dozvoljava pokretanje više različitih operativnih
 sistema na jednom računaru.
 Svaka virtuelna mašina je nezavisan operativni sistem sa sopstvenim hardverom,
 ali svi operativni sistemi dele resurse zajedničkog (fizičkog) hardvera.
 Kontrolu hardvera sprovodi softver nazvan virtuelna mašina (VM), koji kontroliš
e pristupe procesoru, memoriji, ulazno-izlaznim uređajima, diskovima i mrežnom
 hardveru.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M2.PNG
	scale 90

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 2: Prikaz prebacivanja fizičkog računara u virtuelni.
\end_layout

\begin_layout Standard
Da bi se na računaru kreirale virtuelne particije, sistemu se dodaje tanki
 softverski sloj nazvan Virtual Machine Monitor (VMM).
 Ovaj sloj je odgovoran za upravljanje hardverskim resursima i razrešavanje
 zahteva operativnog sistema, odnosno aplikacija koje su pod njim pokrenute.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M3.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M4.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 3: Dva najvažnija modela virtuelizacije: virtuelizacija zasnovana
 na host operativnom sistemu (gore) i direktna virtuelizacija na sistemu
 softvera za virtuelizaciju (dole).
\end_layout

\begin_layout Standard
VMM je virtuelni skup procesora, memorije, diska i mreže za svakog korisnika.
 Osnovne funkcije koje ovaj softver obavlja su emulacija hardvera prema
 operativnim sistemima korisnika, izolovanje rada pojedinačnih virtuelnih
 mašina, alokacija resursa potrebnih svakoj virtuelnoj mašini, uz održavanje
 balansa među zahtevima.
 U 2010.
 godini 23% aplikacija radilo je na virtuelnim mašinama, a prognoza je da
 će do 2012.
 godine ta brojka porasti na 48%.
 Tržištem virtuelnih mašina dominira proizvođač VMware.
 Pretpostavka je da na tržištu trenutno postoji 10,8 miliona virtuelnih
 mašina, a da je tržišni udeo firme VMware 84%, Microsofta 11%, Citrixa
 4%, ostalih proizvođača 1%.
 Najpoznatiji programi za virtuelizaciju su: 
\end_layout

\begin_layout Itemize
VMware Player, Server, Workstation, ESX i ESXi; 
\end_layout

\begin_layout Itemize
Microsoft Hyper-V; 
\end_layout

\begin_layout Itemize
Oracle (Sun) VirtualBox; 
\end_layout

\begin_layout Itemize
Citrix XenServer
\end_layout

\begin_layout Itemize
Parallels Desktop 
\end_layout

\begin_layout Chapter*
Operativni sistemi sa komandnom linijom
\end_layout

\begin_layout Standard
Operativne sisteme sa komandnom linijom (CLI, Command Line Interface) predstavić
emo pomoću virtuelnog računara zasnovanog na operativnom sistemu MS-DOS.
 Ovaj operativni sistem proizvod je kompanije Microsoft, razvijen je 1981.
 godine, i u gotovo neizmenjenom obliku zadržao se do kraja devedesetih
 godina prošlog veka.
 U osnovi, radi se o operativnom sistemu koji radi sa diskovima i isključivo
 sa tekstualnim interfejsom (tastaturom).
 
\end_layout

\begin_layout Standard
Komandna linija je linija u kojoj se kucaju komande (naredbe).
 Komandni prompt pokazuje da se nalazite u komandnoj liniji.
 Prompt može biti slovo za logičku oznaku disk jedinice, praćeno obrnutom
 kosom crtom (backslash), npr.
 C:
\backslash
 ili A:
\backslash
 i nazivom direktorijuma (na primer, C:
\backslash
dos).
 Slovo pokazuje koja je disk jedinica aktivna.
 MS-DOS pretražuje aktivnu disk jedinicu da bi pronašao informaciju koja
 mu je potrebna za izvršavanje komande.
 
\end_layout

\begin_layout Standard
Osim komandne linije, za rad sa većinom MS-DOS komandi može se koristiti
 i MS-DOS Shell.
 To je prozor koji omogućuje vizuelni rad sa MS-DOS-om i prikazuje disk
 jedinice, direktorijume, datoteke i programe koji su na raspolaganju.
 Komande u MS-DOS Shellu navedene su u tzv.
 menijima; nazivi ovih menija smešteni su duž vrha ekrana.
 U MS-DOS Shellu komande se biraju u meniju, uz pomoć tastature ili miša.
 Treba napomenuti da se ne mogu sve MS-DOS komande koristiti iz MS-DOS Shella;
 neke komande moraju se kucati u komandnoj liniji.
\end_layout

\begin_layout Standard
Sve verzije sa nazivom PC-DOS Microsoft je razvio za IBM.
 Početne i kranje verzije DOS-a su: 
\end_layout

\begin_layout Itemize
PC-DOS 1.0 - avgust, 1981 - s prvim IBM PC računarom, 
\end_layout

\begin_layout Itemize
MS-DOS 1.25 - januar, 1982 - za prve kompatibilne IBM računare, 
\end_layout

\begin_layout Itemize
MS-DOS 6.22 - jun, 1994 - poslednja samostalna verzija, 
\end_layout

\begin_layout Itemize
PC-DOS 7.0 - april, 1995, 
\end_layout

\begin_layout Itemize
Windows 95/DOS 7.0 - avgust, 1995 - prva nesamostalna verzija, 
\end_layout

\begin_layout Itemize
Windows 95 OSR2/DOS 7.1 - avgust, 1997 - dodata podrška za sistem datoteka
 FAT32 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M5.PNG
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 4: Izgled ekrana sa komandnom linijom u operativnom sistemu Windows
 7.
\end_layout

\begin_layout Section*
DOS - Disk Operating System
\end_layout

\begin_layout Standard
DOS je skraćeni naziv za Disk Operating System.
 To ime ne znači da je njegova uloga vezana isključivo za rad sa diskom.
 Ime je ostalo kao istorijsko nasleđe.
 
\end_layout

\begin_layout Standard
U nastavku je dat pregled najčešće korišćenih komandi DOS-a.
 Treba znati da DOS ne razlikuje mala i velika slova (tj.
 nije case sensitive).
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="30text%">
<column alignment="center" valignment="top" width="40text%">
<row endhead="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Primer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
TREE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za pregled svih direktorijuma
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C:
\backslash
tree C:
\end_layout

\begin_layout Plain Layout
Argument C: je oznaka diska čiji spisak direktorijuma sa svim poddirektorijumima
 se traži.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
MKDIR [MD]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za kreiranje poddirektorijuma na disku.
 
\end_layout

\begin_layout Plain Layout
MD je skraćeni oblik komande.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
md C:
\backslash
prvi
\backslash
drugi
\backslash
 
\end_layout

\begin_layout Plain Layout
Argument C: je oznaka diska na kome se kreira poddirektorijum.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
CHDIR [CD]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za promenu aktivnog direktorijuma.
 CD je skraćeni oblik komande koji se češće koristi.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cd c:
\backslash
prvi
\backslash
drugi 
\end_layout

\begin_layout Plain Layout
Argument C: je oznaka diska na koji se komanda odnosi.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
RMDIR [RD]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za brisanje (isključivo praznih) poddirektorijuma.
 RD je skraćeni oblik komande koji se češće koristi.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rd 
\backslash
prvi
\backslash
drugi 
\end_layout

\begin_layout Plain Layout
rd primer 
\end_layout

\begin_layout Plain Layout
U prvom primeru biće izbrisan direktorijum drugi koji se nalazi u direktorijumu
 prvi, a u drugom primeru biće izbrisan direktorijum primer.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
PATH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za zadavanje putanje na kojoj DOS traži korisničke programe, spoljašnje
 komande i batch datoteke ukoliko se oni ne nalaze u aktivnom poddirektorijumu.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path C:
\backslash
; C:
\backslash
prvi; A:
\backslash
; C:
\backslash
prvi
\backslash
drugi
\backslash
drugi1 
\end_layout

\begin_layout Plain Layout
U ovom primeru DOS prvo traži komandu ili program u osnovnom direktorijumu
 diska C; ako je tu ne nađe traži je u poddirektorijumu prvi, zatim u osnovnom
 direktorijumu na disketi i na kraju na disku u poddirektorijumu drugi.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
DATE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za postavljanje datuma.
\end_layout

\begin_layout Plain Layout
Argumenti su mm (mesec), dd (dan u mesecu) i yy (dvocifreni završetak godine).
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
date 
\end_layout

\begin_layout Plain Layout
Current date is Tue 1-01-1980 
\end_layout

\begin_layout Plain Layout
Enter new date (mm-dd-yy): 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
TIME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za postavljanje vremena.
 
\end_layout

\begin_layout Plain Layout
Argumenti su sati, minuti, sekunde i stotinke.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time 
\end_layout

\begin_layout Plain Layout
Current time is Tue 00:00:36,93 
\end_layout

\begin_layout Plain Layout
Enter new time:
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
PROMPT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za promenu odzivnog znaka (prompt) DOS-a.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
prompt $t$d$n$g 
\end_layout

\begin_layout Plain Layout
Argumenti navedeni posle reči prompt predstavljaju niz proizvoljnih znakova.
 Pre svakog specijalnog znaka obavezno se dodaje $.
 Oznake i značenja su: t - trenutno vreme; d - važeći datum; n - aktivna
 disk jedinica; p - aktivni poddirektorijum; v - verzija DOS-a; g – matematički
 znak za veće itd.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
VER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za ispisivanje verzije DOS-a.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ver 
\end_layout

\begin_layout Plain Layout
MS-DOS Version 6.20 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
CLS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za brisanje sadržine ekrana.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
DIR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za prikaz sadržaja diska, uključujući i dodatne informacije o datotekama
 poput veličine, datuma kreiranja i sl.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dir/p 
\end_layout

\begin_layout Plain Layout
Argument /p omogućava prikaz sadržaja po stranama.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
COPY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za kopiranje sa diska na disk, i u okviru istog diska.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
copy text.bak text.txt 
\end_layout

\begin_layout Plain Layout
Kopiranje u okviru istog diska u kom se datoteka text.bak kopira u datoteku
 text.txt u istom direktorijumu.
 
\end_layout

\begin_layout Plain Layout
copy a:*.* c: 
\end_layout

\begin_layout Plain Layout
Sve datoteke sa disketne jedinice a kopiraju se na disk c.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
RENAME [REN]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda koja menja ime datoteke.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ren text.bak text1.bak 
\end_layout

\begin_layout Plain Layout
Naziv datoteke TEXT se menja u TEXT1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
DELETE [DEL]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komanda za brisanje datoteka.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
del text.bak 
\end_layout

\begin_layout Plain Layout
U ovom primeru datoteka TEXT će biti obrisana.
 Dozvoljena je upotreba džoker znakova.
 
\end_layout

\begin_layout Plain Layout
del *.bak Biće obrisane sve datoteke sa ekstenzijom BAK.
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
DŽOKER ZNACI: Džoker je znak koji može da zameni jedan ili više znakova.
 Džoker znaci se koriste uglavnom pri navođenju imena datoteka, ali samo
 kada se te datoteke nalaze kao argumenti unutar nekih komandi.
 Znak pitanja ? zamenjuje jedan znak.
 Drugi džoker znak je zvezdica * i ona zamenjuje proizvoljan broj znakova.
 
\end_layout

\begin_layout Standard
*.exe – sve datoteke tipa EXE 
\end_layout

\begin_layout Standard
*.bat – sve datoteke tipa BAT
\end_layout

\begin_layout Standard
*.* - sve datoteke 
\end_layout

\begin_layout Standard
???.com - datoteke tipa COM čiji naziv ima 1, 2, ili 3 znaka 
\end_layout

\begin_layout Subsection*
Primeri DOS komandi u CLI interfejsu Microsoft Windowsa 7
\end_layout

\begin_layout Standard
Da bi pokrenuli interfejs iz komandne linije (CLI), u polje za pretraživanje
 operativnog sistema Windows 7 unećemo komandu CMD i pritisnuti taster Enter.
 Pojaviće se ekran sa slike:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M6.PNG
	scale 75

\end_inset


\end_layout

\begin_layout Standard
Dalje korišćenje nastavljamo samo pomoću tastature i komandi koje smo već
 opisali u prethodnom tekstu.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M7.PNG
	scale 75

\end_inset


\end_layout

\begin_layout Standard
Komanda 
\family typewriter
dir
\family default
 omogućiće nam prikaz sadržaja svih direktorijuma i datoteka u sklopu direktorij
uma u kome se trenutno nalazimo.
 Za potrebe primera kreirali smo direktorijum sa imenom Singidunum pomoću
 komande 
\family typewriter
md Singidunum
\family default
.
 Nakon toga smo trenutno aktivni direktorijum promenili u direktorijum 
\family typewriter
Singidunum
\family default
 pomoću komande 
\family typewriter
cd Singidunum
\family default
.
 Zatim smo prikazali sadržaj direktorijuma Singidunum korišćenjem komande
 
\family typewriter
dir
\family default
 i videli da se radi o praznom direktorijumu koji je upravo kreiran.
 Neke naredbe i sistemske komande se izvršavaju isključivo pomoću komandnog
 interfejsa.
 
\end_layout

\begin_layout Chapter*
Instaliranje virtuelnog operativnog sistema Windows XP
\end_layout

\begin_layout Standard
Opisaćemo korake potrebne za instalaciju virtuelnog računara zasnovanog
 na operativnom sistemu Windows XP.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M8.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 5: Osnovni meni programa VMware Player.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M9.PNG
	scale 75

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 6: Meni koji se dobija izborom opcije Create a New Virtual Machine.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M10.PNG
	scale 75

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7: Meni za izbor "gostujućeg" operativnog sistema.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M11.PNG
	scale 75

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 8: Osnovni podaci o virtuelnoj mašini.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M12.PNG
	scale 75

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 9: Izbor veličine diska i načina skladištenja.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M13.PNG
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 10: Prikaz izabranih opcija.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M14.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 11: Podešavanje procesora i tipa virtuelizacije.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M15.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 12: Podešavanje mrežne kartice i tipa povezivanja.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M16.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 13: Ekran za pokretanje virtuelne mašine.
\end_layout

\begin_layout Standard
Nakon toga sledi standardna procedura instaliranja operativnog sistema Windows
 XP sa odgovarajućim podešavanjima.
 Dalja instalacija teče automatizovano, a zavisno od hardvera računara traje
 od 10 do 30 minuta.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M17.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 14: Izbor dodatnih mrežnih podešavanja, izbor radne grupe ili domena.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M18.PNG
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 15: Ekran nakon prvog prijavljivanja.
\end_layout

\begin_layout Standard
Kao i kod stvarnog računara, i ovde je potrebno instalirati upravljačke
 programe (drajvere) da bi računar radio brže i stabilnije.
 VM drajveri nude i neke dodatne mogućnosti za sam VM računar.
 Do instalacije drajvera stiže se preko Virtual Machine i poslednje opcije,
 Install VMware Tools.
 Nakon toga pokreće se instalacija koja je prilično automatizovana, sa svega
 nekoliko ekrana koji nude mogućnost podešavanja.
\end_layout

\begin_layout Standard
Dok virtuelni računar radi, treba koristiti opcije samog VMware Playera.
 Izaberite opciju Virtual Machine u gornjem delu ekrana, a zatim Virtual
 Machine Settings.
 Videćete da ima dosta opcija koje ne mogu da se promene dok VM radi.
 Kada se završi rad virtuelne mašine, sve opcije ponovo postaju dostupne.
 Opisali smo postupak instalacije VM računara pod operativnim sistemom Windows
 XP.
 Windows XP se dalje ponaša kao da je instaliran na fizičkom računaru sa
 svojstvima koja smo dodelili ovom virtuelnom računaru.
 Zvanične, besplatne i gotove virtuelne računare možete preuzeti sa adrese
 http://www.vmware.com/appliances/directory/
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M19.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 16: Instalacija VMware drajvera protiče kao i instalacija svakog drugog
 programa.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M20.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 17: Nakon instaliranih drajvera sledi restart računara i nastavak
 rada.
\end_layout

\begin_layout Chapter*
Instaliranje virtuelnog operativnog sistema Windows 7 
\end_layout

\begin_layout Standard
Prvih nekoliko koraka instalacije virtuelnog računara zasnovanog na operativnom
 sistemu Windows 7 liče na instalaciju računara zasnovanog na operativnom
 sistemu Windows XP, pa iz tog razloga preskačemo uvodne ekrane i nastavljamo
 od dela koji se razlikuje.
 Osnovne razlike u podešavanju virtuelne mašine odnose se na količinu prostora
 na disku koja je potrebna operativnom sistemu Windows 7, kao i na količinu
 radne memorije koja u ovom slučaju mora biti najmanje 1024 MB.
 Ostala podešavanja u većini slučajeva mogu ostati ista kao i kod podešavanja
 virtuelne mašine za instalaciju operativnog sistema Windows XP.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M21.PNG
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 18: Izgled ekrana pred sam završetak instaliranja (opcija Finish).
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M22.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 19: Ekran za pokretanje virtuelne mašine.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M23.PNG
	scale 45

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 20: Početak instalacije ili popravke operativnog sistema Windows 7.
\end_layout

\begin_layout Standard
Sledeći ekran predstavlja opis licence MICROSOFT SOFTWARE LICENCE TERMS.
 U ovom ekranu treba potvrditi opciju „I accept the license terms“, što
 znači da ste saglasni sa pravilima i time nastavljate instalaciju.
 Na sledećem ekranu treba izabrati tip instalacije.
 Ako postoji prethodna verzija Windowsa, može se odabrati opcija “Upgrade”
 koja će sačuvati postojeće datoteke na disku.
 Druga mogućnost je “Custom (advanced)”, čime se opredeljujete za potpuno
 novu instalaciju.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M24.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 21: Kopiranje instalacionih datoteka i instalacija.
\end_layout

\begin_layout Standard
Sledeće podešavanje je izbor diska na koji želite da instalirate operativni
 sistem.
 Možete da birate disk, kreiranje particije ili (ako postoji RAID kontroler)
 da instalirate drajver da bi disk postao vidljiv za Windows.
 Formatiranje sistema datoteka je NTFS (New Technology File System); prilikom
 formatiranja kreira se zasebna particija od 100MB pod nazivom „System Reserved“
 na kojoj se nalaze sistemske datoteke za slučaj pada sistema ili nekog
 oštećenja.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M25.PNG
	scale 45

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 22: Prvi meni koji će nas dočekati je kreiranje novog naloga (korisnika)
 sa administratorskim privilegijama i dodeljivanje imena računaru.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M26.PNG
	scale 45

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 23: Kreiranje administratorske lozinke i podsetnika.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M27.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 24: Unošenje ključa; prednost Windowsa 7 u odnosu na Windows XP je
 što postoji period od 30 dana korišćenja pre aktivacije.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M28.PNG
	scale 45

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 25: Ekran nakon prvog prijavljivanja.
\end_layout

\begin_layout Standard
Prednost Windowsa 7 u odnosu na ranije verzije je što sa Interneta preuzima
 najnovije verzije drajvera, ali je ipak potrebno instalirati neke drajvere
 koje Windows nema.
 VM drajveri nude i dodatne mogućnosti za sam VM računar.
 Da bi se instalirali drajveri, otvara se Virtual Machine i bira se poslednja
 opcija Install VMware Tools.
 Nakon toga počinje instalacija koja je prilično automatizovana, sa svega
 nekoliko ekrana koji omogućuju podešavanja.
\end_layout

\begin_layout Standard
Dok virtuelni računar radi korisno je isprobati opcije samog VMware Playera.
 Izaberite opciju Virtual Machine u gornjem delu ekrana, a zatim Virtual
 Machine Settings.
 Postoji mnogo opcija koje se ne mogu menjati dok VM radi; kada se završi,
 sve opcije ponovo postaju dostupne.
 Sam operativni system Windows 7 ponaša se kao da je instaliran na fizičkom
 računaru sa svojstvima dodeljenim virtuelnom računaru.
 Zvanične, besplatne gotove virtuelne računare možete preuzeti sa adrese
 http://www.vmware.com/appliances/directory/ 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M29.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 26: Desnim pritiskom miša na Computer preko opcije Manage stižemo
 do podataka o računaru.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M30.PNG
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 27: Instalacija VMware drajvera protiče kao i instalacija svakog drugog
 drajvera/programa.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M31.PNG
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 28: Nakon instaliranih drajvera, treba restartovati računar.
\end_layout

\begin_layout Section*
Opcije za administriranje operativnog sistema Windows 7
\end_layout

\begin_layout Standard
Biranjem opcije Start i desnim pritiskom opcije Computer, zatim Properties,
 pojavljuje se ekran sa slike:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Windows7.1.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Biranjem opcije Advanced System Settings pojavljuje se dijalog System Properties
 sa osnovnim informacijama o sistemu:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Windows7.2.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
Biranjem kartice Advanced, Performance i pritiskom na dugme Settings pojavljuje
 se dijalog u kome je moguće menjati veličinu virtuelne memorije.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Windows7.3.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
Pritiskom na tastere Ctrl+Alt+Delete pojavljuje se Task Manager u kome se
 mogu videti svi procesi u sistemu, količina iskorišćene memorije i opterećenost
 procesora.
 U ovom prozoru procesi se mogu prinudno zaustavljati pritiskom na dugme
 End Process u donjem desnom uglu dijaloga.
 Takođe, procesi se mogu sortirati na osnovu korišćenja procesora i memorije.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Windows7.4.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
Kartica Performance u Task Manageru prikazuje vremenski dijagram opterećenosti
 procesora i korišćenja RAM memorije.
 Detaljniji prikaz svih procesa, niti, diskova, memorije i mreže u sistemu
 može se dobiti izborom opcije Start > All Programs > Accessories > System
 Tools > Resource Monitor:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Windows7.6.png
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Izborom opcije Start > All Programs > Accessories > System Tools > Disk
 Defragmenter pokreće se alatka za defragmentiranje diska:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Windows7.8.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
Start > Control Panel > System and Security > Administrative Tools > Computer
 Management > Disk Management otvara dijalog za prikaz sistema datoteka
 i particija diskova:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Windows7.7.png
	scale 45

\end_inset


\end_layout

\begin_layout Standard
U ovom prozoru vidimo da je disk C: formatiran u sistemu NTFS, kao i da
 postoji mala primarna particija D: koja nije formatirana (RAW).
\end_layout

\begin_layout Standard
Čitaocima se preporučuje da za vežbu pokušaju da pronađu odgovarajuće opcije
 za upravljanje virtuelnom memorijom, procesima i diskovima u svim ostalim
 operativnim sistemima opisanim u ovom dodatku.
\end_layout

\begin_layout Chapter*
Instaliranje virtuelnog operativnog sistema Ubuntu 11.04 
\end_layout

\begin_layout Standard
Nakon pokretanja VMWare Playera prikazuje se osnovni ekran programa.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M33.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 29: Da bismo kreirali novu virtuelnu mašinu, treba odabrati opciju
 "Create a New Virtual Machine".
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M34.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 30: Pojaviće se prozor za izbor instalacionog diska sistema.
 Pošto ne želimo da odmah instaliramo system, odabraćemo opciju I will install
 the operating system later i pritisnuti dugme Next.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M35.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 31: Prozor za izbor "gostujućeg" operativnog sistema.
 Nakon izbora opcija treba pritisnuti dugme Next.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M36.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 32: Prozor za unos naziva i izbor lokacije za virtuelnu mašinu.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M37.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 33: Izbor veličine i tipa virtuelnog diska.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M38.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 34: Prikaz izabranih opcija.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M39.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 35: Da bismo dodatno podesili virtuelnu mašinu, treba izabrati opciju
 Edit virtual machine settings.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M40.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 36: Prozor za detaljnija podešavanja virtuelne mašine; prikazano je
 podešavanje RAM memorije.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M41.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 37: Podešavanje mrežne kartice i tipa povezivanja.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M42.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 38: Podešavanje USB veze između HOST i VM računara.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M43.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 39: Izgled korisničkog interfejsa za virtuelni računar.
 Da bi se pokrenuo sistem, treba izabrati opciju Play virtual machine.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M44.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 40: Instalacioni interfejs.
 Za instalaciju treba izabrati opciju Install Ubuntu.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M45.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 41: Prozor sa informacijama o zahtevima pre instaliranja, opcijama
 za ažuriranje u toku instalacije i instalacijom određenih dodataka (npr.
 MP3 kodeka).
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M46.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 42: Prozor za alociranje prostora na disku.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M47.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 43: Prozor za podelu diska na particije.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M48.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 44: Nakon izbora opcije New Partition Table pojaviće se prozor upozorenja.
 Treba izabrati opciju Continue.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M49.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 45: Prozor za particionisanje sa virtuelnim diskom.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M50.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 46: Dodavanje nove primarne particije.
 Potrebno je odabrati veličinu, tip i tačku gde će se montirati nove particije.
 Preporučljivo je da tip particije bude ext4.
 Pod opcijom "Mount point" treba odabrati "/"..
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M51.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 47: Nakon potvrde dobijamo prikaz virtuelnog diska i njegovih particija.
\end_layout

\begin_layout Standard
Treba još samo napraviti swap particiju, a zatim nastaviti sa procesom instalaci
je.
 Pritiskom na free space i biranjem opcije Add pokrećemo proceduru za kreiranje
 nove particije.
 Može da postoji i više od dve particije.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M52.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 48: SWAP particija treba da bude bar 1.5 puta veća od kapaciteta RAM
 memorije računara.
 U praksi se često koristi odnos RAM memorije i SWAP particije 1:2.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M53.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 49: Nakon što se kreiraju primarna i swap particija, proces instalacije
 može da se nastavi.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M54.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 50: Završni korak instalacije.
 Nakon uspešne instalacije potrebno je izvaditi instalacioni CD i pritisnuti
 Enter da bi se računar restartovao.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M55.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 51: Pošto se računar ponovo pokrenuo, potrebno je prijaviti se na
 sistem.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M56.PNG
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 52: Kada se sistem pokrene, preporučljivo ga je ažurirati.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M57.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 53: Ako ima dostupnih zakrpa, sistem će nas obavestiti.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M58.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 54: Pre nego što počne sa instalacijom, sistem traži lozinku.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M59.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 55: Nakon završenog ažuriranja potrebno je restartovati računar.
 
\end_layout

\begin_layout Chapter*
Distribucije Linuxa
\end_layout

\begin_layout Standard
Linux kernel podržava multitasking sa prinudnom suspenzijom procesa (kako
 u sistemskom, tako i u korisničkom režimu), niti, virtuelnu memoriju, deljene
 biblioteke, upravljanje memorijom, Internet protokol itd.
 Linux je monolitno jezgro, što znači da se drajveri za uređaje, kao i dodaci
 za kernel nalaze i izvršavaju u prostoru kernela (tzv.
 nultom prstenu u većini arhitektura), sa izuzetkom nekoliko dodataka koji
 se pokreću u korisničkom prostoru.
 Time je omogućen potpun pristup hardveru.
 Grafički sistem, za razliku od MS Windowsa, nije deo kernela.
 Deljenje zadataka (procesa ili niti) omogućuje pravilno korišćenje prekida
 i bolju podršku za simetrično multiprocesiranje (SMP).
 Kraći je odziv, što Linux čini podesnijim za rad sa aplikacijama u realnom
 vremenu.
 Linux je većim delom pisan u nadograđenoj i donekle izmenjenoj verziji
 programskog jezika C, koju podržava kompajler GCC (GNU Compiler Collection).
 Zbog podržanih nadogradnji jezika C, GCC je dugo bio jedini kompajler sposoban
 da ispravno interpretira Linux jezgro.
 Linux koristi i druge programske jezike, npr.
 Perl, Python i jezike za shell scripting.
 Neki drajveri mogu biti napisani i u jezicima C++ i Fortran, ali to nije
 preporučljivo.
 Struktura sistema datoteka u Linuxu je takva da počinje od korena (root)
 i grana se na poddirektorijume.
 U Linuxu je sve datoteka (npr.
 uređaji kao što su disk, USB fleš memorije itd.).
 Datoteke u Linuxu se dele na sledeće tipove: 
\end_layout

\begin_layout Itemize
direktorijume (datoteke koje sadrže spisak drugih datoteka) 
\end_layout

\begin_layout Itemize
specijalne datoteke (mehanizmi korišćeni za ulaz i izlaz) 
\end_layout

\begin_layout Itemize
linkove (sistem koji omogućuje da pojedine datoteke budu vidljive u nekoliko
 direktorijuma, slično prečicama u Windowsu) 
\end_layout

\begin_layout Itemize
(domain) sockets - specijalan tip datoteke, sličan TCP/IP soketima (krajnjim
 tačkama komunikacije), koji omogućuje zaštitu internim umreženim procesima
 pomoću kontrole pristupa sistemu datoteka.
 
\end_layout

\begin_layout Itemize
named pipes –slično soketima, prave put preko koga komuniciraju procesi,
 ali ne koriste mrežnu logiku soketa.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M32.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 56: Linuxov sistem datoteka.
 
\end_layout

\begin_layout Standard
Devedesetih godina prošlog veka, ext2 je bio standardni system datoteka.
 Kada bi slučajno nestalo struje, korisnik bi često gubio podatke sa particij
 ext2.
 Zbog toga su dva projekta počela sa razvojem zamene za sistem ext2; bili
 su to ext3 i ReiserFs.
 Cilj projekta ext3 bio je da napravi brz system datoteka, i ukoliko bi
 došlo do pada sistema, bilo bi dovoljno da korisnik restartuje sistem,
 a ne i da proverava njegov integritet.
 Nedostatak sistema datoteka ext3 je to što ne može da povrati jednom obrisane
 datoteke.
 GNU/Linux podržava sledeće sisteme datoteka: ext2, ext3, ext4, ReiserFs,
 Journaled File System (JFS), XFS, NTFS.
 
\end_layout

\begin_layout Section*
Debian 
\end_layout

\begin_layout Standard
Debian je distribucija Linuxa sastavljena od softverskih paketa koji se
 distribuiraju kao besplatni i otvorenog koda pod GNU General Public licencom,
 kao i drugim open source licencama.
 To je jedna je od najuticajnijih distribucija koje koriste GNU OS alate
 i Linux kernel.
 Poznat je po strogoj privrženosti filozofiji otvorenog softvera, primeni
 saradnje u razvoju softvera i procesima testiranja.
 Popularan je i u server i u desktop varijanti.
 Projekat Debian je nezavisna decentralizovana organizacija koju ne podržava
 nijedna kompanija, kao što je to slučaj sa nekim distribucijama GNU/Linuxa
 (Ubuntu, OpenSUSE, Fedora, Mandriva...).
 Debian je osnova za mnoge druge distribucije, npr.
 Ubuntu, Dreamlinux, Knoppix, BackTrack itd.
 Sadrži preko 25.000 softverskih paketa za čak 12 procesorskih arhitektura.
 Standardna instalacija Debiana koristi grafičko okruženje GNOME, a nudi
 veliki broj programa korisnih za osnovne poslove na računaru.
 Pored okruženja GNOME, postoje gotove ISO slike na diskovima sa instaliranim
 grafičkim okruženjem KDE, zbirkom aplikacija, Xfce i LXDE.
 Pošto se Debian paketi ne ažuriraju između zvaničnih izdanja, postoje korisnici
 koji se odlučuju za verzije koje nisu stabilne ili se testiraju.
 Međutim, takve distribucije mogu prouzrokovati probleme u radu, čak i pad
 sistema.
 Za svaki Debian paket postoji osoba koja ga održava, prati izdanja autora
 i obezbeđuje usklađenost paketa sa ostatkom distribucije, kao i sa Debian
 politikom.
 Postoji dobro razvijen sistem za prijavljivanje, praćenje i ispravke grešaka.
 Trenutno aktuelne verzije Debian distribucije su:
\end_layout

\begin_layout Itemize
stabilna (Lenny).
 Zamrznuta zbog testiranja i ispravke grešaka.
 Ažurira se samo u slučaju većih bezbednosnih ispravki.
 
\end_layout

\begin_layout Itemize
test (Squeeze).
 Sadrži više paketa od stabilne, koji nisu dovoljno testirani da bi ušli
 u stabilnu distribuciju.
 Neprekidno se ažurira dok ne uđe u zamrznuto stanje.
 
\end_layout

\begin_layout Itemize
nestabilna (Sid).
 Sadrži pakete koji su trenutno u fazi razvoja.
 Ova verzija je predviđena za Debian programere koji učestvuju u projektu
 i potrebne su im najnovije biblioteke.
 
\end_layout

\begin_layout Standard
Instalacija softverskih paketa u distribuciji Debian obavlja se pomoću paketa:
\end_layout

\begin_layout Itemize
dpkg: uslužni program komandne linije za instaliranje, uklanjanje i obezbeđivanj
e informacija o lokalnim .deb paketima.
 GDebi proširuje funkcionalnost paketa dpkg mogućnošću instaliranja iz mrežnog
 skladišta i može se koristiti kako iz komandne linije, tako i u grafičkom
 interfejsu.
 
\end_layout

\begin_layout Itemize
apt: instaliranje paketa iz skladišta na mreži apt proširuje funkcionalnost
 dpkg mogućnostima pretraživanja, preuzimanja i instaliranja paketa iz mrežnog
 skladišta zajedno sa njihovim bibliotekama, bilo iz binarnih datoteka,
 bilo kompajliranjem izvornog koda.
 Služi i za nadogradnju paketa, kao i cele distribucije operativnog sistema.
 
\end_layout

\begin_layout Standard
Debian Live je verzija Debiana koje se može direktno pokrenuti sa prenosivih
 medijuma (CD/DVD ili USB fleš memorija) ili preko mreže, bez instaliranja
 na disk.
 Na taj način korisnik može da isproba Debian pre instalacije ili da ga
 koristi kao disk za podizanje sistema.
 Postoji gotova ISO slika sa Debian Live CD-om za spašavanje sistema u nekoliko
 verzija (GNOME, KDE, Xfce ...).
 Za instaliranje na disk koristi se Debian Installer koji se nalazi na CD-u.
 
\end_layout

\begin_layout Standard
Debian nema posebnih hardverskih zahteva osim onih uobičajenih za Linux
 kernel i GNU alate.
 Linux, a samim tim i Debian, podržava više procesora, tj.
 simetrično multiprocesiranje.
 Hardverski zahtevi su različiti zavisno od stepena instalacije, a rastu
 sa povećanjem broja instaliranih komponenti.
 Bez grafičkog okruženja zahteva 64MB memorije (preporučuje se 256MB) i
 1GB prostora na disku.
 Sa grafičkim okruženjem je potrebno 64MB memorije (preporučuje se 512MB)
 i 5GB prostora na disku.
 Preporučeni minimum za frekvenciju procesora je 1GHz (za desktop sisteme).
 
\end_layout

\begin_layout Section*
Backtrack 
\end_layout

\begin_layout Standard
Backtrack je najcenjenija i najkorišćenija Linux distribucija kada je reč
 o zaštiti informacionih sistema.
 Zasniva se na distribuciji Ubuntu, koristi grafički interfejs KDE i ima
 brojne bezbednosne i forenzičke alate.
 Kao i u distribuciji Ubuntu, skup alata je moguće ažurirati i proširivati
 koristeći mrežna skladišta (online repository).
 Aktuelna verzija Backtrack 4 R2 je besplatna.
 Backtrack je moguće instalirati i koristiti kao primarni operativni sistem
 ili ga pokretati sa LiveDVD-a ili USB diska.
 Prvo izdanje Backtracka pojavilo se 2007, a tokom godina se nametnulo kao
 standard za testiranje bezbednosti i digitalnu forenziku.
 Backtrack 4 nudi brojne aplikacije, od kojih su najinteresantnije: 
\end_layout

\begin_layout Itemize
Metasploit Framework: okruženje za testiranje bezbednosti operativnih sistema.
 Otvorenog je koda i sadrži najveću bazu testiranih propusta na svetu.
 
\end_layout

\begin_layout Itemize
Wireshark: popularan softver za analizu mrežnih protokola.
 Najvažnija funkcija ovog softvera je “hvatanje” paketa u mrežnom interfejsu
 i njihov detaljan prikaz radi analize.
 
\end_layout

\begin_layout Itemize
Nmap ili Network Mapper: program koji se koristi za pronalaženje hostova
 i servisa na računarskoj mreži.
 
\end_layout

\begin_layout Itemize
Hydra: alat za za proveru lozinki.
 
\end_layout

\begin_layout Itemize
Hashcat: jedan od najbržih alata za razbijanje heševa.
 
\end_layout

\begin_layout Itemize
Maltego: aplikacija za prikupljanje informacija i forenziku.
 
\end_layout

\begin_layout Itemize
Foremost: alat za rekonstruisanje obrisanih datoteka (file carving).
 
\end_layout

\begin_layout Itemize
MacChanger: alatka za promenu MAC adrese.
 
\end_layout

\begin_layout Itemize
S.E.T.: baza alata za socijalni inženjering.
 Može da klonira Web lokacije.
 
\end_layout

\begin_layout Chapter*
Instaliranje operativnog sistema FreeBSD
\end_layout

\begin_layout Standard
FreeBSD je slobodan operativni sistem iz grupe operativnih sistema Unix
 razvijen na Univerzitetu Berkli 1993 godine.
 Osnovni delovi, tj.
 slojevi ovog operativnog sistema su:
\end_layout

\begin_layout Itemize
Kernel
\end_layout

\begin_layout Itemize
Drajveri za periferne uređaje
\end_layout

\begin_layout Itemize
Skup korisničkih aplikacija i biblioteka 
\end_layout

\begin_layout Standard
FreeBSD je prvenstveno orijentisan ka okruženjima koja zahtevaju stabilnost,
 brzinu i sigurnost (npr.
 računski centri, klaster sistemi, složeni informacioni sistemi, simulacije
 ekperimenata itd).
 Sam sistem se može koristiti kao desktop okruženje u svakodnevnoj primeni.
 Instaliranje aplikacija obavlja se preko FreeBSD portova, koji maksimalno
 olakšavaju instalaciju aplikacija prisutnih u port sistemu.
 FreeBSD port sistem je skup javnih servera na kojima se nalaze aplikacije
 u paketima unapred podešenim za instaliranje.
 Prednost sistema FreeBSD nad Linuxom je to što aplikacije koje su razvijane
 za Linux rade i na FreeBSD-u, ali ne i obrnuto.
 FreeBSD omogućuje prilagođavanje radnog okruženja, a nudi brojne kernel
 module u osnovi sistema.
 Ugrađena podrška za skup mrežnih protokola TCP/IP, IPv6, SCTP, IPSec omogućuje
 lako integrisanje FreeBSD sistema u bilo koje okruženje bez instalacije
 dodatnih aplikacija.
 Opsluživanje velikog broja korisnika kroz servisne aplikacije kao sto su
 HTTP ili FTP server veoma se lako realizuje instalacijom samih servisa
 iz već pomenutih FreeBSD portova, dok se podešavanje obavlja brzo u konzoli
 operativnog sistema.
 Sistem za čuvanje podataka je preuzet od ranijih verzija UNIX-a i zove
 se UFS2 (Unix File System).
 Struktura direktorijuma je vrlo slična Linuxovoj.
 Bezbednost u okviru sistema implementirana je pomoću liste kontrola pristupa
 (ACL).
 FreeBSD (verzija 8.2) se sa adrese www.freebsd.org može preuzeti u nekoliko
 formata namenjenim različitim arhitekturama procesora.
 
\end_layout

\begin_layout Subsubsection*
Instaliranje operativnog sistema FreeBSD
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M61.PNG
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 57: Nakon podizanja sistema pojavljuje se meni sa sedam opcija od
 kojih pet omogućuju instaliranje operativnog sistema na različite načine.
 Izborom prve stavke menija instalacija započinje sa standardnim podešavanjima.
\end_layout

\begin_layout Standard
U sledećem koraku se bira željena zemlja/region u prikazanoj listi.
 Nakon izbora zemlje bira se raspored tastera na tastaturi.
 Izborom opcije Standard u listi, instalacija sistema se nastavlja sa standardim
 parametrima.
 Dodatne opcije ukazuju da se sistem može instalirati na različite načine.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M63.PNG
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 58: U ovom koraku može se promeniti raspored tastature, instalirati
 dokumentacija i učitati već pripremljeni parametri.
\end_layout

\begin_layout Standard
Pravljenje sistemske particije, swap i dodatnih particija obavlja se pomoću
 alata FDISK za particionisanje diska.
 Unošenjem parametra „C“ može se napraviti particija određene veličine,
 ali u ovom slučaju ceo disk će biti iskorišćen kao sistemska particija
 (izabrana je opcija „A“).
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M64.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 59: Pravljenje particija na disku.
\end_layout

\begin_layout Standard
Zatim se instalira upravljač podizanjem operativnog sistema (boot manager),
 izborom jedne od sledeće tri opcije: 
\end_layout

\begin_layout Enumerate
Standard – upravljač će biti statičan 
\end_layout

\begin_layout Enumerate
BootMgr – ako u računaru postoji još jedan operativni sistem, ova opcija
 omogućuje izbor sistema pri pokretanju računara.
 
\end_layout

\begin_layout Enumerate
None – upravljač neće biti instaliran 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M65.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 60: Instaliranje upravljača podizanjem sistema.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M66.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 61: U listi ponuđenih opcija treba odabrati lokaciju sa koje će sistem
 biti instaliran (CD/DVD).
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M67.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 62: U prikazanom obrascu mogu se podesiti mrežni parametri, ali je
 to moguće i posle instaliranja.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M69.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 63: Popunjavanje obrasca sa informacijama o korisniku kome će biti
 dozvoljen pristup sistemu.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M70.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 64: Nakon završetka instalacije i restartovanja računara, može se
 pristupiti sistemu.
\end_layout

\begin_layout Chapter*
Operativni sistemi za servere: Windows Server 2008
\end_layout

\begin_layout Standard
Windows Server je Microsoftov serverski operativni sistem.
 Ovaj Microsoftov proizvod ima samo izdanja optimizovana za ulogu servera
 u mrežnom okruženju, a to su Windows Server 2003 Standard Edition, Windows
 Server 2003 Enterprise Edition, Windows Server 2003 Datacenter Edition
 i Windows Server 2003 Web Edition.
 Sve verzije ovog operativnog sistema podržavaju deljenje datoteka i štampača,
 rade kao serveri aplikacija i serveri e-pošte, pružaju usluge autentifikacije
 korisnika, deluju kao sertifikaciono telo za sertifikate X.509, uravnotežuju
 mrežno opterećenje (Network Load Balancing - NLB) itd.
 Poslednja verzija Servera 2003 je Web Edition.
 Osnovna ideja s kojom je započeta realizacija ove verzije je želja Microsofta
 da novom verzijom Web servera, takozvanim IIS-om, nadmaši svoje glavne
 konkurente: Apache i Sun.
 Sa tim ciljem nekoliko funkcija osnovne verzije operativnog sistema je
 isključeno, a osiromašena verzija je ponuđena proizvođačima hardvera za
 prodaju zajedno sa serverima.
 Ta verzija može da pročita samo 2GB memorije (Windows 2000 je podržavao
 4GB), a onemogućene su i sledeće funkcije: 
\end_layout

\begin_layout Itemize
Ne radi kao kontroler domena (ali se može povezati na postojeći domen),
 
\end_layout

\begin_layout Itemize
Ne povezuje sisteme sa udaljenih lokacija putem „Terminal Services“ (ali
 podržava Remote Desktop Connection), 
\end_layout

\begin_layout Itemize
Nije moguće deljenje veze sa Internetom (Internet Connection Sharing) niti
 mrežno premošćavanje (Net Bridging), 
\end_layout

\begin_layout Itemize
Ne radi kao server za dinamičko dodeljivanje IP adresa (DHCP) i server za
 faks.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/M72.PNG
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 65: Izgled korisničkog interfejsa Windows Servera 2003 preko daljinske
 veze.
\end_layout

\begin_layout Standard
S pojavom operativnog sistema Windows NT 4, Microsoft je predstavio skuplju
 verziju Servera, pod nazivom NT 4 Server Enterprise koja je imala novu
 mogućnost klasterizacije i širi memorijski model.
 Windows Server 2003 Enterprise Edition i dalje podržava klasterizaciju
 (tada sa najviše četiri računara po klasteru).
 Pored toga, verzija Enterprise Edition omogućuje pokretanje servera iz
 "mrežnog skladišnog prostora" (Storage Area Network - SAN), „živo“ instaliranje
 (hot-install) memorije kao u verziji Datacenter, i ugradnju najviše četiri
 procesora.
 Windows Server 2003 sadrži jedan važan alat za administratore, a to je
 servis koji omogućuje upravljanje sistemom na način koji je bio moguć samo
 u „mainframe“ računarima pre mnogo godina, nazvan Windows Resource Manager.
 Windows Resource Manager omogućuje raspodelu resursa na način koji odgovara
 korisniku, npr.
 Može se zadati koliko će memorije ili procesorske snage moći da koristi
 SQL Server.
 Ovaj koristan alat dobija se samo u verziji Datacenter.
 Osim toga, Datacenter omogućuje klasterizaciju osam računara, kao i instaliranj
e memorije “na živo” što smo već pomenuli za verziju Enterprise.
 Treba samo da otvorite kućište, stavite nov memorijski modul, sačekate
 par sekundi i sistem automatski prepoznaje novu memoriju, bez potrebe za
 restartovanjem računara.
 
\end_layout

\begin_layout Standard
Aktuelna verzija je Windows Server 2008 R2.
 
\end_layout

\begin_layout Chapter*
Operativni sistemi za mobilne uređaje
\end_layout

\begin_layout Standard
Najpoznatiji operativni sistemi mobilnih uređaja su: Android, Symbian, Windows
 Mobile 7, iOS i Samsung Bada.
\end_layout

\begin_layout Standard
Android je operativni sistem otvorenog koda namenjen mobilnim telefonima
 i tablet računarima.
 Razvio ga je konzorcijum Open Handset Alliance u saradnji sa kompanijama
 Google, HTC, Sony, Dell, Intel, Texas Instruments i NVidia.
 Operativni sistem Android je zasnovan na Linuxovom kernelu.
 Sadrži module koji povezuju softverske komponente ili korisnike sa aplikacijama
, bibliotekama i interfejsima za programiranje (API) napisanim u programskom
 jeziku Java (Slika 66).
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/OS/Android
	scale 55

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 66: Osnovne komponente operativnog sistema Android.
\end_layout

\begin_layout Standard
Android koristi virtuelnu mašinu koja je projektovana tako da optimizuje
 memoriju i hardverske resurse u mobilnom okruženju.
 Za pisanje Android aplikacije prvenstveno se koristi razvojno okruženje
 za Javu.
 Trenutno na tržištu softvera (Android Market) postoji više od 250 000 aplikacij
a za telefone sa operativnim sistemom Android.
 Primena operativnog sistema Android počinje sa verzijom 1.0 koja se pojavila
 2008.
 godine.
 Tokom poslednje tri godine objavljeno je više verzija operativnog sistema
 Android, koje su se uglavnom sastojale od ispravki grešaka iz prethodnih
 verzija i novih funkcija.
 Aktuelna verzija je 3.2.
 
\end_layout

\begin_layout Chapter*
Dodatak A: Kratak uvod u jezik C
\begin_inset Index idx
status open

\begin_layout Plain Layout
jezik C
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Jezik C je izmišljen za potrebe projektovanja operativnog sistema koji bi
 mogao ponovo da se kompajlira (prevodi) za različite hardverske platforme
 (tj.
 za različite procesore).
 Pošto su operativni sistemi uglavnom programirani u jeziku C, ovaj jezik
 je prvi izbor kada je reč o programiranju bilo kakve aplikacije koja treba
 efikasno da komunicira sa operativnim sistemom.
\end_layout

\begin_layout Standard
Većina korisnika računara koji ne programiraju misle da je jezik C samo
 jedan od mnogobrojnih programskih jezika.
 To je međutim potpuno pogrešno: jezik C je zapravo osnova celokupnog računarstv
a.
 UNIX, Microsoft Windows, kancelarijske aplikacije, čitači Weba i još mnogo
 štošta drugog napisani su u jeziku C.
 Devedeset devet procenata vremena koje provodite ispred računara verovatno
 je potrošeno u nekoj aplikaciji programiranoj u jeziku C.
 Približno 70% open-source softvera je napisano u jeziku C, a preostalih
 30% u jezicima čiji su kompajleri ili interpreteri napisani u tom jeziku.
 
\end_layout

\begin_layout Standard
Takođe, za jezik C ne postoji zamena.
 Pošto on svoju namenu ispunjava gotovo savršeno, nikada se neće ni pojaviti
 potreba da se zameni nekim drugim jezikom.
 
\shape italic
Drugi jezici možda su pogodniji za druge namene, ali C svoju svrhu ispunjava
 savršeno.

\shape default
 Sigurno je da će još veoma dugo svi budući operativni sistemi biti pisani
 u jeziku C.
 Iz tog razloga poznavanje operativnih sistema ne može biti kompletno sve
 dok se ne savlada C programiranje.
 
\end_layout

\begin_layout Subsection*
Najjednostavniji C program
\end_layout

\begin_layout Standard
Počećemo od jednostavnog C programa kome ćemo dodavati osnovne elemente.
 
\end_layout

\begin_layout LyX-Code

\size small
#include <stdlib.h>
\end_layout

\begin_layout LyX-Code

\size small
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\size small
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
printf("Zdravo!
\backslash
n");
\end_layout

\begin_layout LyX-Code

\size small
return 3;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Snimite ovaj program u datoteci 
\family typewriter
zdravo.c
\family default
.
 Sada treba kompajlirati taj program.
 Kompajliranje (prevođenje) je postupak kojim se C kôd pretvara u asemblerske
 naredbe.
 Asemblerske naredbe su programski kôd koji procesor (80?86, SPARC, PowerPC
 ili neki drugi) može direktno da razume.
 Dobijena izvršna binarna datoteka je veoma brza jer je izvršava sâm procesor,
 tj.
 čip na matičnoj ploči koji bajt po bajt dohvata reč 
\family typewriter
Zdravo!
\family default
 iz memorije i izvršava svaku naredbu.
 Radni takt procesora (u megahercima) približno odgovara broju miliona naredbi
 u sekundi (
\shape italic
Mega Instructions Per Second
\shape default
, MIPS
\begin_inset Index idx
status open

\begin_layout Plain Layout
MIPS
\end_layout

\end_inset

) koje je procesor u stanju da izvrši.
 Interpretirani jezici (kao što su komandni skriptovi ili Java) mnogo su
 sporiji jer je procesor nije u stanju da razume takav kôd.
\end_layout

\begin_layout Standard
Izvršimo sada naredbu:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
gcc -Wall -o zdravo zdravo.c
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Opcija 
\family typewriter
-o zdravo
\family default
 kaže GNU C kompajleru 
\family typewriter
gcc
\family default
 (koji se u drugim operativnim sistemima zove 
\family typewriter
cc
\family default
) da napravi binarnu datoteku 
\family typewriter
zdravo
\family default
 umesto binarne datoteke standardnog naziva
\family typewriter
 a.out
\family default
 (koja bi se inače dobila kada se ne bi navela opcija 
\family typewriter
-o
\family default
 i ime datoteke).
 Opcija 
\family typewriter
-Wall
\family default
 znači da želimo da vidimo sva upozorenja (all warnings) tokom prevođenja.
 Ova opcija nije neophodna, ali je korisna za uočavanje i ispravljanje grešaka
 u programima.
 
\end_layout

\begin_layout Standard
Zatim, pokrenimo program komandom
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "20col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
./zdravo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
U jeziku C, sav kôd nalazi se unutar funkcija.
 Prva funkcija koju operativni sistem poziva jeste funkcija 
\family typewriter
main
\family default
.
\end_layout

\begin_layout Standard
Otkucajte 
\family typewriter
echo $?
\family default
 da biste videli povratni kôd programa.
 Videćete da je on 
\family typewriter
3
\family default
, odnosno povratna vrednost iz funkcije 
\family typewriter
main
\family default
 (vrednost iza naredbe 
\family typewriter
return
\family default
).
\end_layout

\begin_layout Standard
Treba primetiti i znakove navoda sa obe strane reči (stringa) koji se prikazuje
 na ekranu.
 U jeziku C, stringovi se navode unutar navodnika.
 Unutar string konstante (ovde 
\family typewriter
"Zdravo!"
\family default
), specijalna sekvenca 
\family typewriter

\backslash
n
\family default
 označava znak za novi red.
 U C programu primetićete i mnoštvo tačka-zapeta; svaka naredba u tom jeziku
 završava se znakom 
\family typewriter
;
\family default
 koji se mora navesti.
\end_layout

\begin_layout Standard
Sada probajmo sledeći program:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("broj %d, broj %d
\backslash
n", 1+2, 10);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
exit(3);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Komanda 
\family typewriter
printf
\family default
 služi za prikaz rezultata na ekranu.
 Istovremeno je ova funkcija i deo standardne biblioteke funkcija jezika
 C.
 Drugim rečima, određeno je da bilo koja implementacija jezika C mora da
 ima funkciju 
\family typewriter
printf
\family default
 koja treba da se ponaša na predviđen način.
\end_layout

\begin_layout Standard

\family typewriter
%d
\family default
 zadaje da ispis treba da bude u formatu decimalnog broja.
 Broj kojim se zamenjuje navodi se kao prvi argument funkcije 
\family typewriter
printf
\family default
 nakon string konstante (a to je u ovom slučaju 
\family typewriter
1+2
\family default
).
 Sledeći 
\family typewriter
%d
\family default
 biće zamenjen drugim argumentom (tj.
 brojem 
\family typewriter
10
\family default
).
 
\family typewriter
%d
\family default
 zove se 
\shape italic
specifikator formata
\shape default
; on u osnovi konvertuje ceo broj u decimalni prikaz.
 
\end_layout

\begin_layout Subsection*
Promenljive i tipovi
\end_layout

\begin_layout Standard
U jeziku C ne možete da koristite promenljivu bilo kad i bilo gde, ni bez
 dodeljene početne vrednosti, već kompajleru morate izričito da kažete pre
 svakog bloka kôda (naredbi koje se nalaze unutar para vitičastih zagrada)
 koje ćete promenljive koristiti unutar njega.
 To se postiže 
\shape italic
deklarisanjem
\shape default
 promenljivih.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int x;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int y;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
x = 10;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
y = 2;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("broj %d, broj %d
\backslash
n", 1+y, x);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
exit(3);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Naredba 
\family typewriter
int x
\family default
 je deklaracija promenljive.
 Ona programu kaže da treba da rezerviše prostor za jednu celobrojnu (integer)
 promenljivu kojoj će se kasnije pristupati preko imena 
\family typewriter
x
\family default
.

\family typewriter
 int
\family default
 je tip promenljive.
 
\family typewriter
x = 10
\family default
 je dodela vrednosti 
\family typewriter
10
\family default
 promenljivoj
\family typewriter
 x
\family default
.
 Postoje posebni tipovi za različite klase brojeva sa kojima se radi, kao
 i pridruženi specifikatori formata za njihov ispis.
\end_layout

\begin_layout Standard
Primetićete da se 
\family typewriter
%f
\family default
 koristi za brojeve u pokretnom zarezu obične i dvostruke tačnosti (tipovi
 
\family typewriter
float
\family default
 i 
\family typewriter
double
\family default
).
 To je zato što se tip 
\family typewriter
float
\family default
 uvek prvo konvertuje u tip 
\family typewriter
double
\family default
 pre operacija ovakvog tipa.
 
\end_layout

\begin_layout Subsection*
Funkcije
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
char a;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
short b;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int c;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
long d;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
float e;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
double f;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
long double g;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
a = 'A';
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
b = 10;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
c = 1000000;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
d = 1000000;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
e = 3.14159;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
f = 10e300;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
g = 10e300;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("%c, %hd, %d, %ld, %f, %f, %Lf
\backslash
n", a, b, c, d, e, f, g);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
exit(3);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
void pomnozi_i_prikazi (int x, int y) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("%d * %d = %d
\backslash
n", x, y, x * y);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
pomnozi_i_prikazi(30, 5);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
pomnozi_i_prikazi(12, 3);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
exit(3);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Ovde vidimo funkciju različitu od main koja se poziva iz funkcije main.
 Funkcija je prvo 
\shape italic
deklarisana
\shape default
 naredbom 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
void pomnozi_i_prikazi (int x, int y)
\end_layout

\begin_layout Standard
Ova deklaracija navodi povratni tip funkcije (u ovom slučaju 
\family typewriter
void
\family default
, jer funkcija ne vraća ništa), ime funkcije (
\family typewriter
pomnozi_i_prikazi
\family default
), a zatim i 
\shape italic
argumente
\shape default
 koji će joj biti prosleđeni.
 Brojevima koji će biti prosleđeni funkciji dodeljuju se imena, 
\family typewriter
x
\family default
 i 
\family typewriter
y
\family default
, a pre prosleđivanja funkciji oni se konvertuju u tip 
\family typewriter
x
\family default
 i 
\family typewriter
y
\family default
 (u ovom slučaju,
\family typewriter
 int
\family default
 i 
\family typewriter
int
\family default
).
 Stvarni C kôd koji čini telo funkcije stavlja se unutar vitičastih zagrada
 
\family typewriter
{
\family default
 i 
\family typewriter
}
\family default
.
\end_layout

\begin_layout Standard
Drugim rečima, gornji kôd je ekvivalentan sa:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
void pomnozi_i_prikazi () {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int x;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int y;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
x = <prvi_prosledjeni_broj>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
y = <drugi_prosledjeni_broj>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("%d * %d = %d
\backslash
n", x, y, x * y);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Subsection*
Naredbe
\family typewriter
 for
\family default
, 
\family typewriter
while
\family default
, 
\family typewriter
if
\family default
 i 
\family typewriter
switch
\end_layout

\begin_layout Standard
Lako je prepoznati format naredbi 
\family typewriter
for
\family default
, 
\family typewriter
while
\family default
 i 
\family typewriter
if
\family default
 bez dodatnih objašnjenja; C kôd se stavlja u blokove naredbi unutar vitičastih
 zagrada.
 Kao u većini programskih jezika, kada želimo da dodamo 
\family typewriter
1
\family default
 nekoj promenljivoj (tj.
 da je inkrementiramo), moramo da napišemo 
\family typewriter
x = x + 1
\family default
.
 U jeziku C skraćenica za inkrementiranje je 
\family typewriter
x++
\family default
, a za dekrementiranje (smanjivanje celobrojne promenljive za 
\family typewriter
1
\family default
) je 
\family typewriter
x--
\family default
.
 
\end_layout

\begin_layout Standard
Petlja for sadrži tri naredbe između zagrada 
\family typewriter
(...)
\family default
; prva naredba sadrži inicijalizaciju, druga je poređenje, a treća naredba
 koja se izvršava nakon svakog izvršavanja bloka naredbe.
 Blok naredbi nakon ključne reči 
\family typewriter
for
\family default
 ponavlja se sve dok rezultat poređenja ne postane netačan.
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main (int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int x;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
x = 10;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(x == 10) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("x je tacno 10
\backslash
n");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
x++;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
} else if (x == 20) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("x je jednako 20
\backslash
n");
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
} else {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("x nije ni 10 ni 20
\backslash
n");
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(x > 10) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("x je vece od 10
\backslash
n");
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
while(x > 0) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("x je %d
\backslash
n", x);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
x = x - 1;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(x = 0; x < 10; x++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("x je %d
\backslash
n", x);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
switch(x) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
case 9:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("x je devet
\backslash
n");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
break;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
case 10:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("x je deset
\backslash
n");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
break;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
case 11:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("x je 11
\backslash
n");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
break;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
default:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("sta li je x?
\backslash
n");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
break;
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Naredba 
\family typewriter
switch
\family default
 u zavisnosti od vrednosti argumenta koji se nalazi iza reči 
\family typewriter
switch
\family default
 odlučuje na koju će granu 
\family typewriter
case
\family default
 skočiti.
 U ovom slučaju to će očigledno biti 
\family typewriter
printf("x je 10
\backslash
n");
\family default
 zato što je promenljiva 
\family typewriter
x
\family default
 imala vrednost 
\family typewriter
10
\family default
 kada je završena prethodna 
\family typewriter
for
\family default
 petlja.
 Naredbe 
\family typewriter
break
\family default
 znače da petlja 
\family typewriter
switch
\family default
 treba da se završi i da se izvršavanje nastavlja iza nje.
 
\end_layout

\begin_layout Standard
Primetite da je operator poređenja u jeziku C 
\family typewriter
==
\family default
, a ne 
\family typewriter
=
\family default
.
 Simbol
\family typewriter
 =
\family default
 označava dodelu vrednosti promenljivoj, dok je 
\family typewriter
==
\family default
 operator poređenja.
\end_layout

\begin_layout Subsection*
Stringovi, nizovi i alokacija memorije
\end_layout

\begin_layout Standard
Niz brojeva u jeziku C se definiše kao
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
int y[10];
\end_layout

\begin_layout Standard
Sledeći program ilustruje korišćenje nizova.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int x;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
char y[11];
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(x = 0; x < 10; x++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
y[x] = x * 2;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(x = 0; x < 10; x++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("element %d je %d
\backslash
n", x, y[x]);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Ako niz sadrži znakove (tip 
\family typewriter
char
\family default
), onda se on zove 
\shape italic
string
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
string
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int x;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
char y[11];
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(x = 0; x < 10; x++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
y[x] = 65 + x * 2;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(x = 0; x < 10; x++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("element %d je %d
\backslash
n", x, y[x]);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
y[10] = 0;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("string je %s
\backslash
n", y);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Obratite pažnju da string mora da se završava nulom (tj.
 mora da bude 
\shape italic
null terminated
\shape default
).
 To znači da poslednji znak u nizu znakova (stringu) mora da bude 
\family typewriter
0
\family default
.
 Naredba 
\family typewriter
y[10] = 0
\family default
 postavlja jedanaesti element niza na nula.
 To istovremeno znači i da string mora da bude za jedan 
\family typewriter
char
\family default
 duži nego što očekujete.
\end_layout

\begin_layout Standard
Takođe, obratite pažnju da je prvi element niza 
\family typewriter
y[0]
\family default
, a ne 
\family typewriter
y[1]
\family default
kao u nekim drugim programskim jezicima.
\end_layout

\begin_layout Standard
U prethodnom primeru, red 
\family typewriter
y[11]
\family default
rezerviše 11 bajtova za string.
 Šta bi se desilo kada bi nam zatrebao string od 100 000 bajtova? C dozvoljava
 da se od jezgra operativnog sistema (kernela) zatraži memorija.
 To se zove 
\begin_inset Index idx
status open

\begin_layout Plain Layout
alociranje memorije
\end_layout

\end_inset


\shape italic
alociranje memorije
\shape default
.
 Svaki netrivijalni program za sebe će alocirati memoriju i nema drugog
 načina da se za program obezbede veći blokovi memorije koje bi koristio.
 Pogledajmo sledeći primer:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int x;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
char* y;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
y = malloc(11);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("%ld
\backslash
n", y);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(x = 0; x < 10; x++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
y[x] = 65 + x * 2;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
y[10] = 0;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("string je %s
\backslash
n", y);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
free(y);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Naredbom se deklariše promenljiva (broj) koja se zove 
\family typewriter
y
\family default
, a 
\shape italic
pokazuje
\shape default
 na neku lokaciju u memoriji.
 Zvezdica * u ovom slučaju označava 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivač
\end_layout

\end_inset

pokazivač (pointer).
 Na primer, ako imamo mašinu sa 256 megabajta memorije + swap memorija,
 onda bi promenljiva 
\family typewriter
y
\family default
 imala otprilike isti opseg.
 Numerička vrednost promenljive 
\family typewriter
y
\family default
 štampa se naredbom 
\family typewriter
printf("%ld
\backslash
n", y)
\family default
, ali ta vrednost programera ne zanima.
\end_layout

\begin_layout Standard
Kada program završi sa korišćenjem memorije, mora da je vrati operativnom
 sistemu pomoću naredbe 
\family typewriter
free
\family default
.
 Programi koji ne oslobađaju svu alociranu memoriju izazivaju tzv.
 curenje memorije
\begin_inset Index idx
status open

\begin_layout Plain Layout
curenje memorije
\end_layout

\end_inset

 (
\shape italic
memory leak
\shape default
).
\end_layout

\begin_layout Standard
Alociranje memorije često zahteva prethodni proračun da bi se odredila količina
 potrebne memorije.
 U prethodnom primeru alocirali smo prostor za 11 znakova.
 Pošto svaki znak (tip 
\family typewriter
char
\family default
) zauzima jedan bajt, to nije nikakav problem.
 Međutim, šta bi se desilo kada bi alocirali prostor za 11 celih brojeva
 (tip 
\family typewriter
int
\family default
)? Na PC računaru, jedan ceo broj zauzima 4 bajta (32 bita).
 Za određivanje veličine nekog tipa koristi se ključna reč 
\family typewriter
sizeof
\family default
.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int a;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int b;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int c;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int d;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int f;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int g;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
a = sizeof(char);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
b = sizeof(short);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
c = sizeof(int);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
d = sizeof(long);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
e = sizeof(float);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
f= sizeof(double);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
f= sizeof(long double);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("%d, %d, %d, %d, %d, %d, %d
\backslash
n", a, b, c, d, e, f, g);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Ovaj program prikazaće veličine svih tipova u bajtovima.
 Sada možemo lako da alociramo nizove drugih tipova (a ne samo znakova).
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int x;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int* y;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
y = malloc(10 * sizeof(int));
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("%ld
\backslash
n", y);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(x = 0; x < 10; x++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
y[x] = 65 + x * 2;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(x = 0; x < 10; x++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("%d
\backslash
n", y[x]);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
free(y);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Na mnogim mašinama tip 
\family typewriter
int
\family default
 zauzima 32 bita (4 bajta), ali to nikada ne treba uzeti za sigurno.
 
\shape italic
Uvek koristite ključnu reč 
\family typewriter
\shape default
sizeof 
\family default
\shape italic
za alociranje memorije
\shape default
.
\end_layout

\begin_layout Subsection*
Operacije sa stringovima
\end_layout

\begin_layout Standard
C programi verovatno češće rade sa stringovima nego sa bilo kojim drugim
 podacima.
 Evo programa koji rečenicu deli na reči:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <string.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int duzina_reci;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int i;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int duzina_recenice;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
char p[256];
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
char q;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
strcpy(p, "cao, moje ime je Nikola");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
duzina_recenice = strlen(p);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
duzina_reci = 0;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(i = 0; i <= duzina_recenice; i++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(p[i] == '' || i == duzina_recenice) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
q = malloc(duzina_reci + 1);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(q == 0) {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
perror("malloc je zakazao!");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
abort();
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
strncpy(q, p + i - duzina_reci, duzina_reci);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
q[duzina_reci] = 0;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("rec: %s
\backslash
n", q);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
free(q);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
duzina_reci = 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
} else {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
duzina_reci++
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Ovde uvodimo još tri funkcije standardne C biblioteke.
 
\family typewriter
strcpy
\family default
 je skraćenica za 
\family typewriter

\begin_inset Newline linebreak
\end_inset

str
\family default
ing
\family typewriter
c
\family default
o
\family typewriter
py
\family default
.
 Ova funkcija kopira bajtove sa jednog mesta na drugo redom, sve dok ne
 stigne do bajta nula (tj.
 do kraja stringa).
 Naredba 
\family typewriter
strcpy(p, "cao, moje ime je nikola")
\family default
kopira tekst u niz znakova 
\family typewriter
p
\family default
, koji se zove i odredište za kopiranje.
\end_layout

\begin_layout Standard

\family typewriter
strlen
\family default
 je skraćenica za 
\family typewriter
str
\family default
ing
\family typewriter
len
\family default
gth (dužinu niza).
 Ova funkcija određuje dužinu niza, što je ovde zapravo broj znakova uvećan
 za jedan (nulu na kraju znakovnog niza).
 
\end_layout

\begin_layout Standard
Da bismo se kretali kroz rečenicu, potrebna nam je 
\family typewriter
for 
\family default
petlja.
 Promenljiva 
\family typewriter
i
\family default
 prati trenutni položaj unutar rečenice.
\end_layout

\begin_layout Standard
Naredba kaže da kada naiđemo na znak ' ', to znači da smo stigli do kraja
 reči.
 Znamo i da je kraj rečenice takođe granica za reč, čak i ako na kraju rečenice
 nema razmaka (a po pravilu ga nema).
 Znak 
\family typewriter
||
\family default
 znači ili.
 Sada možemo da alociramo memoriju za tekuću reč i da kopiramo tu reč u
 memoriju.
 Za to će nam poslužiti funkcija 
\family typewriter
strncpy
\family default
.
 Ona kopira string, ali samo do granice od 
\family typewriter
duzina_reci
\family default
 znakova (poslednji argument).
 Poput funkcije 
\family typewriter
strcpy
\family default
, prvi argument je odredište kopije, a drugi argument je izvor odakle se
 kopira.
\end_layout

\begin_layout Standard
Da bismo izračunali položaj početka poslednje reči, koristimo izraz 
\end_layout

\begin_layout Standard

\family typewriter
p + i - duzina_reci
\end_layout

\begin_layout Standard
To znači da dodajemo 
\family typewriter
i
\family default
 na memorijsku lokaciju 
\family typewriter
p
\family default
, a zatim se vraćamo unazad za 
\family typewriter
duzina_reci
\family default
 da bismo postavili funkciju 
\family typewriter
strncpy
\family default
 na odgovarajući položaj.
\end_layout

\begin_layout Standard
Na kraju, string dopunjujemo krajnjom nulom u naredbi.
 Zatim možemo da odštampamo 
\family typewriter
q
\family default
, oslobodimo korišćenu memoriju naredbom 
\family typewriter
free
\family default
 i da nastavimo sa sledećom reči.
\end_layout

\begin_layout Subsection*
Strukture
\end_layout

\begin_layout Standard
U nekim programerskim zadacima dešava se da je potrebno objediniti nekoliko
 promenljivih različitih tipova da bi im se lakše pristupalo.
 Tipičan primer je adresa, koja se sastoji od kućnog broja, ulice, poštanskog
 broja, grada i države.
 Jezik C podržava pojam strukture koja objedinjuje nekoliko promenljivih
 različitih tipova: 
\family typewriter
int
\family default
, 
\family typewriter
char
\family default
, 
\family typewriter
float
\family default
, nizove, čak i druge strukture.
 Promenljive unutar strukture zovu se 
\shape italic
članovi strukture
\shape default
.
\end_layout

\begin_layout Standard
Za definisanje strukture koristi se ključna reč 
\family typewriter
struct
\family default
:
\end_layout

\begin_layout LyX-Code

\size small
struct ime_strukture{ 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
clanovi_strukture 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Evo primera koji definiše strukturu adrese:
\end_layout

\begin_layout LyX-Code

\size small
struct adresa{ 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
unsigned int kucni_broj; 
\end_layout

\begin_layout LyX-Code

\size small
char ulica[50]; 
\end_layout

\begin_layout LyX-Code

\size small
int post_broj;
\end_layout

\begin_layout LyX-Code

\size small
char grad[50];
\end_layout

\begin_layout LyX-Code

\size small
char drzava[50];
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Da bi se kreirala promenljiva tipa strukture, prvi način je da se nakon
 deklaracije strukture navedu nazivi promenljivih tipa te strukture:
\end_layout

\begin_layout LyX-Code

\size small
struct ime_strukture { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
clan_strukture; 
\end_layout

\begin_layout LyX-Code

\size small
...
 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} instanca_1,instanca_2 instanca_n;
\end_layout

\begin_layout Standard
Drugi način je da se promenljive tipa strukture deklarišu odvojeno od deklaracij
e strukture: 
\end_layout

\begin_layout LyX-Code

\size small
struct ime_strukture instanca_1,instanca_2 instanca_n;
\end_layout

\begin_layout Standard
Za pristup članovima strukture koristi se operator tačka (.) između imena
 strukture i podatka člana strukture:
\end_layout

\begin_layout Standard

\family typewriter
\size small
ime_strukture.clan_strukture
\end_layout

\begin_layout Standard
Na primer, da bi se pristupilo imenu ulice u strukturi adresa: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
struct adresa adr; 
\end_layout

\begin_layout Standard

\family typewriter
\size small
adr.drzava = "Srbija";
\end_layout

\begin_layout Subsection*
Rad sa datotekama
\end_layout

\begin_layout Standard
U većini programskih jezika, rad sa datotekama (fajlovima) podrazumeva tri
 koraka: 
\shape italic
otvaranje
\shape default
 datoteke, 
\shape italic
čitanje
\shape default
 iz datoteke ili 
\shape italic
upis
\shape default
 u nju, i na kraju 
\shape italic
zatvaranje
\shape default
.
 Da biste operativnom sistemu saopštili da ste spremni za rad sa datotekom,
 koristite naredbu 
\family typewriter
fopen
\family default
:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <string.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int c;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
FILE *f;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
f = fopen("mojtest.c","r");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(f ==0){
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
perror("fopen");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 1;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(;;) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
c = fgetc(f);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(c == -1)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
break;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("%c", c);
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
fclose(f);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Ovde je predstavljen nov tip: 
\family typewriter
FILE *
\family default
.
 Radi se o promenljivoj za rad sa datotekama koja mora biti inicijalizovana
 naredbom 
\family typewriter
fopen
\family default
 pre nego što se upotrebi.
 Funkcija 
\family typewriter
fopen
\family default
 ima dva argumenta: prvi je ime datoteke, a drugi je string koji objašnjava
 kako želimo da otvorimo datoteku (u ovom slučaju, 
\family typewriter
"r"
\family default
 znači čitanje od početka datoteke, dok bi 
\family typewriter
"w"
\family default
 značilo upis).
\end_layout

\begin_layout Standard
Ako je povratna vrednost funkcije 
\family typewriter
fopen
\family default
 nula, to znači da otvaranje datoteke nije uspelo.
 Funkcija 
\family typewriter
perror
\family default
 tada prikazuje tekstualnu poruku sa greškom (na primer, 
\family typewriter
No such file or directory
\family default
).
 Veoma je važno da se povratne vrednosti svih bibliotečkih poziva proveravaju
 na ovakav način.
 Takve provere činiće otprilike trećinu svakog C programa.
\end_layout

\begin_layout Standard
Komanda 
\family typewriter
fgetc
\family default
 čita znak iz datoteke.
 Bajt po bajt iz datoteke čita se redom sve dok se ne stigne do kraja datoteke,
 kada funkcija 
\family typewriter
fgetc
\family default
 vraća 
\family typewriter
-1
\family default
.
 Naredba 
\family typewriter
break
\family default
 kaže da u tom slučaju treba trenutno prekinuti petlju 
\family typewriter
for
\family default
 i nastaviti izvršavanje u redu 
\family typewriter
fclose(f)
\family default
.
 Naredbe 
\family typewriter
break
\family default
 mogu da se pojave i unutar petlje 
\family typewriter
while
\family default
.
\end_layout

\begin_layout Standard
Primetićete da je naredba 
\family typewriter
for
\family default
 prazna.
 To je dozvoljeno u jeziku C i označava beskonačnu petlju (iz koje se obično
 izlazi naredbom 
\family typewriter
break
\family default
 kada je ispunjen neki uslov).
\end_layout

\begin_layout Subsection*
Čitanje parametara iz komandne linije u C programima
\end_layout

\begin_layout Standard
Dosad ste se sigurno zapitali čemu služe 
\family typewriter
(int argc, char* argv)
\family default
 u funkciji main.
 To su argumenti koji se funkciji 
\family typewriter
main
\family default
 prosleđuju iz komandne linije.
 
\family typewriter
argc
\family default
 je ukupan broj argumenata (
\family typewriter
arg
\family default
ument 
\family typewriter
c
\family default
ount), a 
\family typewriter
argv
\family default
 (
\family typewriter
arg
\family default
ument 
\family typewriter
v
\family default
alue) je niz stringova za svaki argument.
 Njihovo prikazivanje je lako:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include<stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <string.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int i;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
for(i = 0; i < argc; i++) {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("argument %d je %s
\backslash
n", i, argv[i]);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Subsection*
Naredbe 
\family typewriter
#include
\family default
 i prototipovi
\end_layout

\begin_layout Standard
Na početku svakog programa postojaće jedna ili više naredbi 
\family typewriter
#include
\family default
.
 Ove naredbe kažu kompajleru da treba da učita drugi C program.
 U izvornom jeziku C nema mnogo načina za zaštitu od grešaka; na primer,
 funkcija 
\family typewriter
strcpy
\family default
 mogla bi da se koristi sa jednim, tri ili četiri argumenta i C program
 bi se i dalje kompajlirao.
 Međutim, prouzrokovao bi haos u internoj memoriji i krah programa.
 Drugi C programi zovu se 
\shape italic
datoteke zaglavlja
\shape default
 (header files).
 Oni sadrže opise kako bi funkcije trebalo da se koriste.
 Svaka funkcija koju poželite da upotrebite nalazi se u nekom zaglavlju,
 a njen opis se zove 
\shape italic
prototip funkcije
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
prototip funkcije
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Prototip funkcije se piše na isti način kao i sama funkcija, ali bez tela,
 tj.
 kôda.
 Na primer, prototip funkcije 
\family typewriter
brojanje_reci
\family default
 bio bi jednostavno
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
void brojanje_reci(char* ime_fajla);
\end_layout

\begin_layout Standard
Tačka-zapeta na kraju je neophodna da bi se prototip funkcije razlikovao
 od sâme funkcije.
\end_layout

\begin_layout Standard
Nakon što se definiše prototip funkcije, 
\family typewriter
gcc
\family default
 će se snažno usprotiviti svakom pokušaju da se ona upotrebi na način različit
 od predviđenog (npr.
 da joj se prosledi manje ili više argumenata ili da joj se proslede argumenti
 drugačijeg tipa).
\end_layout

\begin_layout Standard
\noindent
Primetićete da smo prilikom korišćenja funkcija za stringove dodali zaglavlje
 
\family typewriter
string.h
\family default
.
 Ako pokušamo da uklonimo red 
\family typewriter
#include <string.h>
\family default
 i da ponovo kompajliramo programe, pojaviće se sledeća greška:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
mojtest.c:21 warning: implicit declaration of function 'strncpy'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
koja objašnjava u čemu je problem.
\end_layout

\begin_layout Standard
Prototipovi funkcija daju jasnu definiciju načina korišćenja svake funkcije.
 U opisima Linux i UNIX komandi (tzv.
 man stranama, Dodatak B) prvo će biti naveden prototip funkcije da bi bilo
 jasno koji argumenti joj se prosleđuju i kog tipa treba da budu.
\end_layout

\begin_layout Subsection*
C komentari
\end_layout

\begin_layout Standard
C komentar označava se sa 
\family typewriter
/* komentar */
\family default
 i može da se proteže u više redova.
 Sve što se nalazi između znakova 
\family typewriter
/*
\family default
 i 
\family typewriter
*/
\family default
 kompajler ignoriše.
 Trebalo bi da postoji komentar za svaku funkciju, kao i za sve naredbe
 koje nisu očigledne.
 Važi pravilo da je program kome je potrebno mnogo komentara loše napisan.
 Takođe, nikada ne treba komentarisati nešto očigledno, niti objašnjavati
 
\shape italic
šta
\shape default
 kôd radi umesto 
\shape italic
kako
\shape default
 to radi.
 Ne preporučuje se 
\begin_inset Quotes eld
\end_inset

crtkanje
\begin_inset Quotes erd
\end_inset

 između funkcija, pa je bolje pisati ovako:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
/* vraca -1 ako se desi greska, prihvata pozitivan ceo broj */
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
int sqr(int x) {
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
...
\end_layout

\begin_layout Standard
nego ovako:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
/***********SQR *****************/
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
* x - argument koji se kvadrira *
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
* povratna vrednost = 
\begin_inset space \qquad{}
\end_inset

*
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
* -1 ako se desi greska 
\begin_inset space \qquad{}
\end_inset

*
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
kvadrat broja x (ako je OK)
\begin_inset space \qquad{}
\end_inset

*
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
*********************************/
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
int sqr(int x) {
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
...
\end_layout

\begin_layout Standard
U jeziku C++ dozvoljen je i komentar //, pri čemu se ignoriše sve od dvostruke
 kose crte do kraja reda.
 Ovakvu vrstu komentara prihvata i gcc, ali ga ne bi trebalo koristiti osim
 ako zaista ne programirate u jeziku C++.
 Često ćete videti da programeri stavljaju blokove kôda u komentar tako
 što ih okružuju direktivama #if 0 ...
 #endif; efekat je isti kao kada se stavi običan komentar, ali ovakva notacija
 omogućuje stavljanje komentara unutar komentara.
 Na primer:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int x = 10;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#if 0
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("debug: x je %d
\backslash
n", x); /* ispis debug informacija */
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
#endif
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
y = x + 10;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
...
\end_layout

\end_deeper
\begin_layout Subsection*
C makroi 
\family typewriter
#define
\family default
 i 
\family typewriter
#if
\end_layout

\begin_layout Standard
Sve što počinje znakom 
\family typewriter
#
\family default
 zapravo nije C, već tzv.
 
\shape italic
preprocesorska direktiva
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorska direktiva
\end_layout

\end_inset

.
 C program se prvo propušta kroz preprocesor koji uklanja sve viškove (poput
 komentara, naredbi 
\family typewriter
#include
\family default
 i svega ostalog što počinje znakom 
\family typewriter
#
\family default
).
 C program može da se učini mnogo čitljivijim ako se umesto konstantnih
 vrednosti definišu 
\begin_inset Index idx
status open

\begin_layout Plain Layout
makro
\end_layout

\end_inset


\shape italic
makroi
\shape default
.
 Na primer,
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
#define START_BUFFER_SIZE 256;
\end_layout

\begin_layout Standard
definiše tekst 
\family typewriter
START_BUFFER_SIZE
\family default
 kao konstantu 256.
 Nakon toga, gde god se u programu pojavi 
\family typewriter
START_BUFFER_SIZE
\family default
, kompajler će videti broj 256.
 To je mnogo elegantiniji stil programiranja jer kada bismo, na primer,
 poželeli da promenimo vrednost te konstante iz 256 u neki drugi broj, to
 bismo mogli da uradimo samo na jednom mestu.
 
\family typewriter
START_BUFFER_SIZE
\family default
 je takođe jasnije, što čini program razumljivijim.
\end_layout

\begin_layout Standard
Kad god vam je potrebna neka konstanta (kao što je 256), treba da je zamenite
 makroom koji se definiše na početku programa.
\end_layout

\begin_layout Standard
Postojanje makroa možete da proverite pomoću direktiva 
\family typewriter
#ifdef
\family default
 i 
\family typewriter
#ifndef
\family default
.
 Direktive 
\family typewriter
#
\family default
 zapravo su same za sebe mali programski jezik.
\end_layout

\begin_layout Subsection*
C biblioteke
\end_layout

\begin_layout Standard
Već smo pominjali standardnu biblioteku jezika C.
 Jezik C sam po sebi ne nudi gotovo ništa; sve što je korisno postoji kao
 spoljašnja funkcija.
 Spoljašnje funkcije grupisane su u biblioteke.
 Standardna C biblioteka pod Linuxom nalazi se u datoteci 
\family typewriter
/lib/libc.so.6
\family default
.
 
\end_layout

\begin_layout Standard
Mnoge funkcije biblioteke imaju odgovarajuće man strane, ali za neke uopšte
 ne postoji dokumentacija pa ćete morati da čitate komentare u zaglavljima.
 Funkcije je bolje ne koristiti osim ako niste sigurni da se radi o 
\shape italic
standardnim 
\shape default
funkcijama (u smislu da su podržane i na drugim sistemima).
\end_layout

\begin_layout Standard
Prilično je lako napraviti sopstvenu biblioteku.
 Recimo da imamo dve datoteke sa nekoliko funkcija koje želimo da kompajliramo
 u biblioteku.
 Te dve datoteke su 
\family typewriter
simple_math_sqrt.c
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
static int aps_greska(int a, int b) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(a > b)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
return a - b;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
return b - a;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int simple_math_isqrt(int x) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int rezultat;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(x < 0) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
fprintf(stderr, "simple_math_sqrt: vadjenje korena negativnog broja
\backslash
n");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
abort();
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
rezultat = 2;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
while(aps_greska (rezultat * rezultat, x) > 1) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
rezultat = (x / rezultat + rezultat) / 2;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return rezultat;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
i 
\family typewriter
simple_math_pow.c
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int simple_math_ipow(int x, int y) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
int rezultat;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(x == 1 || y == 0) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 1;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(x == 0 && y < 0) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
fprintf(stderr, "simple_math_ipow: podizanje nule na negativni stepen
\backslash
n");
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
abort();
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
if(y < 0)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
rezultat = 1;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
while(y > 0) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
rezultat = rezultat * x;
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
y--;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return rezultat;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
Biblioteku bismo želeli da nazovemo 
\family typewriter
simple_math
\family default
.
 Dobra je praksa da se sve funkcije biblioteke nazovu sa 
\family typewriter
simple_math_????
\family default
.
 Funkcija 
\family typewriter
aps_greska
\family default
 neće se koristiti izvan datoteke 
\family typewriter
simple_math_sqrt.c
\family default
 pa smo ispred nje stavili ključnu reč 
\family typewriter
static
\family default
, što znači da je reč o 
\shape italic
lokalnoj
\shape default
 funkciji.
\end_layout

\begin_layout Standard
Kôd možemo da kompajliramo na sledeći način:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
gcc -Wall -c simple_math_sqrt.c
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
gcc -Wall -c simple_math_pow.c
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Opcija 
\family typewriter
-c
\family default
 znači da želimo samo da kompajliramo, tj.
 ne želimo da dobijemo izvršnu datoteku.
 Biće generisane datoteke 
\family typewriter
simple_math_sqrt.o
\family default
 i 
\family typewriter
simple_math_pow.o
\family default
; to su tzv.
 
\shape italic
objektne datoteke
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
objektne datoteke
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Sada treba da 
\shape italic
arhiviramo
\shape default
 objektne datoteke u biblioteku, što ćemo postići pomoću naredbe 
\family typewriter
ar
\family default
:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "95col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
ar libsimple_math.a simple_math_sqrt.o simple_math_pow.o simple_math_pow.o
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
ranlib libsimple_math.a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Komanda 
\family typewriter
ranlib 
\family default
indeksira arhivu.
\end_layout

\begin_layout Standard
Biblioteka sada može da se upotrebi.
 Napravićemo datoteku 
\family typewriter
mojtest.c
\family default
:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdlib.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
int main(int argc, char* argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("%d
\backslash
n", simple_math_ipow(4, 3));
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
printf("%d
\backslash
n", simple_math_isqrt(50));
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
}
\end_layout

\begin_layout Standard
koju ćemo kompajlirati i pokrenuti pomoću komandi
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "80col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
gcc -Wall -c mojtest.c
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
gcc -o mojtest mojtest.o _L.
 -lsimple_math
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Prva naredba kompajlira datoteku 
\family typewriter
mojtest.c
\family default
 u 
\family typewriter
mojtest.o
\family default
, a druga naredba se zove 
\begin_inset Index idx
status open

\begin_layout Plain Layout
povezivanje programa
\end_layout

\end_inset


\shape italic
povezivanje programa 
\shape default
(linking).
 Povezivanjem se 
\family typewriter
mojtest.o
\family default
 i biblioteke objedinjuju u jedinstvenu izvršnu datoteku.
 Opcija 
\family typewriter
L.

\family default
 znači da sve biblioteke treba tražiti u tekućem direktorijumu (obično se
 pregledaju samo direktorijumi 
\family typewriter
/lib
\family default
 i 
\family typewriter
/usr/lib
\family default
).
 Opcija 
\family typewriter
-lsimple_math
\family default
 znači da treba napraviti biblioteku 
\family typewriter
libsimple_math.a
\family default
 (lib i a se automatski dodaju).
 Ova operacija se zove 
\begin_inset Index idx
status open

\begin_layout Plain Layout
statičko povezivanje
\end_layout

\end_inset


\shape italic
statičko povezivanje
\shape default
 jer se dešava pre izvršavanja programa, a umeće sve objektne datoteke u
 izvršnu datoteku.
\end_layout

\begin_layout Standard
Uzgred, često se dešava da se sa istim programom statički povezuju brojne
 datoteke.
 Tada je redosled povezivanja važan: biblioteka sa najmanje zavisnosti trebalo
 bi da bude poslednja, jer će se u suprotnom pojavljivati greške u referenciranj
u simbola.
\end_layout

\begin_layout Standard
Možemo i da napravimo zaglavlje 
\family typewriter
simple_math.h 
\family default
za korišćenje biblioteke:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
/* racuna kvadratni koren celog broja, odustaje u slucaju greske */
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
int simple_math_isqrt(int x);
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
/* racuna stepen celog broja, odustaje u slucaju greske */
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
int simple_math_ipow(int x, int y);
\end_layout

\begin_layout Standard
Na početak datoteke 
\family typewriter
mojtest.c
\family default
 dodaćemo 
\family typewriter
#include "simple_math.h"
\family default
: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
#include <stdlib.h>
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
#include <stdio.h>
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
#include "simple_math.h"
\end_layout

\begin_layout Standard
Ovim dodatkom rešićemo se upozoravajućih poruka 
\shape italic
implicit declaration of function
\shape default
.
 Pošto se zaglavlje 
\family typewriter
simple_math.h
\family default
 nalazi u istom direktorijumu kao i datoteka mojtest.c, ne navodimo zaglavlje
 unutar znakova < > već koristimo navodnike.
 
\end_layout

\begin_layout Subsection*
C projekti - Makefile
\end_layout

\begin_layout Standard
Šta se radi kada malo izmenimo samo jednu datoteku od mnogih, od kojih se
 sastoji C program (a to se često dešava u programiranju)? Mogli bismo da
 napišemo skript za kompajliranje i povezivanje, ali bi se pomoću njega
 sve ponovo kompajliralo, a ne samo izmenjena datoteka.
 Ono što nam zapravo treba jeste datoteka koja ponovo kompajlira samo objektne
 datoteke čiji se izvorni kôd promenio; za to služi uslužna alatka 
\family typewriter
make
\family default
.
 To je program koji kompajlira u skladu sa uputstvima iz datoteke 
\family typewriter
Makefile
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Makefile
\end_layout

\end_inset

 u tekućem direktorijumu.
 Datoteke 
\family typewriter
Makefile
\family default
 sadrže spiskove pravila i zavisnosti koji opisuju kako se dobija program.
 
\end_layout

\begin_layout Standard
Unutar datoteke 
\family typewriter
Makefile
\family default
 treba napisati pravila šta od čega zavisi, tako da ih protumači komanda
 
\family typewriter
make
\family default
, zajedno sa skript komandama neophodnim za postizanje svakog međucilja.
\end_layout

\begin_layout Standard
Prva zavisnost u našem postupku kompajliranja jeste to što 
\family typewriter
mojtest
\family default
 zavisi od obe biblioteke, 
\family typewriter
libsimple_math.a
\family default
 i objektne datoteke 
\family typewriter
mojtest.o
\family default
.
 U stilu komande make napisaćemo red u datoteci 
\family typewriter
Makefile
\family default
 koji izgleda ovako:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
mojtest:
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

libsimple_math.a mojtest.o
\end_layout

\end_inset


\end_layout

\begin_layout Standard
što znači da datoteke 
\family typewriter
libsimple_math.a
\family default
 i 
\family typewriter
mojtest.o
\family default
 moraju da postoje i da se ažuriraju pre datoteke 
\family typewriter
mojtest
\family default
.
 Datoteka 
\family typewriter
mojtest
\family default
 se zove ciljna datoteka komande 
\family typewriter
make
\family default
.
 Ispod ovog reda, moramo da navedemo kako će biti napravljena datoteka mojtest:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "90col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

gcc -Wall -o $@ mojtest.o -L.
 -lsimple_math
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
$@
\family default
 je ime sâme ciljne datoteke, što se zamenjuje sa mojtest.
 
\shape italic
Prazan prostor ispred komande gcc je tabulator
\shape default
, a ne znakovi za razmak.
\end_layout

\begin_layout Standard
Sledeća zavisnost je to što 
\family typewriter
libsimple_math.a
\family default
 zavisi od datoteka 
\family typewriter

\begin_inset Newline linebreak
\end_inset

simple_math_sqrt.o
\family default
 i 
\family typewriter
simple_math_pow.o
\family default
.
 To je još jedna zavisnost koju treba dodati, zajedno sa skriptom za kompajliran
je ciljne datoteke.
 Kompletno pravilo za 
\family typewriter
Makefile
\family default
 je:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "90col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
libsimple_math.a: simple_math_sqrt.o simple_math_pow.o
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

rm -f $@
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

ar rc $@ simple_math_sqrt.o simple_math_pow.o
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

ranlib $@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\shape italic
Ponovo ne zaboravite da se leva margina sastoji od jednog tabulatora, a
 ne od razmaka!
\end_layout

\begin_layout Standard
Poslednja zavisnost je to što datoteke 
\family typewriter
simple_math_sqrt.o
\family default
 i 
\family typewriter
simple_math_pow.o
\family default
 zavise od datoteka 
\family typewriter
simple_math_sqrt.c
\family default
 i 
\family typewriter
simple_math_pow.c
\family default
.
 To zahteva dva 
\family typewriter
make
\family default
 pravila za ciljnu datoteku, ali 
\family typewriter
make
\family default
 ima i skraćeni način za navođenje takvih pravila u slučaju većeg broja
 C datoteka sa izvornim kodom:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
.c.o:
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

gcc -Wall --c -o $*.o $<
\end_layout

\end_inset


\end_layout

\begin_layout Standard
što znači da bilo koja potrebna 
\family typewriter
.o
\family default
 datoteka može da se dobije od 
\family typewriter
.c
\family default
 datoteke sličnog imena pomoću komande 
\family typewriter
gcc -Wall -c -o $*.o $<
\family default
, gde je 
\family typewriter
$*.o
\family default
 ime objektne datoteke, a 
\family typewriter
$<
\family default
 je ime datoteke od koje 
\family typewriter
$*.o
\family default
 zavisi, redom.
\end_layout

\begin_layout Standard
Pravila u Makefile mogu da se stavljaju proizvoljnim redosledom, pa je najbolje
 prvo početi od najočiglednijih zbog razumljivosti.
 Postoji još jedno pravilo koje se stavlja pre svih:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
all:
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

libsimple_math.a mojtest
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ciljna datoteka all: je pravilo koje make pokušava da zadovolji ako se komanda
 make navede bez argumenata u komandnoj liniji.
 To znači da će 
\family typewriter
libsimple_math.a
\family default
 i 
\family typewriter
mojtest
\family default
 biti poslednje dve datoteke koje će biti napravljene, odnosno one se nalaze
 na vrhu liste zavisnosti.
\end_layout

\begin_layout Standard

\family typewriter
Makefile
\family default
 takođe ima sopstveni oblik promenljivih okruženja; primetili ste da smo
 tekst 
\family typewriter
simple_math
\family default
 koristili u tri pravila.
 Zbog toga ima smisla definisati makro, za slučaj da nam zatreba da promenimo
 ime biblioteke.
\end_layout

\begin_layout Standard
Naša konačna datoteka 
\family typewriter
Makefile
\family default
 izgleda ovako:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
# komentari pocinju znakom taraba #
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
# Makefile za pravljenje libsimple_math.a i programa mojtest
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
OBJS = simple_math_sqrt.o simple_math_pow.o
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
LIBNAME = simple_math
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
CFLAGS = -Wall
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
all: lib$(LIBNAME).a mojtest
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
mojtest:
\begin_inset space \qquad{}
\end_inset

lib$(LIBNAME).a mojtest.o
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

gcc $(CFLAGS) -o $@ mojtest.o -L.
 -l$(LIBNAME)
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
lib$(LIBNAME).a: $(OBJS)
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

rm -f $@
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

ar rc $@ $(OBJS)
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

ranlib $@
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
.c.o:
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

gcc $(CFLAGS) -c -o $*.o $<
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
clean:
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

rm -f *.o *.a mojtest
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sada je dovoljno samo da u tekućem direktorijumu otkucamo
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "15col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
make
\end_layout

\end_inset


\end_layout

\begin_layout Standard
i sve datoteke će biti 
\begin_inset Quotes eld
\end_inset

napravljene
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Primetićete da smo dodali još jednu nepovezanu ciljnu datoteku 
\family typewriter
clean:
\family default
.
 Ciljne datoteke mogu se direktno pokrenuti u komandnoj liniji:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "20col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
make clean
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ova komanda uklanja sve napravljene datoteke.
\end_layout

\begin_layout Standard
Datoteke 
\family typewriter
Makefile
\family default
 osim pravljenja C programa imaju i mnoge druge namene (za sve što treba
 da se napravi iz izvornih datoteka može da se u pomoć pozove 
\family typewriter
Makefile
\family default
).
\end_layout

\begin_layout Chapter*
Dodatak B: Kratak pregled UNIX komandi
\end_layout

\begin_layout Standard
Prilikom rada u terminalu UNIX-olikih sistema, treba znati sledeće:
\end_layout

\begin_layout Itemize
UNIX sistemi razlikuju mala i velika slova (tj.
 oni su case-sensitive).
 Ako se u komandi promeni samo jedno slovo iz malog u veliko ili obrnuto,
 to je sasvim drugačija komanda.
 Isto važi i za datoteke, direktorijume i sintaksu većine podržanih programskih
 jezika.
\end_layout

\begin_layout Itemize
Neke komande imaju opcije, tzv.
 flegove.
 Ista komanda može da se koristi u više varijanti (npr.
 
\family typewriter
ls -la
\family default
 ili 
\family typewriter
ls -a
\family default
; u ovom slučaju 
\family typewriter
ls
\family default
 je komanda za prikaz sadržaja tekućeg direktorijuma, fleg 
\family typewriter
-l
\family default
 kaže da treba ga prikaže u dužem formatu, a fleg 
\family typewriter
-a
\family default
 traži da se prikažu sve datoteke, čak i one skrivene).
 Flegovi se mogu kombinovati (tj.
 
\family typewriter
ls -al
\family default
 je isto što i 
\family typewriter
ls -a -l
\family default
).
 Između naziva komande i flegova stavlja se razmak.
\end_layout

\begin_layout Itemize
Većina komandi prihvata opcije 
\family typewriter
-h
\family default
 i 
\family typewriter
--help
\family default
 koje prikazuju kratak pregled načina njenog korišćenja.
 Ove opcije su korisne kada poznajete komandu a želite da se podsetite opcija;
 za komande koje ne poznajete počnite od 
\family typewriter
man
\family default
 strana koje ih detaljno opisuju.
 
\end_layout

\begin_layout Itemize
U istom redu može se zadati nekoliko komandi; u tom slučaju, one se razdvajaju
 tačkom\SpecialChar \-
zapetom, (npr.
 
\family typewriter
ls ; pwd
\family default
 prikazuje datoteke u tekućem direktorijumu, a nakon toga prikazuje koji
 je tekući direktorijum).
\end_layout

\begin_layout Itemize
Komande nisu prijateljske, tj.
 često se dešava da se nakon izvršenja komande u terminalu ne prikaže ništa.
 To je znak da je komanda uspešno izvršena; sistem će prikazati poruku samo
 ako se tokom izvršavanja komande desilo nešto nepredviđeno.
 
\end_layout

\begin_layout Itemize
U opštem slučaju, svaka komanda (npr.
 
\family typewriter
ls
\family default
, 
\family typewriter
cd
\family default
 itd.) se može posmatrati kao poseban program koji operativni sistem izvršava.
 Na primer, ako u terminalu otkucate 
\family typewriter
ls /etc
\family default
, program 
\family typewriter
ls
\family default
 biće pokrenut u direktorijumu 
\family typewriter
/etc
\family default
.
 Svaki program zahteva ulaz (u ovom slučaju, to je sadržaj direktorijuma)
 i proizvodi izlaz (tj.
 prikazuje rezultate).
 Često se dešava da programi treba da se pokrenu jedan za drugim.
 Na primer, mogli bismo da otvorimo datoteku i da nakon toga pokrenemo proverimo
 pravopis u njoj.
 Radeći to, mi zapravo povezujemo dva programa, odnosno izlaz prvog programa
 (otvaranja datoteke) šaljemo kao ulaz drugom programu (proveri pravopisa).
 Postupak kojim se izlaz jednog programa prosleđuje kao ulaz drugom programu
 zove se nadovezivanje komandi
\begin_inset Index idx
status open

\begin_layout Plain Layout
nadovezivanje komandi (piping)
\end_layout

\end_inset

 (piping).
 Može se nadovezati proizvoljan broj komandi.
 Nadovezivanje se označava simbolom | (pipe).
 Na primer, komanda 
\family typewriter
ls | spell | sort
\family default
 bi napravila spisak datoteka u tekućem direktorijumu, proverila pravopis
 spiska i na kraju sortirala pogrešno napisane reči koje bi bile prikazane
 na ekranu (pravilno napisane reči ne bi bile prikazane, jer je ulaz za
 komandu 
\family typewriter
sort
\family default
 izlaz komande 
\family typewriter
spell
\family default
).
 
\end_layout

\begin_layout Itemize
Džoker znakovi: 
\family typewriter
?
\family default
 zamenjuje jedan znak ili broj, 
\family typewriter
*
\family default
 zamenjuje nula ili više znakova i(li) brojeva.
 Možete ih koristiti na bilo kom mestu; na primer, 
\family typewriter
*p
\family default
 će pronaći sve reči koje se završavaju na, 
\family typewriter
p*
\family default
 sve one koje se počinju na 
\family typewriter
p
\family default
, a 
\family typewriter
tr?ka
\family default
 će pronaći reč 
\family typewriter
traka
\family default
.
 
\end_layout

\begin_layout Itemize
Datoteke čiji nazivi počinju tačkom su skrivene, najčešće zato da bi se
 izbeglo njihovo nehotično menjanje; možete ih prikazati komandom 
\family typewriter
ls -a
\family default
.
\end_layout

\begin_layout Itemize
Ako komanda kao argument očekuje naziv datoteke ili direktorijuma, oni joj
 se mogu proslediti na dva načina.
 Ako se komanda izvršava u istom direktorijumu u kome se nalazi i datoteka
 (tj.
 datoteka se nalazi u tekućem direktorijumu), onda se njen naziv može uneti
 direktno (npr.
 
\family typewriter
cp moja_datoteka nova_datoteka
\family default
).
 U suprotnom, može se uneti kompletna putanju do datoteke, npr.
 
\family typewriter

\begin_inset Newline linebreak
\end_inset

cp /home/korisnik\SpecialChar \-
/moja_datoteka /home/korisnik/nova_datoteka
\family default
).
 Administratori često koriste i označavanje 
\family typewriter
./moja_datoteka
\family default
, gde je 
\family typewriter
./
\family default
 skraćenica za tekući direktorijum.
 Nazivi datoteka koji počinju kosom crtom 
\family typewriter
/
\family default
 zovu se apsolutne putanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
apsolutna putanja
\end_layout

\end_inset

, i odnose se na putanju počev od korenskog (root) direktorijuma čija je
 oznaka 
\family typewriter
/
\family default
.
 Nazivi koji ne počinju kosom crtom zovu se relativne putanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
relativna putanja
\end_layout

\end_inset

 i odnose se na putanju u odnosu na tekući direktorijum, odnosno lokaciju
 u sistemu datoteka gde se trenutno nalazite.
 
\end_layout

\begin_layout Itemize
Kada u terminalu otkucate komandu, ona mora da se učita sa diska iz jednog
 od nekoliko uobičajenih direktorijuma gde se čuvaju komande.
 Komanda se raspoređuje u stablu direktorijuma u skladu sa tipom, a ne u
 skladu sa tim kom softverskom paketu pripada.
 Tako na primer izvršna datoteka programa za obradu teksta može da se nalazi
 u direktorijumu gde se čuvaju izvršne datoteke, a odgovarajuće datoteke
 sa fontovima čuvaju se tamo gde su smešteni fontovi drugih programa.
 Kada u terminalu otkucate komandu sa putanjom, npr.
 
\family typewriter
/bin/cp
\family default
, sistem će pokušati da izvrši komandu 
\family typewriter
cp
\family default
 iz direktorijuma 
\family typewriter
/bin
\family default
.
 Ako otkucate samo 
\family typewriter
cp
\family default
, pokušaće da pronađe komandu 
\family typewriter
cp
\family default
 u svim poddirektorijumima promenljive okruženja 
\family typewriter
PATH
\family default
.
 Da biste videli koja vam je putanja, otkucajte 
\family typewriter
echo $PATH
\family default
.
 Postoje i komande za prilagođavanje okruženja pomoću kojih možete (trajno
 ili privremeno) da menjate vrednost promenljive 
\family typewriter
PATH
\family default
.
\end_layout

\begin_layout Itemize
Često je potrebno preusmeriti izlaz komande u datoteku; za to se koristi
 simbol 
\family typewriter
>
\family default
 (na primer, komanda ls 
\family typewriter
/usr/local/bin > lokalni.programi.txt
\family default
 preusmerava listu sadržaja direktorijuma 
\family typewriter
/usr/local/bin
\family default
 u datoteku 
\family typewriter
lokalni.programi.
\begin_inset Newline linebreak
\end_inset

txt
\family default
 (na ekranu se neće prikazati ništa).
 Ako želite da dopišete rezultat na kraj postojeće datoteke, upotrebite
 simbol >> (npr.
 
\family typewriter
ls/usr/bin >> svi.programi.txt
\family default
).
 Komande možete da nadovezujete i preusmeravate u isto vreme (npr.
 
\family typewriter
ls | wc -l >> infodir 
\family default
broji koliko stavki ima u tekućem direktorijumu i upisuje taj broj u datoteku
 
\family typewriter
infodir
\family default
).
\end_layout

\begin_layout Subsection*
Osnovne komande
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="22" columns="2">
<features islongtable="true" longtabularalignment="left">
<column alignment="center" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="60text%">
<row endhead="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Komanda
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
apropos komanda
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pronalazi odgovarajuće man strane za komandu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cat datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje sadržaj datoteke na ekranu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cat datoteka1 datoteka2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje datoteku1 i datoteku2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cd
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća se u home direktorijum sa bilo kog mesta
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cd ..
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pomera se za jedan nivo iznad u stablu direktorijuma
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cd /etc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pomera se u direktorijum /etc u odnosu na korenski (root) direktorijum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cd ~/poddirektorijum
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Znak ~ je korisna prečica za home direktorijum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cd Projekti
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pomera se u direktorijum Projekti relativno u odnosu na tekući direktorijum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
exit (Ctrl + D)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Završava trenutni proces (obično terminal)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
less datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje sadržaj datoteke ekran po ekran
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
logout
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Završava UNIX sesiju
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ls
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje spisak datoteka i direktorijuma
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ls /
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje spisak datoteka u korenskom (root) direktorijumu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ls /direktorijum
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje sadržaj direktorijuma 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ls -a
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje sve datoteke i direktorijume, uključujući i skrivene
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ls -l
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje sadržaj direktorijuma uz dodatne informacije
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
man komanda
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje man (manual) strane koje opisuju komandu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
more datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje sadržaj datoteke ekran po ekran
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
passwd
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Menja lozinku
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
pwd
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje putanju i naziv direktorijuma u kome se nalazite
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
su -username
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prijavljuje vas kao korisnika 
\family typewriter
username
\family default
 bez potrebe da se odjavljujete
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection*
UNIX direktorijumi i njihov sadržaj
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="25" columns="2">
<features islongtable="true" longtabularalignment="left">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="70text%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Direktorijum
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Sadržaj
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/bin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Osnovni programi i komande koje koriste svi korisnici sistema
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/boot
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Datoteke koje koristi bootloader
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/dev
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Uređaji (CD-ROM, USB i sl.) i specijalne datoteke
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/etc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Datoteke za konfiguraciju sistema i globalna podešavanja
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/home
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Matični (home) direktorijumi korisnika
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/lib
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Osnovne deljene biblioteke i moduli jezgra operativnog sistema
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/mnt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tačka gde se montiraju (mount) privremeni sistemi datoteka
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/opt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Direktorijum za dopunske softverske pakete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/proc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jezgro (kernel) i informacije o procesima
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/root
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Matični (home) direktorijum administratora sistema (root korisnika)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/sbin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Osnovne komande i programi za podizanje sistema
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/tmp
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Privremene datoteke
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/usr/bin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komande i programi koji nisu toliko značajni za sistem kao oni koji se nalaze
 u direktrorijumu 
\family typewriter
/bin
\family default
 ali se instaliraju zajedno sa operativnim sistemom
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/usr/include
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Standardna zaglavlja (include file) za C programe
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/usr/lib
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Biblioteke za programiranje i za instalirane pakete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/usr/local
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Većina datoteka i podataka koji su prilagođeni u sistemu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/usr/local/bin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lokalno programirani ili instalirani paketi
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/usr/local/man
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Man strane za lokalne pakete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/usr/src
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Izvorni (source) kôd standardnih programa
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/usr/share
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deljene datoteke (nezavisne od sistema)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/var
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Promenljivi podaci: dnevnici sistema (log), privremeni podaci iz programa,
 poruke e-pošte korisnika i sl.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/var/account
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dnevnici prijavljivanja na sistem
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/var/lock
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zaključane datoteke koje su napravili različiti programi
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
/var/log
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Datoteke i direktorijumi sa dnevnicima (log)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection*
Korišćenje datoteka i direktorijuma
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features islongtable="true" longtabularalignment="left">
<column alignment="center" valignment="top" width="40text%">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Komanda
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cp postojeca_datoteka nova_datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kopira postojeću datoteku u novu datoteku
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cp -i postojeca_datoteka stara_datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kopira postojeću datoteku u staru datoteku, ali pritom pita za dozvolu da
 je prepiše
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cp -r /Projekti /shared/Projekti
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kopira direktorijum 
\family typewriter
/Projekti
\family default
 u novo ime 
\family typewriter
/shared/Projekti
\family default
 uz naznaku da je reč o rekurzivnom kopiranju (
\family typewriter
-r
\family default
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
find -name izgubljeno -print
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pronalazi datoteku u tekućem direktorijumu ili poddirektorijumima koji se
 zovu 
\family typewriter
izgubljeno
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
mkdir Nov_direktorijum
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pravi nov direktorijum koji se zove 
\family typewriter
Nov_direktorijum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
mv postojeca_datoteka nova_datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preimenuje 
\family typewriter
postojecu_datoteku
\family default
 u 
\family typewriter
nova_datoteka
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
mv -i stara_datoteka nova_datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preimenuje 
\family typewriter
staru_datoteku
\family default
 u 
\family typewriter
novu_datoteku
\family default
 i zahteva od sistema da traži dozvolu pre nego što prepiše (uništi) stare
 datoteke
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
rm -i *
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interaktivno brisanje sadržaja tekućeg direktorijuma, uz traženje dozvole
 pre brisanja.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
rm -i nepotrebna_dat
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interaktivno briše datoteku 
\family typewriter
nepotrebna_dat
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
rm -ir dan*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interaktivno brisanje svih datoteka i direktorijuma koji počinju sa 
\family typewriter
dan
\family default
 u tekućem direktorijumu, kao i svih datoteka i direktorijuma u poddirektorijumi
ma koji počinju sa 
\family typewriter
dan
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
rmdir Direktorijum
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Briše prazan direktorijum 
\family typewriter
Direktorijum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
touch nova_datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pravi praznu datoteku 
\family typewriter
nova_datoteka
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
which komanda
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pronalazi kompletnu putanju do komande 
\family typewriter
komanda
\family default
.
 Korisno za pronalaženje da li se neka komanda uopšte nalazi na putanji,
 odnosno ako ih ima više, za saznavanje koja će se od njih izvršiti.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
Upravljanje vlasništvom i dozvolama
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features islongtable="true" longtabularalignment="left">
<column alignment="center" valignment="top" width="40text%">
<column alignment="left" valignment="middle" width="50text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Komanda
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chgrp
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Menja pridruženost datoteka ili direktorijuma određenoj grupi
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chgrp grupa datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Menja pridruženost datoteke 
\family typewriter
datoteka
\family default
 grupi 
\family typewriter
grupa
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chgrp -R grupa direktorijum
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rekurzivno menja pridruženost 
\family typewriter
direktorijuma
\family default
 i svih njegovih poddirektorijuma grupi 
\family typewriter
grupa
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chmod
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Menja dozvole za datoteku
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chmod a-w datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Uklanja dozvolu upisa (
\family typewriter
write, w
\family default
) u 
\family typewriter
datoteku
\family default
 za sve (
\family typewriter
all, a
\family default
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chmod g+w datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dodaje dozvolu upisa u 
\family typewriter
datoteku
\family default
 za tekuću grupu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chmod -R go-rwx *
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Povlači sve dozvole od svih osim od korisnika za sve datoteke u tekućem
 direktorijumu, njegovim poddirektorijumima i sadržajem
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chmod u=rwx, g=rx, o=r datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja dozvole za datoteku tako da korisnik može da je čita, upisuje
 i izvršava, grupa da čita i izvršava (
\family typewriter
execute, x
\family default
), a drugi (
\family typewriter
others, o
\family default
) samo da je čitaju (
\family typewriter
read, r
\family default
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chmod ugo=*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Povlači sve dozvole za sve u tekućem direktorijumu od svih
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chown
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Menja vlasništvo nad datotekom ili direktorijumom
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chown -R korisnik Direktorijum
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rekurzivno menja vlasništvo 
\family typewriter
Direktorijuma
\family default
 i njegovog kompletnog sadržaja i dodeljuje ga korisniku
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
chown korisnik datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Menja vlasništvo nad datotekom i dodeljuje ga korisniku
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection*
Rad sa datotekama
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="2">
<features islongtable="true" longtabularalignment="left">
<column alignment="center" valignment="top" width="40text%">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Komanda
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cmp stara_datoteka nova_datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Poredi 
\family typewriter
staru_datoteku
\family default
 sa 
\family typewriter
novom_datotekom
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
crypt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Šifruje ili dešifruje datoteku zaštićenu lozinkom
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
diff -b stara_datoteka nova_datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pronalazi razlike (uz zanemarivanje praznih redova) između 
\family typewriter
stare_datoteke
\family default
 i 
\family typewriter
nove_datoteke
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
diff Stari_direktorijum Nov_direktorijum
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pronalazi razlike između 
\family typewriter
Starog_direktorijuma
\family default
 i 
\family typewriter
Novog_direktorijuma
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
diff -i nova_datoteka stara_datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pronalazi razlike između 
\family typewriter
nove_datoteke
\family default
 i 
\family typewriter
stare_datoteke
\family default
 uz zanemarivanje malih i velikih sloka
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
grep izraz datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pronalazi 
\family typewriter
izraz
\family default
 u 
\family typewriter
datoteci
\family default
 i prikazuje redove koji sadrže 
\family typewriter
izraz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
grep -c izraz datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Broji koliko puta se 
\family typewriter
izraz
\family default
 pojavljuje u 
\family typewriter
datoteci
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
grep -v izraz datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pronalazi sve redove u 
\family typewriter
datoteci
\family default
 koji ne sadrže 
\family typewriter
izraz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
head datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje prvih deset redova 
\family typewriter
datoteke
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
sort datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sortira 
\family typewriter
datoteku
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
sort -n datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sortira 
\family typewriter
datoteku
\family default
 numerički
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
tail datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje poslednjih deset redova 
\family typewriter
datoteke
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
wc -b datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Broji koliko 
\family typewriter
datoteka
\family default
 ima bajtova
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
wc datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Broji redove, reči i bajtove u 
\family typewriter
datoteci
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
wc -l datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Broji redove u 
\family typewriter
datoteci
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
wc -w datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Broji reči u 
\family typewriter
datoteci
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ispell datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interaktivno proverava pravopis u 
\family typewriter
datoteci
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection*
Prikazivanje informacija o sistemu
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="2">
<features islongtable="true" longtabularalignment="left">
<column alignment="center" valignment="top" width="40text%">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Komanda
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
df
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje instalirane diskove, lokaciju montiranih sistema datoteka, količinu
 iskorišćenog i slobodnog prostora
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
df /usr/local/src
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pronalazi gde je montiran 
\family typewriter
/usr/local/src
\family default
 i koliko na njemu ima mesta
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
du
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje informacije o korišćenju diska (disk usage) u tekućem direktorijumu
 i njegovim poddirektorijumima
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
du /home
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pronalazi informacije o korišćenju diska u direktorijumu 
\family typewriter
/home
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
du -k
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje informacije o korišćenju diska u kilobajtima
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
file /usr/bin/pico
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje kog je tipa datoteka 
\family typewriter
/usr/bin/pico
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
finger
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje ko je još prijavljen na sistem
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
id
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje numeričku vrednost korisničkog imena prijavljenog korisnika
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
id korisnik
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje pripadnost 
\family typewriter
korisnika
\family default
 grupama
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
quota
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje da li je korisnik premašio dodeljenu kvotu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
quota -v
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje trenutna podešavanja kvote i njenu iskorišćenost za prijavljenog
 korisnika
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
uname
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje podatke o vrsti UNIX sistema koji se izvršava
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
uname -a
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje sve informacije o sistemu, uključujući tip sistema, ime računara,
 verziju i hardver
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
w
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje informacije o drugim korisnicima sistema i njihovim aktivnostima
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
who
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje informacije o drugim korisnicima sistema
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
whoami
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje sa kojim korisničkim nalogom ste trenutno prijavljeni u sistemu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
bc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kalkulator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
cal
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje kalendar za tekući mesec
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
Upravljanje procesima
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features islongtable="true" longtabularalignment="left">
<column alignment="center" valignment="top" width="30text%">
<column alignment="left" valignment="top" width="60text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Komanda
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Ctrl + Z
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Suspenduje posao, program ili proces koji se trenutno izvršava
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
kill %ftp
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Ubija
\begin_inset Quotes erd
\end_inset

 proces po imenu 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
kill 16217
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Ubija
\begin_inset Quotes erd
\end_inset

 proces sa brojem 16127
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
kill -9 16217
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Ubija
\begin_inset Quotes erd
\end_inset

 proces sa brojem 16127; fleg -9 omogućuje i ukidanje procesa koje obična
 komanda kill ne 
\begin_inset Quotes eld
\end_inset

ubija
\begin_inset Quotes erd
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
nice
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pokreće posao 
\begin_inset Quotes eld
\end_inset

nežnije
\begin_inset Quotes erd
\end_inset

, tj.
 sporije i sa manjim uticajem na sistem i druge korisnike
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ps 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje trenutne procese prijavljenog korisnika
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ps -a
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje sve procese svih korisnika
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ps -f
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje stablo procesa (forest), tj.
 procese i njihove međusobne veze
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
ps -x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje sistemske procese (demone)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
top
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nadgleda opterećenje sistema i procese u realnom vremenu
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
Rad sa kodiranim i(li) komprimovanim datotekama
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features islongtable="true" longtabularalignment="left">
<column alignment="center" valignment="top" width="40text%">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Komanda
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape slanted
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
compress -c datoteka.tar > datoteka.tar.Z
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komprimuje datoteku 
\family typewriter
datoteka.tar
\family default
 sa istim imenom uz dodatak ekstenzije 
\family typewriter
Z
\family default
 uz istovremeno zadržavanje originalne datoteke
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
compress datoteka.tar
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komprimuje datoteku.tar uz njenu zamenu arhivom kojoj se dodaje nastavak
 
\family typewriter
.Z
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
gunzip arhiva.tar.gz
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Raspakuje datoteku 
\family typewriter
arhiva.tar.gz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
gzip arhiva.tar
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komprimuje 
\family typewriter
arhivu.tar
\family default
.
 Spakovana datoteka zameniće originalnu i imaće dodatak 
\family typewriter
.gz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
gzip -d
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dekomprimuje (raspakuje) datoteku
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
tar -cf nova_datoteka.tar Direktorijum
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pravi novu 
\family typewriter
tar
\family default
 arhivu koja sadrži sve datoteke i direktorijume iz 
\family typewriter
Direktorijuma
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
tar -v
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opisuje šta se dešava tokom arhiviranja (
\family typewriter
v, verbose
\family default
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
tar -xf arhiva.tar
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Raspakuje sadržaj 
\family typewriter
arhive.tar
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
uncompress -c arhiva.tar.Z > arhiva.tar
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dekomprimuje (raspakuje) sadržaj 
\family typewriter
arhive.tar.Z
\family default
 uz zadržavanje originalne arhive
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
unzip zipovano
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Raspakuje 
\family typewriter
zipovano
\family default
 bez posebnog nastavka imena
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
zip zipovano datoteka
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pravi novu datoteku koja će se zvati 
\family typewriter
zipovano
\family default
 od 
\family typewriter
datoteke
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-19"

\end_inset

A.
 Silberschatz, P.B.
 Galvin, G.
 Gagne, 
\shape italic
Operating System Concepts, Seventh Edition
\shape default
, John Wiley and Sons, 2005.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-11"

\end_inset

W.
 Stallings, 
\shape italic
Operating Systems: Internals and Design Principles, Fifth Edition
\shape default
, Prentice Hall, 2005.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-13"

\end_inset

A.S.
 Tanenbaum, A.S.
 Woodhull, 
\shape italic
Operating Systems: Design and Implementation, Third Edition,
\shape default
 Prentice Hall, 2006.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-14"

\end_inset

W.S.
 Davis, T.M.
 Rajkumar, 
\shape italic
Operating Systems: A systematic view, Sixth Edition
\shape default
, Addison-Wesley, 2004.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-15"

\end_inset

R.
 Love, 
\shape italic
Linux Kernel Development, Second Edition,
\shape default
 Novell Press, 2005.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-16"

\end_inset

J.
 Bacon, T.
 Harris, 
\shape italic
Operating Systems: Concurrent and distributed software design,
\shape default
 Addison-Wesley, 2003.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-17"

\end_inset

B.
 Đorđević, D.
 Pleskonjić, N.
 Maček, 
\shape italic
Operativni sistemi: teorija, praksa i rešeni zadaci
\shape default
, Mikro knjiga, 2005.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-8"

\end_inset

G.
 Coulouris, J.
 Dollimore, T.
 Kindberg, 
\shape italic
Distributed Systems: Concepts and design, Fourth Edition
\shape default
, Addison-Wesley, 2005.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

P.
 Sheer, 
\shape italic
Linux: Rute User's Tutorial and Exposition
\shape default
, Prentice Hall, 2001.
 
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

D.
 Ray, E.
 Ray, 
\shape italic
UNIX and Linux: Visual Quickstart Guide, Fourth Edition
\shape default
, Peachpit Press, 2009.
\end_layout

\end_body
\end_document
