#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass mwbk
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language serbian-latin
\language_package default
\inputencoding auto
\fontencoding global
\font_roman utopia
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\boxbgcolor #e6e6e6
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.75cm
\topmargin 5.1cm
\rightmargin 3.75cm
\bottommargin 5.1cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language swedish
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begingroup
\end_layout

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
vspace*{0.14
\backslash
textheight} 
\end_layout

\begin_layout Plain Layout

{
\backslash
LARGE IRINA BRANOVIĆ}
\backslash

\backslash
[2
\backslash
baselineskip] 
\end_layout

\begin_layout Plain Layout

{
\backslash
Huge
\backslash
bf OBJEKTNO ORIJENTISANO}
\backslash

\backslash
[
\backslash
baselineskip] 
\end_layout

\begin_layout Plain Layout

{
\backslash
Huge
\backslash
bf PROGRAMIRANJE: C++}
\backslash

\backslash
[1.5
\backslash
baselineskip] 
\end_layout

\begin_layout Plain Layout


\backslash
vspace*{0.5
\backslash
textheight}
\end_layout

\begin_layout Plain Layout


\backslash
rule{0.6
\backslash
textwidth}{0.4pt}
\backslash

\backslash
[1
\backslash
baselineskip] 
\end_layout

\begin_layout Plain Layout

{
\backslash
LARGE
\backslash
sffamily UNIVERZITET SINGIDUNUM}
\backslash

\backslash
[
\backslash
baselineskip] 
\end_layout

\begin_layout Plain Layout

{
\backslash
LARGE Beograd, 2011}
\backslash
par
\end_layout

\begin_layout Plain Layout


\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OBJEKTNO ORIJENTISANO PROGRAMIRANJE: C++
\end_layout

\begin_layout Standard
prvo izdanje
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Autor:
\end_layout

\begin_layout Standard
Doc.
 dr Irina Branović
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Recenzenti:
\end_layout

\begin_layout Standard
Prof.
 dr Dejan Živković
\end_layout

\begin_layout Standard
Doc.
 dr Snežana Mladenović
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Lektor:
\end_layout

\begin_layout Standard
Stanka Vatović
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\shape italic
Izdavač:
\end_layout

\begin_layout Standard
UNIVERZITET SINGIDUNUM
\end_layout

\begin_layout Standard
Danijelova 32, Beograd
\end_layout

\begin_layout Standard
www.singidunum.ac.rs
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\shape italic
 Za izdavača:
\end_layout

\begin_layout Standard
Prof.
 dr Milovan Stanišić
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\shape italic
Tehnička obrada:
\end_layout

\begin_layout Standard
Irina Branović
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\shape italic
Dizajn korica:
\end_layout

\begin_layout Standard
Ime Prezime
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\shape italic
Godina izdanja:
\end_layout

\begin_layout Standard
2011
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\shape italic
Tiraž:
\end_layout

\begin_layout Standard
??? primeraka
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\shape italic
Štampa:
\end_layout

\begin_layout Standard
Mladost Grup
\end_layout

\begin_layout Standard
Loznica
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\shape italic
ISBN:
\end_layout

\begin_layout Standard
\paragraph_spacing single
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter*
Predgovor
\end_layout

\begin_layout Standard
Sadržaj i obim ove knjige prilagođeni su nastavnom programu istoimenog predmeta
 na Fakultetu za informatiku i računarstvo Univerziteta Singidunum u Beogradu.
 Podrazumeva se da čitaocima knjige ovo nije prvi susret sa programiranjem,
 tj.
 očekuje se da su ranije koristili neki programski jezik i da poznaju procedural
no programiranje.
 Naglasak je na objektno orijentisanom pristupu projektovanju.
 Ipak, radi kompletnosti, u knjizi su prikazani svi elementi jezika C++
 kroz koji se ilustruju objektno orijentisani principi.
\end_layout

\begin_layout Standard
Uložen je veliki napor da se pronađu zanimljivi i poučni primeri za obrađene
 teme.
 Primeri su birani tako da budu što jednostavniji, ali da istovremeno ilustruju
 stvarne probleme sa kojima se svakodnevno susrećemo u programiranju.
 Stil pisanja bio je takav da se čitaocima predstavi što više praktičnog
 znanja o objektno orijentisanim principima primenjenim u jeziku C++.
 Kada savlada gradivo iz knjige, čitalac sasvim sigurno neće znati sve detalje
 jednog tako složenog jezika kao što je C++, ali će mu razumevanje objektno
 orijentisanog pristupa biti dovoljno da lako nastavi samostalno učenje.
 Iako je knjiga pisana tako da posluži kao udžbenik, ambicija autora jeste
 da ona posluži svima koji se prvi put susreću sa jezikom C++, bilo da žele
 da nauče principe OO projektovanja, ili žele da savladaju sâm jezik C++.
 Na kraju svakog poglavlja data su pitanja kroz koje se može utvrditi naučeno
 gradivo.
\end_layout

\begin_layout Standard
Jedno od najčešćih pitanja koje studenti postavljaju jeste da li se na predmetu
 OOP može naučiti programiranje u jeziku C++ za Windows.
 Ova knjiga objašnjava osnove jezika C++ i sigurno je da ćete, kada je savladate
, moći da se pohvalite da znate jezik C++.
 Međutim, za pisanje Windows programa potrebno je dodatno specifično znanje,
 koje se nadograđuje na osnove kojima se bavi ova knjiga.
 Čitaoci koji su zainteresovani za tu oblast upućuju se na nekoliko odličnih
 knjiga u odeljku literature.
 
\end_layout

\begin_layout Standard
I konačno, svi komentari i preporuke mogu se uputiti na adresu
\begin_inset Newline newline
\end_inset

 
\family typewriter
\shape italic
\emph on
ibranovic@singidunum.ac.rs
\family default
\shape default
\emph default
.
\end_layout

\begin_layout Chapter
Uvod u jezik C++
\end_layout

\begin_layout Standard
U ovoj glavi upoznaćemo se sa jezikom C++, pregledati njegov istorijat,
 ideje primenjene tokom projektovanja jezika i najvažnije objektno orijentisane
 osobine.
 U procesu savladavanja novog programskog jezika najteže je to što su njegovi
 elementi međusobno povezani i ne mogu da se razmatraju nezavisno.
 Da bismo prevazišli taj problem, u ovom odeljku pomenućemo nekoliko najvažnijih
 svojstava jezika C++, bez upuštanja u detalje, ali dovoljno da sagledamo
 opšte principe zajedničke za sve C++ programe.
\end_layout

\begin_layout Section
Istorijat jezika C++
\end_layout

\begin_layout Standard
C++ je najvažniji programski jezik kada je reč o razvoju softvera visokih
 performansi.
 Sintaksa ovog jezika postala je standard i u drugim programskim jezicima,
 a ideje koje su korišćene tokom njegovog dizajniranja često se sreću u
 računarstvu.
\end_layout

\begin_layout Standard
Istorijat jezika C++ počinje od jezika C, iz prostog razloga što se na njemu
 zasniva.
 C++ je proširen i poboljšan jezik C sa podrškom za objektno orijentisano
 programiranje (OOP, o kome će biti detaljno reči u knjizi).
 Često se kaže i da je jezik C++ "objektno orijentisani C
\begin_inset Quotes erd
\end_inset

.
 Osim podrške za OOP, u jeziku C++ su poboljšane i ugrađene biblioteke u
 poređenju sa jezikom C.
 I pored svega toga, duh i suština jezika C++ direktno su nasleđeni iz jezika
 C.
 Zbog toga, da bi se u potpunosti razumeo C++, mora se prvo razumeti C.
\end_layout

\begin_layout Standard
Pojavljivanje jezika C sedamdesetih godina prošlog veka označilo je početak
 modernog doba u programiranju.
 Dizajn ovog jezika uticao je na sve kasnije programske jezike, jer je iz
 osnova promenio pristup programiranju.
 Jezik C je osmislio i prvi implementirao Denis Riči pod operativnim sistemom
 UNIX, da bi ubrzo stekao brojne sledbenike širom sveta iz više razloga:
 bio je lak za savladavanje, omogućavao je modularno pisanje programa, sadržavao
 je samo naredbe koje se lako prevode u mašinski jezik, davao je brzi kôd.
 Od tada pa sve do pre desetak godina većina programa bila je pisana u jeziku
 C, ponegde dopunjena delovima u asembleru ako je brzina bila kritični faktor.
\end_layout

\begin_layout Standard
Međutim, kako su se programi razvijali, i na polju programskih jezika stanje
 se menjalo.
 Krajem sedamdesetih godina programi sa nekoliko stotina hiljada redova
 kôda više nisu bili retkost, tj.
 počeli su da postaju toliko složeni da nisu mogli da se sagledaju u celini.
 Pojavila se potreba za rešenjima koja će upravljati tom složenošću.
 C++ i OOP nastali su kao odgovor na te probleme.
 
\end_layout

\begin_layout Standard
C++ je projektovao Danac Bjarne Stroustrup 1979.
 godine.
 Pre toga, on je radio na svom doktoratu na Kembridžu gde je proučavao distribui
ranu obradu (paralelno programiranje za više procesora istovremeno).
 Pri tom je koristio jezik Simula, koji je posedovao neke važne osobine
 koje su ga činile pogodnim za taj zadatak; na primer, podržavao je pojam
 klasa, tj.
 struktura koje objedinjuju podatke i funkcije za rad sa njima.
 Dobijeni kôd je bio vrlo razumljiv, a Stroustrup je bio posebno oduševljen
 načinom na koji je sâm jezik usmeravao programera prilikom razmišljanja
 o problemu.
 Međutim, iako na prvi pogled idealan u teoriji, jezik Simula je posrnuo
 u praksi: prevođenje je bilo dugotrajno, a dobijeni kôd se izvršavao izuzetno
 sporo.
 Dobijeni program je bio neupotrebljiv, pa je Stroustrup morao ponovo da
 ga napiše u jeziku BCPL niskog nivoa koji je omogućio dobre performanse.
 Međutim, iskustvo pisanja programa u takvom jeziku bilo je užasno i Stroustrup
 je odlučio da više nikad neće pokušavati da rešava složene probleme neodgovaraj
ućim alatima kao što su Simula i BCPL.
 Zato je 1979.
 započeo rad na novom jeziku koji je prvobitno nazvao “C sa klasama”, ali
 ga je 1983.
 preimenovao u C++.
 Stroustrup nije izmislio potpuno nov jezik, već je unapredio jezik C, tj.
 podržao je u potpunosti sve funkcije jezika C, ali i objektno orijentisan
 pristup.
 U suštini, C++ je objektno orijentisan C, tj.
 C i "još malo više
\begin_inset Quotes erd
\end_inset

 (odatle ++ u imenu).
 Zbog toga su programeri koji su već poznavali jezik C mogli lako da ga
 usvoje, savladavajući samo objektno orijentisane novine.
\end_layout

\begin_layout Standard
Kada je projektovao C++, Stroustrup
\begin_inset Index idx
status open

\begin_layout Plain Layout
Stroustrup, Bjarne
\end_layout

\end_inset

 je zadržao pristup jezika C, uključujući njegovu efikasnost, prilagodljivost
 i filozofiju, a istovremeno je dodao podršku za OOP.
 Iako je C++ prvobitno projektovan kao pomoć u projektovanju veoma velikih
 programa, on nipošto nije ograničen isključivo na njih, jer se OOP atributi
 mogu efikasno primeniti na bilo koji programerski zadatak.
 Često se sreću C++ aplikacije poput editora, baza podataka, sistema za
 upravljanje datotekama, umrežavanje i komunikaciju.
 Pošto je C++ zadržao efikasnost jezika C, mnogi softverski sistemi kod
 kojih su kritične performanse programirani su u jeziku C++.
 Takođe, C++ se često sreće i u programima za operativne sisteme Windows
 i Linux.
\end_layout

\begin_layout Section
Standardizacija jezika
\end_layout

\begin_layout Standard
Od svog prvog pojavljivanja, jezik C++ je pretrpeo tri velike prepravke,
 tokom kojih je proširivan i menjan.
 Prva revizija desila se 1985, a druga 1990.
 godine (kada je već bio u toku proces standardizacije jezika).
 Formiran je zajednički komitet za standardizaciju koji su činile organizacije
 ANSI (American National Standards Institute) i ISO (International Standards
 Organization).
 U prvom nacrtu standarda zadržane su osobine jezika koje je definisao Stroustru
p, kojima su dodate i neke nove, ali je u suštini taj nacrt standarda odražavao
 status jezika C++ u tom trenutku.
 Ubrzo pošto je kompletiran prvi nacrt standarda, Rus Aleksandar Stepanov
 je objavio biblioteku STL
\begin_inset Index idx
status open

\begin_layout Plain Layout
STL
\end_layout

\end_inset

 (Standard Template Library), tj.
 skup generičkih metoda za rad sa podacima.
 Komisija za standardizaciju je zatim odlučila da uključi tu biblioteku
 u specifikaciju jezika, što je bitno promenilo početnu definiciju jezika
 i usporilo proces standardizacije.
 Iako je proces standardizacije trajao mnogo duže nego što se očekivalo,
 a verzija koju je standardizovao ANSI/ISO
\begin_inset Index idx
status open

\begin_layout Plain Layout
ANSI/ISO standard
\end_layout

\end_inset

 C++ komitet bila daleko obimnija od početne Stroustrupove definicije jezika,
 ona je ipak konačno završena 1998.
 godine.
 Ta specifikacija se obično navodi kao standardni C++, potpuno je prenosiva
 i podržavaju je najpoznatiji C++ kompajleri (uključujući i Microsoftov
 Visual C++), te će o njoj biti reči u ovoj knjizi.
 
\end_layout

\begin_layout Section
Objektno orijentisane osobine jezika C++
\end_layout

\begin_layout Standard
Suština jezika C++ jeste podrška za objektno orijentisano programiranje
\begin_inset Index idx
status open

\begin_layout Plain Layout
objektno orijentisano programiranje
\end_layout

\end_inset

 (OOP), koje je i bilo razlog za njegov nastanak.
 Zbog toga je pre nego što se napiše i najjednostavniji C++ program važno
 razumeti OOP principe.
 Objektno orijentisano programiranje preuzelo je najbolje ideje strukturnog
 programiranja koje su proširene sa nekoliko novina.
 Kao rezultat toga, poboljšan je način organizovanja programa.
 U najopštijem smislu, program može da bude organizovan na dva načina: sa
 naglaskom na kôdu (tj.
 na tome šta se dešava) ili sa naglaskom na podatke (sa kojima se radi).
 Korišćenjem isključivo tehnika strukturnog programiranja, programi su obično
 organizovani oko kôda koji operiše sa podacima.
 Objekno orijentisani programi rade na drugi način.
 Oni su organizovani oko podataka, pri čemu je ključni princip da podaci
 kontrolišu pristup kôdu.
 U objektno orijentisanom jeziku, tip podataka precizno definiše šta sa
 tim podacima može da se radi.
 
\end_layout

\begin_layout Standard
Tri su važne osobine programskog jezika koje ga čine objektno orijentisanim:
\end_layout

\begin_layout Enumerate
skrivanje podataka (encapsulation)
\end_layout

\begin_layout Enumerate
nasleđivanje (inheritance)
\end_layout

\begin_layout Enumerate
polimorfizam (polymorphism)
\end_layout

\begin_layout Subsubsection*
Skrivanje podataka 
\end_layout

\begin_layout Standard
Skrivanje (kapsuliranje) podataka
\begin_inset Index idx
status open

\begin_layout Plain Layout
skrivanje podataka
\end_layout

\end_inset

 je programerski
\begin_inset Index idx
status open

\begin_layout Plain Layout
kapsuliranje
\end_layout

\end_inset

 mehanizam koji povezuje kôd i podatke sa kojima radi, na taj način da i
 kôd i podaci budu sigurni od spoljašnjih uticaja.
 U objektno orijentisanom jeziku, kôd i podaci mogu da se povežu tako da
 ne budu vidljivi spolja, tako što se smeštaju u objekat.
 Unutar objekta, kôd i podaci mogu da budu privatni ili javni.
 Privatnom kôdu ili podacima ne mogu da pristupaju delovi programa koji
 se nalaze izvan objekta, a javni delovi objekta koriste se za obezbeđivanje
 kontrolisanog interfejsa ka privatnim elementima objekta.
 Osnovna jedinica kojom se postiže skrivanje podataka u jeziku C++ je klasa.
 Klasa definiše izgled objekta i određuje podatke i kôd koji će raditi sa
 podacima.
 Objekti su primerci (instance) klase.
 Kôd i podaci koji čine klasu zovu se članovi klase.
 Podaci članovi
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!podaci članovi
\end_layout

\end_inset

 (
\shape italic
member data
\shape default
) klase su podaci koji su definisani u klasi, a funkcije članice
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!funkcije članice
\end_layout

\end_inset

 (
\shape italic
member functions
\shape default
) čini kôd koji radi sa tim podacima.
\end_layout

\begin_layout Subsubsection*
Polimorfizam 
\end_layout

\begin_layout Standard
Polimorfizam
\begin_inset Index idx
status open

\begin_layout Plain Layout
polimorfizam
\end_layout

\end_inset

 (na grčkom “više oblika”) je osobina koja omogućuje projektovanje zajedničkog
 interfejsa koje će se zatim preslikavati u različite akcije.
 Pojam polimorfizma se obično izražava frazom “jedan interfejs, više metoda”,
 a najlakše se razume na primeru.
 Korisnik koji kupuje auto sigurno neće biti zadovoljan ako se njegov novi
 model razlikuje od starog po načinu korišćenja, na primer, da se umesto
 pritiskom na papučicu gasa auto ubrzava povlačenjem ručne kočnice.
 Vozač auta s pravom očekuje da se auto ubrzava kada pritisne papučicu za
 gas; ono što eventualno može da bude promenjeno u novom modelu auta može
 da bude vreme ubrzavanja do 100 km/h.
 Slično je i sa programskim komponentama: programer ne treba da se opterećuje
 time koju verziju komponente koristi, već će jednostavno tražiti od komponente
 određenu uslugu, a na njoj je da mu je pruži na odgovarajući način.
 To je polimorfizam.
\end_layout

\begin_layout Standard
Polimorfizam uprošćava programe jer omogućuje definisanje generalnih operacija;
 kompajleru je ostavljen zadatak da izabere određenu akciju (tj.
 metod) koji se primenjuje na konkretnu situaciju.
 Programer treba samo da poznaje i koristi uopšteni interfejs.
\end_layout

\begin_layout Subsubsection*
Nasleđivanje 
\end_layout

\begin_layout Standard
Nasleđivanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!nasleđivanje
\end_layout

\end_inset

 je proces kojim se jednom objektu omogućuje da preuzme svojstva drugog
 objekta.
 To je važno zato što se time podržava pojam hijerarhijske klasifikacije.
 Na primer, sorta jabuke crveni delišes je deo klasifikacije jabuka, koje
 su zauzvrat deo klase voća, a voće opet potpada pod širu klasu hrane.
 Klasa hrane konkretno poseduje određene kvalitete (ukus, hranljiva vrednost
 i sl.) koji se zatim primenjuju i na njegovu potklasu, tj.
 voće.
 Osim pomenutih karakteristika hrane, klasa voće ima određene karakteristike
 (sočnost, slast i sl.) koje ga razlikuju od druge hrane.
 Klasa jabuka definiše svojstva karakteristična za jabuke (raste na drveću,
 nije tropsko voće i sl.).
 Crveni delišes nasleđuje svojstva svih prethodno pomenutih klasa, a definiše
 samo ona koja ga čine jedinstvenim (npr.
 mora biti crvene boje).
 Bez korišćenja hijerarhija, svaki objekat morao bi eksplicitno da definiše
 sve svoje karakteristike.
 Kada se koristi nasleđivanje, objekat treba da definiše samo svojstva koja
 ga čine jedinstvenim unutar klase, a svoje generalne osobine nasleđuje
 od roditeljskih klasa.
 Na taj način mehanizam nasleđivanja omogućuje jednom objektu da bude specifični
 primerak nekog opštijeg slučaja.
\end_layout

\begin_layout Section
Unošenje, prevođenje i izvršavanje C++ programa
\end_layout

\begin_layout Standard
Da bi se izvršio C++ program, potrebna su četiri koraka:
\end_layout

\begin_layout Enumerate
pisanje izvornog kôda
\end_layout

\begin_layout Enumerate
kompajliranje programa
\end_layout

\begin_layout Enumerate
povezivanje programa
\end_layout

\begin_layout Enumerate
izvršavanje programa
\end_layout

\begin_layout Standard
Procesor računara je u stanju da razume i direktno izvršava samo binarni
 kôd (tj.
 kôd koji se sastoji samo od nula i jedinica).
 Nažalost, takav kôd čovek veoma teško razume.
 Zbog toga se nakon pisanja izvornog kôda programa (koji je razumljiv ljudima)
 on prevodi u mašinski jezik, tj.
 u binarni ili objektni kôd (koji razume računar) pomoću alatke koja se
 zove prevodilac ili kompajler (compiler).
 
\end_layout

\begin_layout Standard
Pre nego što nastavimo, naglasimo još jednom razliku između izvornog kôda
 i objektnog kôda.
 Izvorni kôd
\begin_inset Index idx
status open

\begin_layout Plain Layout
izvorni kôd
\end_layout

\end_inset

 (source code) je čitljiv tekst programa koji se čuva u tekstualnoj datoteci.
 Objektni kôd
\begin_inset Index idx
status open

\begin_layout Plain Layout
objektni kôd
\end_layout

\end_inset

 (object code) je izvršni oblik programa koji kreira prevodilac (kompajler).
\end_layout

\begin_layout Standard
Unošenje kôda programa u tekstualnu datoteku obavlja se pomoću nekog tekst
 editora (npr.
 Notepad, WordPad, vi i sl.), a nikako u programu za obradu teksta kao što
 je Microsoftov Word (zato što napredni programi za obradu teksta osim 
\begin_inset Quotes eld
\end_inset

čistog
\begin_inset Quotes erd
\end_inset

 teksta u svojoj datoteci čuvaju i neke druge podatke koji zbunjuju C++
 kompajlere).
 Ime datoteke koja sadrži izvorni C++ kôd može da bude proizvoljno, ali
 se obično koristi nastavak .cpp (ili ređe .cp).
 Nastavak je potreban samo da bi se datoteka sa izvornim kôdom kasnije lakše
 pronašla.
\end_layout

\begin_layout Standard
Način kompajliranja (prevođenja) programa
\begin_inset Index idx
status open

\begin_layout Plain Layout
kompajliranje programa
\end_layout

\end_inset

 zavisi od okruženja za programiranje koje se koristi.
 Šta više, mnoga okruženja za programiranje nude više načina za kompajliranje
 datoteke.
 Zbog toga nije moguće dati opšte uputstvo za kompajliranje, već treba proučiti
 okruženje koje se koristi.
 Osim prevođenja izvornog kôda u objektni kôd, kompajler ima i zadatak da
 proveri da li je izvorni kôd sintaksno ispravan, odnosno da li su poštovana
 pravila programskog jezika.
 Greške koje pronalazi kompajler
\begin_inset Index idx
status open

\begin_layout Plain Layout
kompajler (prevodilac)
\end_layout

\end_inset

 zovu se greške tokom prevođenja
\begin_inset Index idx
status open

\begin_layout Plain Layout
greške!tokom prevođenja
\end_layout

\end_inset

 (compile-time errors).
 U svakom slučaju, kompajler kao izlaz daje objektni kôd koji ima nastavak
 .o ili .obj.
 Za svaki programski jezik postoji poseban kompajler; takođe, izvorni kôd
 koji je kompajliran za jedan tip procesora po pravilu neće raditi na računaru
 sa drugim tipom procesora, ili sa drugačijim operativnim sistemom.
 Kaže se da kôd nije prenosiv (kompatibilan).
 
\end_layout

\begin_layout Standard
Često se u pisanju programa koriste tzv.
 biblioteke kôda
\begin_inset Index idx
status open

\begin_layout Plain Layout
biblioteke kôda
\end_layout

\end_inset

 (libraries).
 To su zbirke standardnog, profesionalnog kôda koji podržava i(li) proširuje
 programski jezik.
 Neke biblioteke su i ugrađene u sâm jezik (npr.
 biblioteka matematičkih funkcija, metode za rad sa stringovima, algoritmi
 za sortiranje itd), a može ih kupiti ili razvijati i sâm programer.
 Korišćenje biblioteka gotovog, proverenog kôda uvek se preporučuje umesto
 pisanja sopstvenog kôda za istu namenu iz više razloga: taj kôd je proveren,
 profesionalan, efikasniji od kôda koji biste sami napisali, a uostalom,
 nema ni svrhe gubiti vreme na 
\begin_inset Quotes eld
\end_inset

izmišljanje tople vode
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Zbog korišćenja biblioteka, sledeći korak u procesu nastanka programa jeste
 tzv.
 povezivanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
povezivanje
\end_layout

\end_inset

 (linking).
 Linker
\begin_inset Index idx
status open

\begin_layout Plain Layout
linker
\end_layout

\end_inset

 je poseban alat koji povezuje različite module koje je kompajler generisao
 od izvornog kôda, dodaje već preveden kôd iz biblioteka (ako su one korišćene
 u programu) i sve to povezuje u celinu koja se naziva izvršni kôd (executable
 code).
 Pri tom, slično kao i kompajler, i linker prijavljuje eventualne greške
 (npr.
 navođenje kôda iz nepostojeće biblioteke); takve greške zovu se greške
 tokom povezivanja
\begin_inset Index idx
status open

\begin_layout Plain Layout
greške!tokom povezivanja
\end_layout

\end_inset

 (link-time errors).
\end_layout

\begin_layout Standard
Nakon kompajliranja i povezivanja, dobija se izvršna datoteka
\begin_inset Index idx
status open

\begin_layout Plain Layout
izvršna datoteka
\end_layout

\end_inset

 (executable file) koja po pravilu ima isto ime kao datoteka sa izvornim
 kôdom, a pod operativnim sistemom Windows nastavak joj je .exe (Slika 1.1).
\end_layout

\begin_layout Standard
Kada se program kompajlira, on može da se izvrši, najlakše pozivom iz komandne
 linije.
 Ipak, to što je program uspešno preveden i povezan ne znači da u njemu
 nema grešaka.
 Na primer, dešava se da pravilno radi sa jednim podacima, a nepravilno
 sa drugim.
 Greške otkrivene tokom testiranja programa zovu se greške tokom izvršavanja
\begin_inset Index idx
status open

\begin_layout Plain Layout
greške!tokom izvršavanja
\end_layout

\end_inset

 (run-time errors).
 Postupak testiranja programa, pronalaženja i uklanjanja grešaka nastavlja
 se sve dok se ne proceni da je program dovoljno stabilan.
 Pronalaženje grešaka zove se debagovanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
debagovanje
\end_layout

\end_inset

 (debugging), a poseban alat koji služi za tu namenu jeste debager
\begin_inset Index idx
status open

\begin_layout Plain Layout
debager
\end_layout

\end_inset

 (debugger).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/ciklus.PNG
	scale 69

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 1.1: Ciklus razvoja aplikacije.
\end_layout

\begin_layout Subsection
Integrisana razvojna okruženja za programiranje (IDE)
\end_layout

\begin_layout Standard
Postoje brojna integrisana razvojna okruženja
\begin_inset Index idx
status open

\begin_layout Plain Layout
integrisana razvojna okruženja (IDE)
\end_layout

\end_inset

 za jezik C++ (Microsoft Visual Studio, Borland Enterprise Studio, KDevelop,
 CodeForge itd.); koje ćete od njih koristiti najviše zavisi od toga za koji
 ćete se operativni sistem odlučiti (Windows, Linux, MacOS) i od ličnih
 sklonosti.
 U svako razvojno okruženje po pravilu su integrisane sve potrebne alatke
 za razvoj programa (od tekst editora, preko kompajlera, linkera, biblioteka,
 sve do debagera).
 Prevođenje i povezivanje programa obično su objedinjeni u istu komandu,
 tj.
 povezivanje se obavlja automatski.
 Izvršavanje programa obično se postiže komandom Run iz menija, ili komandom
 Debug ukoliko se program izvršava u režimu traženja grešaka.
 U Dodatku E detaljno je opisano razvojno okruženje Microsoft Visual C++
 Express Edition koje može besplatno da se preuzme sa Interneta, a korišćeno
 je za proveru programa u ovoj knjizi.
\end_layout

\begin_layout Subsection
Prevođenje i interpretiranje
\end_layout

\begin_layout Standard
Postoje programski jezici, kao što su Java ili C#, čiji se izvorni kôd ne
 prevodi direktno u izvršni kôd, već se interpretira
\begin_inset Index idx
status open

\begin_layout Plain Layout
interpretiranje
\end_layout

\end_inset

.
 To zapravo znači da prevođenje i izvršavanje programa nisu vremenski razdvojeni
, već objedinjeni procesi.
 Umesto da se prevede u mašinski kôd koji će se izvršavati u procesoru,
 Javin izvorni kôd se prevodi u tzv.
 bajt kod (bytecode) koji interpretira i izvodi Javina virtuelna mašina.
 C# kôd se izvršava u okruženju Common Language Runtime (CLR).
 Prednost ovakvog pristupa je to što se jednom prevedeni bajt kôd može izvršavat
i na bilo kom računaru i operativnom sistemu na kome je instalirana virtuelna
 mašina.
 S druge strane, takav kôd neće biti optimizovan za procesor na kome se
 izvršava, pa su zato interpretirani programi mnogo sporiji od aplikacija
 koje se direktno kompajliraju u izvorni kôd.
 C++ programi su poznati po svojoj efikasnosti, koja je direktna posledica
 toga što se kompajliraju u mašinski kôd.
 Ostale razlike između jezika C++ i Java detaljno su opisane u Dodatku D.
\end_layout

\begin_layout Standard
Često se raspravlja o tome koji je jezik 
\begin_inset Quotes eld
\end_inset

bolji
\begin_inset Quotes erd
\end_inset

: C++, Java ili C#, pa ćemo se ovde ukratko osvrnuti i na tu problematiku.
 Sintaksa sva tri jezika je gotovo istovetna, a osnovna razlika je tip okruženja
 za koje su namenjeni.
 Jezik C++ je izmišljen da bi se pisali veoma efikasni programi za određeni
 tip procesora i operativnog sistema.
 Ako želite da izvršite isti C++ program na drugom sistemu, moraćete ponovo
 da ga kompajlirate i specijalno optimizujete za tu platformu.
 Java je razvijena posebno za potrebe Internet programiranja, a C# za programira
nje modularnih softverskih komponenata.
 
\end_layout

\begin_layout Standard
Dakle, odgovor na pitanje koji je jezik najbolji zavisi od toga kakav se
 problem rešava: ako je neophodna efikasnost, koristićemo C++; za Web programira
nje odlučićemo se za Javu, a za specifične Windows programe kod kojih efikasnost
 nije najvažnija upotrebićemo C#.
\end_layout

\begin_layout Subsection
Konzolni i grafički programi
\end_layout

\begin_layout Standard
Gotovo svi primeri programa u ovoj knjizi biće konzolni programi.
 Konzolni programi
\begin_inset Index idx
status open

\begin_layout Plain Layout
konzolni programi
\end_layout

\end_inset

 izvršavaju se u komandnoj liniji, tj.
 ne koriste grafički korisnički interfejs (Graphical User Interface, GUI).
 Pod grafičkim interfejsom
\begin_inset Index idx
status open

\begin_layout Plain Layout
grafički interfejs
\end_layout

\end_inset

 podrazumevamo izgled programa na koji smo navikli, sa dijalozima, menijima
 sa opcijama, dugmadima za potvrdu i sl.
 Razlog za izbegavanje grafičkih programa je lako razumeti: čak i najjednostavni
ji grafički program za Windows ima 50 do 70 redova kôda i nije pogodan za
 objašnjavanje osnovnih pojmova.
 Drugi razlog za izbegavanje grafičkih programa jeste njihova nekompatibilnost
 sa standardnim jezikom C++.
 Grafička okruženja u jeziku C++ za različite operativne sisteme po pravilu
 koriste verzije jezika C++ koje odstupaju od one propisane standardom (kojom
 se mi bavimo u ovoj knjizi), ili zahtevaju savladavanje posebnih grafičkih
 biblioteka, što prevazilazi okvire ovog kursa.
 Takođe, programiranje grafičkih programa u jeziku C++ veoma zavisi od toga
 za koji se operativni sistem aplikacija pravi; grafički C++ program napisan
 za Windows po pravilu neće moći da radi pod Linuxom i obrnuto.
 
\end_layout

\begin_layout Section
Prvi C++ program
\end_layout

\begin_layout Standard
Došli smo do trenutka kada ćemo napisati prvi, najjednostavniji program
 u jeziku C++ i objasniti najvažnije elemente njegove sintakse.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
/* ovo je najprostiji C++ program
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
nazovite ovu datoteku primer.cpp */
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
//tipican C++ komentar koji se proteze
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
//samo do kraja reda
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include<iostream>
\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "OOP se uci na" <<
\end_layout

\begin_layout LyX-Code

\size small
" II  godini Fakulteta za Informatiku i Racunarstvo " <<
\end_layout

\begin_layout LyX-Code

\size small
" Univerziteta Singidunum." << endl;
\end_layout

\begin_layout LyX-Code

\size small
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard
\align left

\series bold
\size small
OOP se uči na II godini Fakulteta za Informatiku i Racunarstvo Univerziteta
 Singidunum.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
U jeziku C++ postoje dve vrste komentara
\begin_inset Index idx
status open

\begin_layout Plain Layout
komentari
\end_layout

\end_inset

.
 Tip komentara koji počinje sa 
\family typewriter
/*
\family default
 nasleđen je iz jezika C, može da se proteže u više redova, a završava se
 tek kada naiđe znak 
\family typewriter
*/
\family default
.
 Sve što se nalazi između simbola 
\family typewriter
/*
\family default
 i 
\family typewriter
*/
\family default
 prevodilac potpuno zanemaruje.
 Komentar koji počinje znakom 
\family typewriter
//
\family default
 je tipičan za C++, a završava se na kraju istog reda.
 Obično se C komentari
\begin_inset Index idx
status open

\begin_layout Plain Layout
komentari!C stil
\end_layout

\end_inset

 koriste za pisanje detaljnijih objašnjenja, a komentar // za kratke opaske.
\end_layout

\begin_layout Standard
Iako pisanje komentara zahteva dodatno vreme i napor, ono se uvek isplati.
 Ako se desi da neko drugi mora da prepravlja vaš kôd, ili (još gore) da
 vi nakon izvesnog vremena morate da ispravljate sopstveni kôd, komentari
 će vam olakšati da proniknete u to kako je autor kôda razmišljao.
 Ipak, sa komentarima ne treba preterivati; višak komentara podjednako je
 loš kao i njihovo potpuno odsustvo, a prava mera dolazi sa iskustvom i
 proučavanjem kôda iskusnih programera.
 
\end_layout

\begin_layout Standard
Sve praznine u kôdu prevodilac takođe zanemaruje; one se stavljaju isključivo
 radi povećanja čitljivosti programa.
 Pod prazninama se osim razmaka (whitespace) podrazumevaju i praznine dobijene
 pomoću tastera Tab (tabulatori) i prelasci u novi red.
 Naredbe se mogu protezati u više redova, a svaka naredba u jeziku C++ se
 mora završavati znakom tačka-zarez (;).
 
\end_layout

\begin_layout Standard
U sedmom redu nalazi se naredba
\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorske direktive!
\family typewriter
include
\end_layout

\end_inset

 
\family typewriter
#include<iostream>
\family default
 kojom se od kompajlera zahteva da u program uključi biblioteku 
\family typewriter
iostream
\family default
.
 U toj biblioteci (koja je ugrađena u jezik C++) nalazi se 
\shape italic
izlazni tok
\shape default
 (engl.
 
\shape italic
output stream
\shape default
), odnosno funkcije za ispis teksta na ekranu.
 Ovde naglašavamo da 
\family typewriter
#include
\family default
 nije naredba jezika C++, već tzv.
 preprocesorska direktiva
\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorske direktive
\end_layout

\end_inset

 nasleđena iz jezika C.
 Kada naiđe na preprocesorsku direktivu, kompajler će prekinuti postupak
 prevođenja kôda u tekućoj datoteci, skočiti u datoteku 
\family typewriter
iostream
\family default
, prevesti je, a zatim se vratiti u polaznu datoteku iza reda 
\family typewriter
#include
\family default
.
 Sve preprocesorske direktive počinju znakom 
\family typewriter
#
\family default
.
 Pošto preprocesorske direktive nisu C++ naredbe, one ne zahtevaju tačku-zarez
 na kraju; mnogi kompajleri to čak prijavljuju kao grešku.
\end_layout

\begin_layout Standard

\family typewriter
iostream
\family default
 je primer datoteke zaglavlja
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja
\end_layout

\end_inset

 (engl.
 
\shape italic
header file
\shape default
).
 U zaglavljima se nalaze deklaracije funkcija sadržanih u odgovarajućim
 datotekama.
 Jedna od osnovnih karakteristika jezika C++ je mali broj funkcija ugrađenih
 u sâm jezik.
 Ta oskudnost olakšava učenje samog jezika, a istovremeno pojednostavljuje
 i ubrzava prevođenje.
 Za specifične zahteve na raspolaganju je veliki broj gotovih biblioteka
 klasa.
 
\end_layout

\begin_layout Standard
U petom redu nalazi se naredba 
\family typewriter
using namespace std
\family default
.
 
\family typewriter
using
\family default
 i 
\family typewriter
namespace
\family default
 su ključne (zaštićene) reči jezika C++ kojim se 
\begin_inset Quotes eld
\end_inset

aktivira
\begin_inset Quotes erd
\end_inset

 određena oblast imena (imenik, engl.
 
\shape italic
namespace
\shape default
), a 
\family typewriter
std
\family default
 je naziv imenika
\begin_inset Index idx
status open

\begin_layout Plain Layout
imenici
\end_layout

\end_inset

 koji sadrži sve standardne funkcije, uključujući i funkcije iz već pomenute
 biblioteke 
\family typewriter
iostream
\family default
.
 Imenici su se prilično kasno pojavili u jeziku C++, a uvedeni su da bi
 se izbegao sukob sa nazivima funkcija i promenljivih iz različitih biblioteka.
 Na primer, ako dve različite funkcije iz različitih biblioteka imaju isto
 ime, a koriste se u istoj datoteci, kompajler će javiti grešku.
 Kada ne bismo imali na raspolaganju imenike, jedino rešenje u takvom slučaju
 bilo bi da se jednoj funkciji u nekoj od biblioteka promeni ime, ali to
 ponekad nije moguće jer autori obično te biblioteke objavljuju već prevedene.
 O imenicima će detaljnije biti reči u Poglavlju 5, a do tada ćemo ih uzeti
 
\begin_inset Quotes eld
\end_inset

zdravo za gotovo
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Izvršavanje programa počinje od reda 
\family typewriter
int main()
\family default
.
 Svi C++ programi sastavljeni su od jedne funkcije ili više njih.
 Svaka C++ funkcija mora da ima ime, a svaki C++ program mora da ima jednu
 (i samo jednu) funkciju 
\family typewriter
main()
\family default
.
 U funkciji 
\family typewriter
main() 
\family default
počinje (i najčešće se završava) izvršavanje programa.
 Otvorena vitičasta zagrada iza 
\family typewriter
main()
\family default
 označava početak kôda funkcije.
 Reč 
\family typewriter
int
\family default
 ispred 
\family typewriter
main()
\family default
 označava tip podatka koji vraća funkcija 
\family typewriter
main()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
main()
\end_layout

\end_inset

.
 Kao što ćemo saznati u nastavku, C++ ugrađeno je nekoliko tipova podataka,
 a ceo broj (int, od integer) je jedan od njih.
\end_layout

\begin_layout Standard
Treća naredba unutar programa
\begin_inset Index idx
status open

\begin_layout Plain Layout
cout
\end_layout

\end_inset


\family typewriter
 main()
\family default
 je 
\family typewriter
cout
\family default
, što je skraćenica za 
\series bold
\shape italic
c
\series default
onsole
\begin_inset Newline linebreak
\end_inset

 
\series bold
out
\series default
put
\shape default
.
 To je ime izlaznog toka
\begin_inset Index idx
status open

\begin_layout Plain Layout
izlazni tok
\end_layout

\end_inset

 definisanog u zaglavlju 
\family typewriter
iostream
\family default
, pridruženom ekranu računara.
 Ono što sledi iza operatora <<
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!<<
\end_layout

\end_inset

 upućuje se na standardni izlaz, tj.
 na ekran računara (u našem slučaju, to je poruka 
\shape italic
OOP se uči na II godini Fakulteta za Informatiku i računarstvo Univerziteta
 Singidunum
\shape default
).
 Poruka 
\shape italic

\begin_inset Quotes eld
\end_inset

OOP se uči na II godini Fakulteta za Informatiku i računarstvo Univerziteta
 Singidunum
\begin_inset Quotes erd
\end_inset


\shape default
 je string, odnosno niz znakova između navodnika.
 Identifikator 
\family typewriter
endl
\family default
 je objekat toka koji označava kraj reda (
\series bold
\shape italic
end l
\series default
ine
\shape default
), odnosno prelazak u ispis u novom redu.
\end_layout

\begin_layout Standard
Korisno je znati da je 
\family typewriter
iostream
\family default
 novi (standardom propisani) naziv zaglavlja 
\family typewriter

\begin_inset Newline linebreak
\end_inset

iostream.h
\family default
.
 Do te promene naziva došlo je s razlogom.
 Kada su uvedeni imenici, trebalo je sve standardne datoteke uvesti u imenik
 
\family typewriter
std
\family default
.
 Pošto je tada već postojalo mnogo kôda koji je koristio biblioteku 
\family typewriter
iostream.h
\family default
, ona nije smela da se menja zbog održavanja kompatibilnosti sa starim kôdom.
 Rešenje je bilo da se definiše nova biblioteka sličnog imena u kojoj su
 definisane sve funkcije kao u zaglavlju 
\family typewriter
iostream.h
\family default
, ali unutar imenika 
\family typewriter
std
\family default
.
 Zato je u bibliotekama većine modernih C++ kompajlera unutar zaglavlja
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja!
\family typewriter
iostream
\end_layout

\end_inset

 
\family typewriter
iostream
\family default
 zapravo samo uključena (preprocesorskom direktivom 
\family typewriter
#include
\family default
) datoteka 
\family typewriter
iostream.h
\family default
, a slično je i sa svim ostalim starim zaglavljima.
 
\end_layout

\begin_layout Standard
Naredba 
\family typewriter
return 0;
\family default
 završava program i vraća vrednost 0 procesu koji je pozvao program (a to
 je obično operativni sistem).
 Vrednost 0 po pravilu znači da se program pravilno izvršio, dok druge vrednosti
 znače da se program nepravilno završio zbog neke greške.
 Zatvorena vitičasta zagrada na kraju programa u redu 15 i formalno ga završava.
\end_layout

\begin_layout Section*
Pitanja
\end_layout

\begin_layout Standard
1.
 Jezik C++ je bliski rođak jezika C# i Java.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
2.
 Autor jezika C++ je:
\end_layout

\begin_layout Standard
a) Bjarne Stroustrup
\end_layout

\begin_layout Standard
b) Denis Riči
\end_layout

\begin_layout Standard
c) Aleksandar Stepanov
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
3.
 Jezik C++ je nastao od jezika C.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
4.
 Kompajliranjem (prevođenjem) programa dobija se:
\end_layout

\begin_layout Standard
a) izvorni kôd
\end_layout

\begin_layout Standard
b) objektni kôd
\end_layout

\begin_layout Standard
c) izvršni kôd
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
5.
 Alatka koja služi za povezivanje objektnog kôda sa bibliotekama zove se:
\end_layout

\begin_layout Standard
a) kompajler
\end_layout

\begin_layout Standard
b) linker
\end_layout

\begin_layout Standard
c) debager
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
6.
 C++ program počinje izvršavanje:
\end_layout

\begin_layout Standard
a) u prvom redu kôda
\end_layout

\begin_layout Standard
b) u datoteci main.cpp
\end_layout

\begin_layout Standard
c) u funkciji main
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
7.
 Svaki C++ program mora da ima:
\end_layout

\begin_layout Standard
a) naredbu 
\family typewriter
cout
\end_layout

\begin_layout Standard
b) funkciju 
\family typewriter
main
\end_layout

\begin_layout Standard
c) naredbu 
\family typewriter
#include
\end_layout

\begin_layout Standard
d) sve pomenuto
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
8.
 Preprocesorske direktive počinju sa:
\end_layout

\begin_layout Standard
a) #
\end_layout

\begin_layout Standard
b) !
\end_layout

\begin_layout Standard
c) <
\end_layout

\begin_layout Standard
d) ništa od pomenutog
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
9.
 Svaka kompletna naredba u jeziku C++ završava se:
\end_layout

\begin_layout Standard
a) tačkom-zarezom
\end_layout

\begin_layout Standard
b) zarezom
\end_layout

\begin_layout Standard
c) dvotačkom
\end_layout

\begin_layout Standard
d) zatvorenom zagradom
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
10.
 Koja od sledećih naredbi je ispravna?
\end_layout

\begin_layout Standard
a) 
\family typewriter
#include (iostream.h)
\end_layout

\begin_layout Standard
b) 
\family typewriter
#include <iostream>
\end_layout

\begin_layout Standard
c) 
\family typewriter
#include {iostream.h}
\end_layout

\begin_layout Standard
d) sve navedene
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
11.
 Komentar 
\family typewriter
/* Ovaj program napisao je A.
 Programer */
\family default
 je u:
\end_layout

\begin_layout Standard
a) C stilu
\end_layout

\begin_layout Standard
b) C++ stilu
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
12.
 Kada se izvršavaju preprocesorske direktive?
\end_layout

\begin_layout Standard
a) pre nego što prevodilac kompajlira program
\end_layout

\begin_layout Standard
b) nakon što prevodilac kompajlira program
\end_layout

\begin_layout Standard
c) istovremeno dok prevodilac kompajlira program
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
13.
 Programski jezik C++ je:
\end_layout

\begin_layout Standard
a) objektno orijentisano proširenje programskog jezika C
\end_layout

\begin_layout Standard
b) proceduralno proširenje programskog jezika C
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
14.
 Programski jezik C++ je standardizovan.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
15.
 Sve C++ naredbe moraju da se završe u istom redu u kome su započete.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
16.
 Program napisan u programskom jeziku C++: 
\end_layout

\begin_layout Standard
a) mora se prevesti na mašinski jezik
\end_layout

\begin_layout Standard
b) ne mora se prevesti na mašinski jezik jer je objektno orijentisan
\end_layout

\begin_layout Standard
c) ne prevodi se, već se interpretira
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
17.
 Tačan redosled u pisanju programa je:
\end_layout

\begin_layout Standard
a) program.obj ->program.cpp->program.exe
\end_layout

\begin_layout Standard
b) program.exe ->program.obj->program.cpp
\end_layout

\begin_layout Standard
c) program.exe ->program.obj->program.exe
\end_layout

\begin_layout Standard
d) program.cpp ->program.obj->program.exe 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
18.
 Objektni kôd je rezultat rada:
\end_layout

\begin_layout Standard
a) editora
\end_layout

\begin_layout Standard
b) kompajlera
\end_layout

\begin_layout Standard
b) linkera
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
19.
 Naziv imenika (namespace) koji sadrži sve nazive standardnih C++ funkcija
 je 
\family typewriter
cout
\family default
.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Chapter
Tipovi podataka i operatori
\end_layout

\begin_layout Standard
Jezgro svakog programskog jezika čine tipovi podataka i operatori koji definišu
 njegova ograničenja.
 C++ podržava brojne tipove podataka i operatore, što ga čini pogodnim za
 različite programerske probleme.
 Iako su operatori dosta široka tema, počećemo pregledom osnovnih tipova
 podataka jezika C++ i najčešće korišćenih operatora.
 Bliže ćemo se upoznati i sa promenljivama i izrazima.
\end_layout

\begin_layout Section
Identifikatori
\end_layout

\begin_layout Standard
Mnogim elementima C++ programa (promenljivama, klasama) potrebno je dati
 određeno ime, tzv.
 
\shape italic
identifikator
\shape default
.
 Imena koja dodeljujemo identifikatorima
\begin_inset Index idx
status open

\begin_layout Plain Layout
identifikatori
\end_layout

\end_inset

 su proizvoljna, uz uslov da poštujemo sledeća tri pravila:
\end_layout

\begin_layout Enumerate
Identifikator može da bude sastavljen od slova engleske abecede (A - Z,
 a - z), brojeva (0 - 9) i donje crte ( _ )
\end_layout

\begin_layout Enumerate
Prvi znak mora da bude slovo ili donja crta
\end_layout

\begin_layout Enumerate
Identifikator ne sme da bude neka ključna reč (Tabela 2.1) niti neka alternativna
 oznaka operatora (Tabela 2.2).
 To ne znači da ključna reč ne može da bude deo identifikatora (na primer,
 
\family typewriter
moj_int
\family default
 je dozvoljeni identifikator iako je 
\family typewriter
int
\family default
 ključna reč).
 Iako 
\family typewriter
main
\family default
 nije ključna reč, treba se ponašati kao da jeste.
 Treba izbegavati dvostruku donju crtu u identifikatorima, ili započinjanje
 identifikatora donjom crtom iza koje sledi veliko slovo, jer su takvi identifik
atori rezervisani za C++ implementacije i standardne biblioteke (npr.
 __LINE__, __FILE__)
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="22" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row endhead="true" endfirsthead="true">
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.1.

\series default
 Ključne reči
\begin_inset Index idx
status open

\begin_layout Plain Layout
ključne reči
\end_layout

\end_inset

 jezika C++.
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
asm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
sizeof
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
auto
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
static
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
bool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
for
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
static_cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
break
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
friend
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
struct
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
case
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
goto
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
switch
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
catch
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
if
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
template
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
inline 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
this
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
throw
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
const
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
const_cast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
mutable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
try
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
continue
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
namespace
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
typedef
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
default
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
typeid
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
delete
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
operator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
typename
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
do
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
private
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
union
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
protected
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
unsigned
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
dynamic_cast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
public 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
using
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
else
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
register
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
virtual
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
enum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
reinterpret_cast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
void
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
explicit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
return
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
volatile
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
export
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
wchar_t
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
extern
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
signed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
while
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.2.

\series default
 Alternativne oznake operatora
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!alternativne oznake
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
and
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
bitand
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
compl
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
not_eq
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
or_eq
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
xor_eq
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
and_eq
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
bit_or
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
not
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
or
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
xor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Vodeći računa o pomenutim ograničenjima, možemo pustiti mašti na volju i
 svoje promenljive i funkcije zvati kako hoćemo.
 Jasno je da je zbog razumljivosti kôda bolje davati razumljiva imena promenljiv
ama, odnosno dodeljivati im imena koja odražavaju njihovu stvarnu funkciju,
 npr.
\end_layout

\begin_layout Standard
\align center

\family typewriter
kamata
\end_layout

\begin_layout Standard
\align center

\family typewriter
Racun
\end_layout

\begin_layout Standard
\align center

\family typewriter
rezultat
\end_layout

\begin_layout Standard
a izbegavati identifikatore poput
\end_layout

\begin_layout Standard
\align center

\family typewriter
Snezana_I_Sedam_Patuljaka
\end_layout

\begin_layout Standard
\align center

\family typewriter
FrankieGoesToHollywood
\end_layout

\begin_layout Standard
\align center

\family typewriter
moja_privatna_promenljiva
\end_layout

\begin_layout Standard
Primetimo da C++ ne dozvoljava korišćenje naših dijakritičkih znakova (č,
 ć, ž, š, đ) u identifikatorima.
 Čak i ako bismo koristili neki kompajler koji ih podržava, treba ih izbegavati
 zbog prenosivosti kôda.
 Takođe, veoma je važno znati da C++ razlikuje mala i velika slova (tj.
 jezik je 
\shape italic
case-sensitive
\shape default
).
 Zbog toga identifikatori
\end_layout

\begin_layout Standard
\align center

\family typewriter
tripraseta
\end_layout

\begin_layout Standard
\align center

\family typewriter
triPraseta
\end_layout

\begin_layout Standard
\align center

\family typewriter
TRIPRASETA
\end_layout

\begin_layout Standard
predstavljaju tri različita imena.
 Ne postoji ograničenje dužine identifikatora, mada neki kompajleri razlikuju
 samo nekoliko prvih znakova (pri čemu je pojam 
\begin_inset Quotes eld
\end_inset

nekoliko
\begin_inset Quotes erd
\end_inset

 prilično neodređen).
 Jasno je da dugačka imena treba izbegavati i zbog sopstvene udobnosti,
 naročito kada se radi o funkcijama i promenljivama koje se često koriste.
 U Tabeli 2.3 prikazano je nekoliko primera dobrih i loših identifikatora.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.3.

\series default
 Primeri identifikatora.
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dobri
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedozvoljeni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
kamata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
7Up
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
velikiCeoBroj
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Ana Marija
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
poluprecnik
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Ana-Marija
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ana_marija
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
_system
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Specijalni znakovi
\end_layout

\begin_layout Standard
U jeziku C++ postoji nekoliko specijalnih znakova
\begin_inset Index idx
status open

\begin_layout Plain Layout
specijalni znakovi
\end_layout

\end_inset

 (
\shape italic
escape sequence
\shape default
) koji se koriste kada je potrebno na ekranu odštampati neki znak koji ima
 specijalnu namenu u jeziku, npr.
 #.
 Svi specijalni znakovi započinju obrnutom kosom crtom (
\backslash
, backslash) koju nikako ne treba mešati sa kosom crtom (/).
 U Tabeli 2.4 prikazani su specijalni znakovi i njihova namena.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.4
\series default
: Neki specijalni znaci
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Specijalni znak
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Naziv
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
newline
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pomera kursor u sledeći red
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tab
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pomera kursor na sledeći tabulator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
alarm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Računar se oglašava 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
backspace
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća kursor za jednu poziciju unazad
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
carriage return
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pomera kursor na početak tekućeg reda
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
backslash
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje obrnutu kosu crtu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
single quote
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje apostrof
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash

\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double quote
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje navodnik
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
?
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
question mark
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje znak pitanja
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Ugrađeni tipovi podataka
\end_layout

\begin_layout Standard
Bez obzira na jezik u kome je pisan, svaki program sastoji se od niza naredbi
 koje menjaju vrednosti objekata koji se nalaze u memoriji računara.
 Da programer tokom pisanja programa ne bi pamtio memorijske adrese, svi
 programski jezici omogućuju da se vrednosti objekata dohvataju preko simbolički
h adresa.
 Tip objekta, između ostalog, određuje i raspored bitova prema kojem je
 objekat sačuvan u memoriji.
\end_layout

\begin_layout Standard
C++ nudi ugrađene tipove podataka
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka
\end_layout

\end_inset

 koji odgovaraju celim brojevima, realnim brojevima u pokretnom zarezu (floating
-point) i logičkim vrednostima.
 To su tipovi vrednosti sa kojima se najčešće radi u programima.
 Kao što ćemo kasnije videti, C++ omogućuje i konstruisanje mnogo složenijih
 tipova, kao što su nabrajanja, strukture i klase, ali se i oni mogu razložiti
 na osnovne (proste) tipove.
 
\end_layout

\begin_layout Standard
Još jedan razlog zbog koga su tipovi podataka toliko važni za C++ programiranje
 jeste to što su osnovni tipovi čvrsto povezani sa osnovnim blokovima sa
 kojima računar radi: bajtovima i rečima.
 Jezik C++ omogućuje rad sa istim tipovima podataka sa kojima radi i procesor,
 što omogućuje pisanje veoma efikasnog, sistemskog kôda.
 C++ podržava sedam osnovnih tipova podataka prikazanih u sledećoj tabeli:
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.5
\series default
: Sedam osnovnih
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka!osnovni
\end_layout

\end_inset

 tipova jezika C++
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tip
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Značenje
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
znak
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
w_char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

široki
\begin_inset Quotes erd
\end_inset

 znak
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ceo broj
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
decimalni broj
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
decimalni broj u dvostrukoj preciznosti
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
bool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
logička vrednost
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
void
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bez vrednosti
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
C++ dozvoljava proširivanje osnovnih tipova navođenjem modifikatora ispred
 naziva tipa podataka
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka!modifikatori
\end_layout

\end_inset

.
 Modifikator menja značenje osnovnog tipa tako da bude pogodniji za specifične
 načine korišćenja.
 Postoji četiri modifikatora tipa: 
\family typewriter
signed
\begin_inset Index idx
status open

\begin_layout Plain Layout
signed
\end_layout

\end_inset


\family default
, 
\family typewriter
unsigned
\begin_inset Index idx
status open

\begin_layout Plain Layout
unsigned
\end_layout

\end_inset


\family default
, 
\family typewriter
long
\begin_inset Index idx
status open

\begin_layout Plain Layout
long
\end_layout

\end_inset


\family default
 i 
\family typewriter
short
\begin_inset Index idx
status open

\begin_layout Plain Layout
short
\end_layout

\end_inset


\family default
.
 Svi osnovni tipovi su standardno označeni (
\family typewriter
signed
\family default
).
 Tabela 2.6 prikazuje sve dozvoljene kombinacije osnovnih tipova, kao i garantova
n minimalni opseg za svaki tip prema ANSI/ISO C++ standardu.
 
\end_layout

\begin_layout Standard
Stvarni opseg tipa u jeziku C++ zavisi od konkretne implementacije.
 Pošto C++ standard zadaje samo minimalni opseg koji tip podataka mora da
 podrži, u dokumentaciji kompajlera uvek treba proveriti stvarne opsege.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="25text%">
<column alignment="center" valignment="top" width="15text%">
<column alignment="left" valignment="top" width="45text%">
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.6
\series default
: Opseg osnovnih C++ 
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka!opseg
\end_layout

\end_inset

tipova prema ANSI/ISO standardu
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tip
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Veličina u bajtovima
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opseg definisan ANSI/ISO standardom
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
bool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
true 
\family default
ili
\family typewriter
 false
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
-128 
\family default
do
\family typewriter
 127
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
unsigned char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
0 
\family default
do
\family typewriter
 255
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
signed char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
-128 
\family default
do
\family typewriter
 127
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
-2 147 483 648 
\family default
do
\family typewriter
 2 147 483 647
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
unsigned int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
0 
\family default
do
\family typewriter
 4 294 967 295
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
signed int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
isto kao 
\family typewriter
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
short int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
-32 768 do 32 767
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
unsigned short int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
0 
\family default
do
\family typewriter
 65 535
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
signed short int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
isto kao 
\family typewriter
short int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
long int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
-2 147 483 648 
\family default
do
\family typewriter
 2 147 483 647
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
signed long int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
isto kao 
\family typewriter
long int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
unsigned long int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
0 
\family default
do
\family typewriter
 4 294 967 295
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
±3,4 x 10
\begin_inset script superscript

\begin_layout Plain Layout

\family typewriter
±
\end_layout

\end_inset

38 
\family default
sa tačnošću od 
\begin_inset Newline newline
\end_inset

približno 7 cifara
\family typewriter
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
±1,7 x 10
\begin_inset script superscript

\begin_layout Plain Layout

\family typewriter
±
\end_layout

\end_inset

308 
\family default
sa tačnošću od 
\begin_inset Newline newline
\end_inset

približno 15 cifara
\family typewriter
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
long double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
isto kao
\family typewriter
 double 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Kada se u C++ programu uvodi neka promenljiva, mora se deklarisati kog je
 ona tipa.
 Pošto ne može da postoji promenljiva za koju se ne zna kog je tipa, kaže
 se da je C++ strogo tipiziran jezik.
 Za razliku od programskog jezika C u kome sve deklaracije moraju da budu
 na početku programa ili funkcije, u jeziku C++ ne postoji takvo ograničenje,
 pa se deklaracije promenljivih
\begin_inset Index idx
status open

\begin_layout Plain Layout
promenljive!deklaracija
\end_layout

\end_inset

 mogu nalaziti bilo gde u programu, ali pre prvog korišćenja promenljive.
 Promenljiva se 
\shape italic
deklariše
\shape default
 navođenjem tipa i imena:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int tezina; //deklaracija celobrojne promenljive
\end_layout

\begin_layout Standard

\family typewriter
\size small
unsigned short int dani; //deklaracija pozitivne celobrojne promenljive
\end_layout

\begin_layout Standard
Tip promenljive određuje koliko bajtova u memoriji će za nju biti odvojeno.
 Ukoliko se prilikom deklaracije promenljivoj dodeli i početna vrednost
 pomoću operatora dodele (=), kaže se da je promenljiva
\begin_inset Index idx
status open

\begin_layout Plain Layout
promenljive!inicijalizacija
\end_layout

\end_inset

 i 
\shape italic
inicijalizovana
\shape default
:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int tezina = 70; //deklaracija i inicijalizacija celobrojne promenljive
\end_layout

\begin_layout Standard
Dakle, pod 
\shape italic
deklarisanjem
\shape default
 promenljive podrazumeva se definisanje imena i tipa promenljive, dok se
 pod 
\shape italic
definisanjem
\shape default
 promenljive podrazumeva da se za nju odvaja i prostor u memoriji.
 Osim nekih specijalnih slučajeva o kojima će biti reči u nastavku knjige,
 svaka deklaracija u jeziku C++ istovremeno je i definicija
\begin_inset Index idx
status open

\begin_layout Plain Layout
promenljive!definicija
\end_layout

\end_inset

, odnosno čim se promenljiva deklariše, za nju se automatski rezerviše prostor
 u memoriji.
 
\end_layout

\begin_layout Subsection
Promenljive i konstante
\end_layout

\begin_layout Standard
Promenljiva se tako zove zato što njena vrednost može da se menja.
 
\shape italic
Konstante
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
konstante
\end_layout

\end_inset

 (ili literali
\begin_inset Index idx
status open

\begin_layout Plain Layout
literali
\end_layout

\end_inset

) su podaci čija se vrednost tokom izvršavanja programa ne može menjati,
 odnosno vrednosti koje predstavljaju 
\begin_inset Quotes eld
\end_inset

same sebe
\begin_inset Quotes erd
\end_inset

.
 U Tabeli 2.7 prikazano je nekoliko vrednosti konstanti.
 U nastavku ćemo se detaljnije pozabaviti osobinama svih osnovnih tipova
 podataka ugrađenih u jezik, gde ćemo objasniti i označavanje konstanti
 za sve tipove pojedinačno.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.7
\series default
: Primeri konstanti (literala)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tip
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Primeri literala
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
'A', 'Z', '8', '*' 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-77, 65, 0x9FE 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
unsigned int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
10U, 64000U 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-77L, 65L, 12345L 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
unsigned long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
5UL 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
3.14f 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
1.414 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
bool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
true, false
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Celobrojni podaci (int)
\end_layout

\begin_layout Standard
U računarima koji koriste aritmetiku komplementa dvojke (a takvi su gotovo
 svi), ceo broj
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka!celobrojni
\end_layout

\end_inset

 (tip 
\family typewriter
int
\family default
) imaće opseg od najmanje −32 768 do najviše 32 767.
 Iako nije sigurno da tip 
\family typewriter
int
\begin_inset Index idx
status open

\begin_layout Plain Layout
int
\end_layout

\end_inset


\family default
 zauzima 4 bajta, u svim slučajevima, međutim, opseg tipa 
\family typewriter
short int
\family default
 biće podskup opsega za 
\family typewriter
int
\family default
, koji će sa svoje strane biti podskup opsega za tip 
\family typewriter
long int
\family default
.
 Dakle, tip 
\family typewriter
int
\family default
 i tip 
\family typewriter
long
\begin_inset Index idx
status open

\begin_layout Plain Layout
long
\end_layout

\end_inset

 int
\family default
 mogu da imaju isti opseg, ali 
\family typewriter
int
\family default
 ne može da ima veći opseg od tipa 
\family typewriter
long int
\family default
.
\end_layout

\begin_layout Standard
Standardno su svi celobrojni tipovi označeni (
\family typewriter
signed
\family default
).
 Modifikator 
\family typewriter
unsigned
\family default
 treba koristiti samo za pozitivne podatke, npr.
 ako promenljiva treba da sadrži godine starosti ili težinu.
 Pri tom treba voditi računa da kompajler ne prijavljuje grešku ako se promenlji
voj koja je deklarisana kao 
\family typewriter
unsigned
\family default
 dodeli neka negativna vrednost, već o tome mora da vodi računa programer.
 Prilikom deklaracije, može se i izostaviti 
\family typewriter
int
\family default
, kao u sledećem primeru:
\end_layout

\begin_layout Standard

\family typewriter
\size small
unsigned sobe = 32;
\end_layout

\begin_layout Standard

\family typewriter
\size small
long apartmani = 300;
\end_layout

\begin_layout Standard
Celobrojne konstante su standardno tipa 
\family typewriter
int
\family default
:
\end_layout

\begin_layout Standard

\family typewriter
\size small
sobe = 300;
\end_layout

\begin_layout Standard

\family typewriter
\size small
apartmani = 32;
\end_layout

\begin_layout Standard
Ako želimo celobrojnu konstantu tipa 
\family typewriter
long
\family default
, na kraj konstante treba dodati 
\family typewriter
L
\family default
 ili 
\family typewriter
l
\family default
; za neoznačenu 
\family typewriter
U
\family default
 ili 
\family typewriter
u
\family default
, a ovi simboli se mogu i kombinovati:
\end_layout

\begin_layout Standard

\family typewriter
\size small
spratovi = 32L;
\end_layout

\begin_layout Standard

\family typewriter
\size small
sobe = 300UL;
\end_layout

\begin_layout Standard

\family typewriter
\size small
apartmani = 10u;
\end_layout

\begin_layout Standard
Ako tip literala nije zadat, C++ kompajler standardno celobrojnoj vrednosti
 dodeljuje najmanji celobrojni tip u koji ona može da stane, a to je po
 pravilu tip 
\family typewriter
int
\family default
.
 C++ podrazumeva da su celobrojne konstante predstavljene u decimalnom brojnom
 sistemu.
 Heksadecimalne konstante počinju znakom 
\family typewriter
0x
\family default
, a oktalne konstante znakom 
\family typewriter
0
\family default
:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int tucePatuljaka = 0x0C; //12 decimalno
\end_layout

\begin_layout Standard

\family typewriter
\size small
int SnezanaIPatuljci = 010; //8 decimalno
\end_layout

\begin_layout Standard
Sve konstante koje počinju nulom kompajler tretira kao oktalne brojeve,
 što znači da će nakon prevođenja 010 i 10 biti dva različita broja, pa
 o tome treba voditi računa.
\end_layout

\begin_layout Subsection
Znakovni podaci (char)
\end_layout

\begin_layout Standard
Tip 
\family typewriter
char
\begin_inset Index idx
status open

\begin_layout Plain Layout
char
\end_layout

\end_inset


\family default
 služi za smeštanje znakova, ali je to u suštini celobrojni tip podataka
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka!znakovni
\end_layout

\end_inset

 i može se koristiti za čuvanje 
\begin_inset Quotes eld
\end_inset

malih
\begin_inset Quotes erd
\end_inset

 brojeva.
 Razlog zbog koga se za čuvanje znakova koristi celobrojni tip jeste to
 što su znakovi u računaru predstavljeni brojevima.
 Najčešće korišćen metod za predstavljanje znakova jeste ASCII kôd
\begin_inset Index idx
status open

\begin_layout Plain Layout
ASCII kôd
\end_layout

\end_inset

 (Dodatak A).
 Znakovna promenljiva se deklariše i inicijalizuje na sledeći način:
\end_layout

\begin_layout Standard

\family typewriter
\size small
char slovo = 'A';
\end_layout

\begin_layout Standard

\family typewriter
\size small
slovo = 65; //ASCII kod slova A
\end_layout

\begin_layout Standard
Znakovne konstante
\begin_inset Index idx
status open

\begin_layout Plain Layout
znakovne konstante
\end_layout

\end_inset

 navode se pod jednostrukim navodnicima (npr.
 
\family typewriter
'A'
\family default
).
 Kada se znak smešta u memoriju, zapravo se smešta njegov numerički kôd;
 kada se od računara zatraži da ispiše znak na ekranu, on prikazuje znak
 koji odgovara tom kôdu.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//program koji demonstrira blisku vezu 
\end_layout

\begin_layout LyX-Code

\size small
//izmedju znakova i celih brojeva
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char slovo; 
\end_layout

\begin_layout LyX-Code

\size small
slovo = 65; 
\end_layout

\begin_layout LyX-Code

\size small
cout << slovo << endl; 
\end_layout

\begin_layout LyX-Code

\size small
slovo = 66; 
\end_layout

\begin_layout LyX-Code

\size small
cout << slovo << endl; 
\end_layout

\begin_layout LyX-Code

\size small
slovo = 'C'; 
\end_layout

\begin_layout LyX-Code

\size small
cout << slovo << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
A
\end_layout

\begin_layout Standard

\series bold
\size small
B
\end_layout

\begin_layout Standard

\series bold
\size small
C
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
C++ podržava još jedan tip literala osim konstanti ugrađenih tipova, a to
 je string.
 String konstanta
\begin_inset Index idx
status open

\begin_layout Plain Layout
string!konstanta
\end_layout

\end_inset

 je skup znakova između navodnika.
 Na primer, “ovo je test” je string.
 U prethodnim primerima programa viđali smo stringove u naredbama 
\family typewriter
cout
\family default
.
 Treba zapamtiti da iako C++ dozvoljava definisanje string konstanti, on
 nema ugrađen tip podataka string.
 Umesto toga, kao što ćete saznati u nastavku knjige, stringovi su u jeziku
 C++ podržani kao nizovi znakova (u biblioteci klasa ugrađenoj u jezik takođe
 postoji klasa string, o kojoj će kasnije biti reči.)
\end_layout

\begin_layout Standard
U tip 
\family typewriter
wchar_t
\family default
 smeštaju se znaci koji pripadaju većim skupovima od engleske abecede, tj.
 ASCII kôda
\begin_inset Index idx
status open

\begin_layout Plain Layout
ASCII kôd
\end_layout

\end_inset

 (kao što je npr.
 Unicode).
 Mnogi jezici, kao što je kineski, imaju veliki broj znakova koji ne može
 da se kodira pomoću samo 8 bitova koliko staje u tip 
\family typewriter
char
\family default
.
 Zbog toga je u C++ dodat tip 
\family typewriter
wchar_t
\family default
 koji u ovoj knjizi nećemo koristiti, ali ćete se sa njim sigurno susresti
 u programima namenjenim za inostrana tržišta.
\end_layout

\begin_layout Subsection
Brojevi u pokretnom zarezu (float, double)
\end_layout

\begin_layout Standard
Vrednosti koje nisu celobrojne predstavljaju se kao brojevi u pokretnom
 zarezu
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka!brojevi u pokretnom zarezu
\end_layout

\end_inset

 (floating point).
 Broj u pokretnom zarezu može se predstaviti kao decimalna vrednost (npr.
 112.5), ili u eksponencijalnoj notaciji.
 U eksponencijalnoj notaciji, decimalni deo ispred simbola E (ili e) množi
 se sa deset na stepen (eksponent) zadat nakon slova E.
 Na primer, 1.125e2 znači 1.125×10
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

, a to je 112.5.
 Praznine unutar broja (npr.
 iza predznaka, ili između cifara i slova) nisu dozvoljene.
 Konstanta u pokretnom zarezu mora da sadrži decimalnu tačku, eksponent,
 ili oba.
 Ako nema ni tačke ni eksponenta, numerička vrednost se tumači kao ceo broj.
 Za brojeve u pokretnom zarezu koriste se tipovi 
\family typewriter
float
\begin_inset Index idx
status open

\begin_layout Plain Layout
float
\end_layout

\end_inset


\family default
 i 
\family typewriter
double
\begin_inset Index idx
status open

\begin_layout Plain Layout
double
\end_layout

\end_inset


\family default
; razlika između ova dva tipa je u opsegu koji mogu da sadrže.
 U tip 
\family typewriter
double
\family default
 može da stane približno deset puta veći broj nego u tip
\family typewriter
 float
\family default
.
 Zbog tog se tip 
\family typewriter
double
\family default
 češće koristi.
 Još jedan razlog za češće korišćenje tipa 
\family typewriter
double
\family default
 jeste to što većina matematičkih funkcija u C++ biblioteci koristi 
\family typewriter
double
\family default
 vrednosti.
\end_layout

\begin_layout Standard

\family typewriter
\size small
float pi = 3.1415;
\end_layout

\begin_layout Standard

\family typewriter
\size small
float naelektrisanjeElektrona = 1.6e-19;
\end_layout

\begin_layout Standard

\family typewriter
\size small
double masaSunca = 2E30;
\end_layout

\begin_layout Subsection
Logički tip (bool)
\end_layout

\begin_layout Standard
Tip 
\family typewriter
bool
\begin_inset Index idx
status open

\begin_layout Plain Layout
bool
\end_layout

\end_inset


\family default
 type je relativno nov dodatak u jezik C++.
 U njemu se čuvaju logičke
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka!logički
\end_layout

\end_inset

 vrednosti (tj.
 tačno/netačno).
 C++ definiše dve logičke konstante, 
\family typewriter
true
\family default
 i 
\family typewriter
false
\family default
, i to su jedine dve vrednosti koje tip 
\family typewriter
bool
\family default
 može da ima.
 
\end_layout

\begin_layout Standard
Bilo koja vrednost različita od nule u jeziku C++ tumači se kao tačno 
\family typewriter
(true
\family default
), a vrednost nula tumači se kao netačno 
\family typewriter
(false
\family default
); ovo svojstvo je naročito korisno u logičkim izrazima.
 Kada se koristi u izrazima koji nisu logički, važi obrnuto: 
\family typewriter
true
\family default
 se konvertuje u 1, a 
\family typewriter
false
\family default
 u 0.
 Automatska konverzija vrednosti nula i vrednosti različitih od nule u logičke
 ekvivalente posebno je važna u kontrolnim naredbama, o čemu će biti reči
 u Poglavlju 3.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
bool b = false; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "b je " << b << endl; 
\end_layout

\begin_layout LyX-Code

\size small
b = true; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "b je " << b << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\paragraph_spacing single

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard
\paragraph_spacing single

\series bold
\size small
b je 0
\end_layout

\begin_layout Standard
\paragraph_spacing single

\series bold
\size small
b je 1
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Section
Operatori
\end_layout

\begin_layout Subsection
Operator dodele
\end_layout

\begin_layout Standard
Operator dodele
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!dodela
\end_layout

\end_inset

 smo već koristili u prethodnim primerima programa, a sada ćemo se njime
 detaljnije pozabaviti.
 Operator dodele (assignment operator) u jeziku C++ radi slično kao i u
 drugim programskim jezicima i ima opšti oblik
\end_layout

\begin_layout Standard

\family typewriter
\size small
promenljiva = izraz;
\end_layout

\begin_layout Standard
što znači da se vrednost izraza dodeljuje promenljivoj.
 Operator dodele se može koristiti i lančano, kao u sledećem primeru: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
int x, y, z;
\end_layout

\begin_layout Standard

\family typewriter
\size small
x = y = z = 100;
\end_layout

\begin_layout Standard
Ova naredba dodeljuje vrednost 100 promenljivama x, y i z u jednom koraku.
 To je moguće zato što je rezultat operatora dodele izraz sa njegove desne
 strane.
 Tako je rezultat naredbe z = 100 zapravo 100, taj rezultat se zatim dodeljuje
 promenljivoj y, i na kraju se rezultat izraza y = 100 (što je opet 100)
 dodeljuje promenljivoj x.
 
\end_layout

\begin_layout Standard
Operatorom dodele menja se vrednost objekta, pri čemu tip objekta ostaje
 nepromenjen.
 Najčešći operator dodele je znak jednakosti ( = ) kojim se objektu sa leve
 strane dodeljuje neka vrednost sa desne strane.
 Ako su objekat sa leve strane i vrednost sa desne strane različitih tipova,
 vrednost se svodi na tip objekta prema definisanim pravilima konverzije,
 što će biti objašnjeno u odeljku 2.5.
 Očigledno je da se s leve strane operatora dodele mogu nalaziti samo promenljiv
i objekti, tzv.
 
\shape italic
lvrednosti
\shape default
 (engl.
 
\shape italic
lvalues
\shape default
, skraćenica od 
\shape italic
left-hand side values
\shape default
).
 Pri tom treba znati da se ne može svakoj lvrednosti
\begin_inset Index idx
status open

\begin_layout Plain Layout
lvrednosti
\end_layout

\end_inset

 dodeljivati nova vrednost, jer se neke promenljive mogu deklarisati i tako
 da budu konstantne, pa će pokušaj njihove promene kompajler prepoznati
 kao grešku.
 Sa desne strane operatora dodele mogu biti i lvrednosti i konstante.
 
\end_layout

\begin_layout Standard

\family typewriter
\size small
3.1415 = pi; //greska!
\end_layout

\begin_layout Standard

\family typewriter
\size small
int i;
\end_layout

\begin_layout Standard

\family typewriter
\size small
i = i + 5;
\end_layout

\begin_layout Standard

\family typewriter
\size small
int j = 5;
\end_layout

\begin_layout Subsection
Aritmetički operatori
\end_layout

\begin_layout Standard
Operatori
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!aritmetički
\end_layout

\end_inset

 +, –, * i / u jeziku C++ imaju isto značenje kao u algebri i mogu se primeniti
 na bilo koji ugrađen numerički tip podataka (kao i na podatke tipa 
\family typewriter
char
\family default
).
 Mogu se podeliti na unarne, koji deluju na samo jedan operand, i binarne,
 koji rade sa dva operanda.
 
\end_layout

\begin_layout Standard
Operator % (modulo) daje ostatak celobrojnog deljenja.
 Kada se operator / primeni na podatak tipa 
\family typewriter
int
\family default
, eventualni ostatak deljenja se odseca; na primer, rezultat operacije 10/3
 daće 3.
 Ostatak celobrojnog deljenja može se dobiti operacijom modulo
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!modulo
\end_layout

\end_inset

 (%).
 Na primer, 10 % 3 daje 1.
 U jeziku C++, operator % može da se primeni samo na celobrojne operande,
 ne i na podatke u pokretnom zarezu.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.8
\series default
: Aritmetički operatori
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Značenje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tip
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sabiranje 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binarni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
oduzimanje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binarni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
množenje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binarni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
deljenje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binarni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modulo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binarni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
inkrementiranje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unarni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dekrementiranje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unarni
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Operatori inkrementiranja i dekrementiranja
\end_layout

\begin_layout Standard
Operator ++ uvećava vrednost celobrojne promenljive za jedan, što se zove
 inkrementiranje
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!++
\end_layout

\end_inset

.
 Operator -- smanjuje vrednost celobrojne promenljive za 1, tj.
 dekrementira
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!--
\end_layout

\end_inset

 je.
 
\end_layout

\begin_layout Standard

\family typewriter
\size small
int i = 0;
\end_layout

\begin_layout Standard

\family typewriter
\size small
++i;
\end_layout

\begin_layout Standard

\family typewriter
\size small
cout << i; //ispisuje 1
\end_layout

\begin_layout Standard

\family typewriter
\size small
--i;
\end_layout

\begin_layout Standard

\family typewriter
\size small
cout << i; //ispisuje 0
\end_layout

\begin_layout Standard

\family typewriter
x++
\family default
 je isto što i 
\family typewriter
x = x + 1
\family default
, a 
\family typewriter
x--
\family default
 je isto što i 
\family typewriter
x = x - 1
\family default
.
 Treba uočiti razliku kada je operator inkrementiranja (dekrementiranja)
 napisan ispred operatora ili iza njega.
 Kada je napisan ispred operanda, radi se o prefiksnom obliku; tada će se
 vrednost promenljive prvo inkrementirati (dekrementirati), a zatim će se
 raditi sa promenjenom vrednošću.
 Ako je operator iza promenljive, prvo će se pročitati vrednost promenljive,
 a tek zatim će ona biti promenjena.
 
\end_layout

\begin_layout Standard
U prethodnom primeru svejedno je da li su operatori napisani u prefiksnom
 ili u postfiksnom obliku.
 Međutim, kada je inkrementiranje ili dekrementiranje deo složenijeg izraza,
 to postaje važno.
 Na primer:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int x = 1, y;
\end_layout

\begin_layout Standard

\family typewriter
\size small
y = ++x; //y je 2, x je 1
\end_layout

\begin_layout Standard

\family typewriter
\size small
y = x--; //y je 2, x je 1
\end_layout

\begin_layout Subsubsection
Skraćeni operatori dodele
\end_layout

\begin_layout Standard
C++ je od jezika C nasledio i skraćeno
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!skraćeni oblik
\end_layout

\end_inset

 pisanje naredbi.
 Opšti oblik skraćene naredbe je:
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
\size small
levo op= desno;
\end_layout

\begin_layout Standard
gde je op neki od sledećih operanada:
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="10">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Neke od ovih operatora smo već videli, a sa nekima ćemo se susresti u nastavku
 poglavlja.
 Značenje ove notacije je isto kao naredba:
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
\size small
levo = levo op desno;
\end_layout

\begin_layout Standard
Tako su, na primer, sledeće tri naredbe funkcionalno identične:
\end_layout

\begin_layout Standard

\family typewriter
\size small
x = x + 1;
\end_layout

\begin_layout Standard

\family typewriter
\size small
x++;
\end_layout

\begin_layout Standard

\family typewriter
\size small
x+=1; //skracena notacija
\end_layout

\begin_layout Standard
Skraćeni operatori dodele imaju dve prednosti.
 Prvo, kompaktniji su od odgovarajućih standardnih naredbi.
 Drugo, često daju efikasniji izvršni kôd, jer se operand proverava samo
 jednom.
 Zbog toga se ovakav oblik naredbi dodele često sreće u profesionalno napisanim
 C++ programima.
\end_layout

\begin_layout Subsection
Relacioni i logički operatori
\end_layout

\begin_layout Standard
Relacioni operatori
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!relacioni
\end_layout

\end_inset

 omogućuju poređenje logičkih vrednosti i određivanje vrednosti koja je
 veća, manja, jednaka ili različita.
 Svi relacioni operatori su binarni, tj.
 zahtevaju dva operanda i pridružuju se sleva udesno.
 U Tabeli 2.9 prikazani su relacioni operatori i njihovo značenje:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.9
\series default
: Relacioni operatori
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Izraz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Značenje
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
x > y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Da li je x veće od y?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
x < y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Da li je x manje od y?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
x >= y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Da li je x veće ili jednako y?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
x <= y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Da li je x manje ili jednako y?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
x == y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Da li je x jednako y?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
x != y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Da li je x različito od y?
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Treba zapamtiti suštinsku razliku između jednostrukog znaka jednakosti (
\family typewriter
=
\family default
) koji je simbol za dodelu, i dvostrukog znaka jednakosti (
\family typewriter
==
\family default
) koji je simbol za poređenje Rezultat logičke operacije moće da bude tačan
 ili pogrešan.
 Netačno poređenje (kada je rezultat relacione operacije 
\family typewriter
false
\family default
) uvek se predstavlja kao 0, dok je vrednost tačnog poređenja (
\family typewriter
true
\family default
) broj 1.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//program koji prikazuje vrednosti stanja true i false
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int tacnaVrednost, pogresnaVrednost, x=5, y=10; 
\end_layout

\begin_layout LyX-Code

\size small
tacnaVrednost = x < y; 
\end_layout

\begin_layout LyX-Code

\size small
pogresnaVrednost = x == y; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Tacno je: " << tacnaVrednost << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Pogresno je: " << pogresnaVrednost << endl;
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Tacno je 1
\end_layout

\begin_layout Standard

\series bold
\size small
Pogresno je 0
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Logički operatori
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!logički
\end_layout

\end_inset

 povezuju nekoliko relacionih izraza u jedan, ili invertuju logiku izraza.
 U Tabeli 2.10 prikazani su logički operatori po redosledu prioriteta:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.10
\series default
: Logički operatori
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NOT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logička negacija
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logičko i 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
||
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logičko ili
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Logička negacija je unarni operator koji menja logičku vrednost promenljive
 (iz
\family typewriter
 true
\family default
 u 
\family typewriter
false
\family default
 ili obrnuto).
 Logičko i je binarni operator koji kao rezultat daje 
\family typewriter
true
\family default
 samo ako su oba operanda 
\family typewriter
true
\family default
.
 Logičko ili je takođe binarni operator; da bi dao tačnu vrednost, dovoljno
 je da barem jedan od operanada ima vrednost 
\family typewriter
true
\family default
.
 Logički operatori najčešće se koriste u naredbama za grananje toka programa,
 pa ćemo ih kasnije detaljnije proučiti.
\end_layout

\begin_layout Subsection
Definisanje sinonima za tipove podataka: typedef
\end_layout

\begin_layout Standard
Ključna reč 
\family typewriter
typedef
\family default
 omogućuje definisanje sopstvenih naziva za postojeće tipove podataka.
 Na primer, pomoću ključne reči 
\family typewriter
typedef
\family default
 mogli bismo da uvedemo naziv 
\family typewriter
VelikiCeoBroj
\family default
 kao zamenu za tip
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka!typedef
\end_layout

\end_inset

 
\family typewriter
long int
\family default
 pomoću sledeće deklaracije:
\end_layout

\begin_layout Standard

\family typewriter
\size small
typedef long int VelikiCeoBroj;
\end_layout

\begin_layout Standard
Na ovaj način 
\family typewriter
VelikiCeoBroj
\family default
 postaje alternativni specifikator tipa za 
\family typewriter
long int
\family default
, pa možemo da deklarišemo promenljivu 
\family typewriter
mojBroj
\family default
 kao 
\family typewriter
long int
\family default
 pomoću sledeće deklaracije:
\end_layout

\begin_layout Standard

\family typewriter
\size small
VelikiCeoBroj mojBroj = 0L;
\end_layout

\begin_layout Standard
Nema razlike između ove deklaracije i one koja koristi ime ugrađenog tipa.
 I dalje može da se piše: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
long int mojBroj = 0L;
\end_layout

\begin_layout Standard
Dakle, čak i ako se definiše ime tipa kao što je 
\family typewriter
VelikiCeoBroj
\family default
, i dalje mogu da se koriste oba specifikatora za deklarisanje različitih
 promenljivih koje će na kraju biti istog tipa.
 Iako je korišćenje reči 
\family typewriter
typedef
\begin_inset Index idx
status open

\begin_layout Plain Layout
typedef
\end_layout

\end_inset


\family default
 u funkciji sinonima za postojeći tip na prvi pogled trivijalno, ono je
 važno za uprošćavanje složenijih deklaracija, što čini kôd mnogo čitljivijim.
 Takođe, ako je isti program potrebno optimizovati i ponovo kompajlirati
 za različite platforme, preporučljivo je definisati sinonime za ugrađene
 tipove pomoću ključne reči 
\family typewriter
typedef
\family default
 (na primer, ako za celobrojne promenljive na jednoj platformi treba da
 se koristi tip 
\family typewriter
int
\family default
, a na drugoj 
\family typewriter
long
\family default
, tip svih celobrojnih promenljivih deklarisanih u programu može se lako
 promeniti na jednom mestu - samo u deklaraciji 
\family typewriter
typedef
\family default
).
 
\end_layout

\begin_layout Subsection
Operator sizeof
\end_layout

\begin_layout Standard
Već smo pomenuli da se veličina memorijskog prostora i opseg vrednosti koji
 određeni tip zauzima menjaju u zavisnosti od kompajlera i platforme.
 Najvažniji podaci o celobrojnim opsezima mogu se naći u zaglavlju
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja!
\family typewriter
climits
\end_layout

\end_inset

 
\family typewriter
climits
\family default
, a za decimalne brojeve u zaglavlju
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja!
\family typewriter
cfloat
\end_layout

\end_inset

 
\family typewriter
cfloat
\family default
.
 Na primer, u zaglavlju 
\family typewriter
climits
\family default
 definisane su konstante 
\family typewriter
INT_MIN
\family default
 i 
\family typewriter
INT_MAX
\family default
 sa najmanjom i najvećom vrednošću tipa 
\family typewriter
int
\family default
.
\end_layout

\begin_layout Standard
U jeziku C++ postoji i poseban operator
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!sizeof
\end_layout

\end_inset

 
\family typewriter
sizeof
\begin_inset Index idx
status open

\begin_layout Plain Layout
sizeof
\end_layout

\end_inset


\family default
 koji prikazuje dužinu određenog tipa u bajtovima.
 Njegovo korišćenje ilustruje sledeći primer:
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <climits> 
\end_layout

\begin_layout LyX-Code

\size small
#include <cfloat> 
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Najmanji int: " << INT_MIN << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Najveci int: " << INT_MAX << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Najmanji double: " << DBL_MIN << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Najveci float: " << FLT_MAX << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Tip double na ovom racunaru zauzima " << sizeof(double) 
\end_layout

\begin_layout LyX-Code

\size small
<< " bajtova" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Tip long zauzima " << sizeof(long) << " bajta" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Najmanji int: -2147483648
\end_layout

\begin_layout Standard

\series bold
\size small
Najveci int: 2147483648
\end_layout

\begin_layout Standard

\series bold
\size small
Najmanji double: 2.22507e-308
\end_layout

\begin_layout Standard

\series bold
\size small
Najveci float: 3.40282e+038
\end_layout

\begin_layout Standard

\series bold
\size small
Tip double na ovom racunaru zauzima 8 bajtova
\end_layout

\begin_layout Standard

\series bold
\size small
Tip long zauzima 4 bajta
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsection
Operator nabrajanja (,)
\end_layout

\begin_layout Standard
Operator nabrajanja
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!nabrajanje
\end_layout

\end_inset

 (ili razdvajanja) koristi se za razdvajanje izraza u naredbama.
 Navedeni izrazi se izvršavaju postepeno, sleva udesno, a rezultat operatora
 je vrednost poslednjeg izraza u nabrajanju.
 Prilikom korišćenja operatora zarez u složenijim naredbama treba biti vrlo
 oprezan, jer mu je prioritet vrlo nizak.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
long num1=0, num2=0, num3=0, num4=0; 
\end_layout

\begin_layout LyX-Code

\size small
num4=(num1=10, num2=20, num3=30); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Vrednost niza izraza je vrednost " << 
\end_layout

\begin_layout LyX-Code

\size small
" poslednjeg izraza sa desne strane: " << num4 << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Vrednost niza izraza je vrednost poslednjeg izraza sa desne strane: 30
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsection
Osnovne operacije ulaza i izlaza 
\end_layout

\begin_layout Standard
Ulaz i izlaz podataka u jeziku C++ zasnovani su na apstraktnom pojmu tokova
 podataka
\begin_inset Index idx
status open

\begin_layout Plain Layout
tokovi podataka
\end_layout

\end_inset

 (stream), kojima ćemo se detaljnije baviti u Poglavlju 8.
 
\end_layout

\begin_layout Standard
U prethodnim primerima videli smo kako se objekat izlaznog toka 
\family typewriter
cout
\family default
 koristi za ispis podataka na konzolu pomoću operatora umetanja
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!<<
\end_layout

\end_inset

 (insertion operator) <<.
 Podaci se šalju u izlazni tok (output stream), odnosno čitaju iz ulaznog
 toka (input stream).
 Odgovarajući objekat ulaznog toka za čitanje podataka sa tastature zove
 se 
\family typewriter
cin
\family default
.
 Znaci se sa tastature u objekat ulaznog toga 
\family typewriter
cin
\family default
 učitavaju se pomoću operatora izdvajanja
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!>>
\end_layout

\end_inset

 (>>): 
\end_layout

\begin_layout Standard

\family typewriter
\size small
cin >> promenljiva;
\end_layout

\begin_layout Standard
Operator izdvajanja (extraction operator) “pokazuje”u smeru toka podataka:
 u ovom slučaju, iz objekta ulaznog toka 
\family typewriter
cin
\family default
 na promenljivu koja prima podatke.
 Ako ima praznina, one se preskaču, a prva vrednost koja se otkuca na tastaturi
 biće dodeljena promenljivoj jer se naredbe ulaza izvršavaju sleva udesno.
 Operacija učitavanja iz toka završava se kada se pritisne taster Enter.
 Operacije učitavanja iz ulaznog toka automatski rade sa svim promenljivama
 ugrađenih tipova.
 Za formatiranje ulaza i izlaza koriste se tzv.
 manipulatori i o tome ćemo detaljnije učiti u Poglavlju 8.
\end_layout

\begin_layout Subsection
Prioritet i asocijativnost operatora
\end_layout

\begin_layout Standard
U Tabeli 2.11 prikazan je prioritet operatora
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!prioritet
\end_layout

\end_inset

.
 Mnoge od njih još nismo objasnili, ali ćemo se sa njima susresti u nastavku
 knjige.
\end_layout

\begin_layout Standard
Operatori su u tabeli navedeni u grupama po opadajućem prioritetu.
 Vodoravne linije u tabeli označavaju promenu u prioritetu operatora.
 
\end_layout

\begin_layout Standard
Ako u izrazu nema zagrada, operacije istog prioriteta izvršavaju se redosledom
 koji je definisan njihovom asocijativnošću, tj.
 pridruživanjem.
 Tako, ako je pridruživanje “sleva”, onda se prvo izvršava operacija koja
 je prva gledano sa leve strane, a zatim redom ostale kako se kreće udesno.
 To znači da se izraz kao što je 
\family typewriter
a + b + c + d
\family default
 izvršava kao da je napisano 
\family typewriter
(((a + b) + c) + d)
\family default
 pošto se binarni operator sabiranja + pridružuje sleva.
 U slučajevima kada isti operator ima i unarni i binarni oblik, unarni oblik
 je uvek višeg prioriteta.
\end_layout

\begin_layout Standard
Prefiksni unarni operatori i operatori dodele pridružuju se zdesna ulevo.
 Svi ostali operatori pridružuju se sleva udesno.
 Na primer,
\family typewriter
 
\end_layout

\begin_layout Standard

\family typewriter
x - y - z
\family default
 znači 
\family typewriter
(x - y) - z
\family default
 jer se operator 
\family typewriter
-
\family default
 pridružuje sleva udesno, ali
\family typewriter
 
\end_layout

\begin_layout Standard

\family typewriter
x = y = z
\family default
 znači 
\family typewriter
x = (y = z)
\family default
 jer se operator 
\family typewriter
=
\family default
 pridružuje zdesna ulevo.
\end_layout

\begin_layout Standard
Prioritet operatora može se uvek promeniti pomoću zagrada.
 Pošto jezik C++ ima mnogo operatora, ponekad nije lako odrediti redosled
 izvršavanja operacija i zato zagrade treba koristiti i kada nisu neophodne
 jer poboljšavaju čitljivost kôda.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="30text%">
<column alignment="left" valignment="top" width="50text%">
<row endhead="true">
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 2.11
\series default
: Prioritet i asocijativnost operatora.
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operator
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
::
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Razrešenje dosega (scope)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
.
\end_layout

\begin_layout Plain Layout

\family typewriter
->
\end_layout

\begin_layout Plain Layout

\family typewriter
[]
\end_layout

\begin_layout Plain Layout

\family typewriter
()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Pristup podatku članu
\end_layout

\begin_layout Plain Layout
Dereferenciranje i pristup podatku članu
\end_layout

\begin_layout Plain Layout
Indeksiranje niza
\end_layout

\begin_layout Plain Layout
Poziv funkcije
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
++
\end_layout

\begin_layout Plain Layout

\family typewriter
--
\end_layout

\begin_layout Plain Layout

\family typewriter
typeid
\end_layout

\begin_layout Plain Layout

\family typewriter
const_cast
\end_layout

\begin_layout Plain Layout

\family typewriter
dynamic_cast
\end_layout

\begin_layout Plain Layout

\family typewriter
static_cast
\end_layout

\begin_layout Plain Layout

\family typewriter
reinterpret_cast
\end_layout

\begin_layout Plain Layout

\family typewriter
!
\end_layout

\begin_layout Plain Layout

\family typewriter
~
\end_layout

\begin_layout Plain Layout

\family typewriter
+
\family default
 (unarni)
\family typewriter
 -
\family default
 (unarni)
\end_layout

\begin_layout Plain Layout

\family typewriter
*
\family default
 (unarni)
\end_layout

\begin_layout Plain Layout

\family typewriter
&
\family default
 (unarni)
\end_layout

\begin_layout Plain Layout

\family typewriter
new
\end_layout

\begin_layout Plain Layout

\family typewriter
delete
\end_layout

\begin_layout Plain Layout

\family typewriter
sizeof
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Inkrementiranje
\end_layout

\begin_layout Plain Layout
Dekrementiranje
\end_layout

\begin_layout Plain Layout
Identifikacija tipa tokom izvršavanja
\end_layout

\begin_layout Plain Layout
Ukidanje nepromenljivosti tipa
\end_layout

\begin_layout Plain Layout
Konverzija tipa tokom izvršavanja
\end_layout

\begin_layout Plain Layout
Konverzija tipa tokom prevođenja
\end_layout

\begin_layout Plain Layout
Neproverena konverzija tipa
\end_layout

\begin_layout Plain Layout
Logička negacija
\end_layout

\begin_layout Plain Layout
Bitska negacija
\end_layout

\begin_layout Plain Layout
Promena znaka
\end_layout

\begin_layout Plain Layout
Dereferenciranje pokazivača
\end_layout

\begin_layout Plain Layout
Adresa promenljive
\end_layout

\begin_layout Plain Layout
Dinamička alokacija memorije
\end_layout

\begin_layout Plain Layout
Oslobađanje dinamičke memorije
\end_layout

\begin_layout Plain Layout
Veličina promenljive ili tipa
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
.*
\family default
 (unarni)
\end_layout

\begin_layout Plain Layout

\family typewriter
->*
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Pristup podatku članu
\end_layout

\begin_layout Plain Layout
Dereferenciranje i pristup podatku članu
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
*
\end_layout

\begin_layout Plain Layout
/
\end_layout

\begin_layout Plain Layout

\family typewriter
%
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Množenje
\end_layout

\begin_layout Plain Layout
Deljenje
\end_layout

\begin_layout Plain Layout
Modulo (ostatak deljenja)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
+ -
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sabiranje i oduzimanje
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
<< >>
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pomeranje za jedan bit ulevo ili udesno
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
< <= > >=
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Relacioni operatori
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
== !=
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operatori jednakosti
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bitsko i (AND)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bitsko isljučivo ili (XOR)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bitsko ili (OR)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&&
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logičko i
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
||
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logičko ili
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
:?
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Uslovni izraz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
= *= /= %= += -= 
\end_layout

\begin_layout Plain Layout

\family typewriter
&= ^= >= <<= >>=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Operatori dodele
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
,
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operator nabrajanja
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Konverzija tipova (cast)
\end_layout

\begin_layout Standard
Kada u izrazu dodele učestvuju operatori različitih tipova, vrednost desne
 strane (izraza) biće konvertovana
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka!konverzija
\end_layout

\end_inset

 u tip leve strane (tip promenljive).
 U slučaju izračunavanja, pravila za konverziju tipova su složenija.
 Izračunavanja u jeziku C++ mogu se izvoditi samo sa vrednostima istog tipa.
 Kada se napiše izraz u kome se nalaze promenljive ili konstante različitih
 tipova, za svaku operaciju kompajler mora da konvertuje tip jednog od operanada
 tako da odgovara onom drugom.
 To se zove 
\shape italic
konverzija tipa
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
konverzija tipova
\end_layout

\end_inset

 (casting).
 Na primer, ako želimo da saberemo vrednost tipa 
\family typewriter
double
\family default
 sa vrednošću tipa 
\family typewriter
int
\family default
, celobrojna vrednost se prvo konvertuje u tip 
\family typewriter
double
\family default
, a zatim se obavlja sabiranje.
 Naravno, sâma promenljiva koja sadrži vrednost koja se konvertuje ostaje
 neizmenjena.
 
\end_layout

\begin_layout Standard
Postoje pravila koja upravljaju izborom operanda koji će biti konvertovan
 u operacijama.
 Bilo koji izraz koji se izračunava raščlanjuje se u niz operacija između
 dva operanda.
 Na primer, izraz 2*3-4+5 se raščlanjuje na 2*3 što daje 6, 6-4 daje 2,
 i na kraju 2+5 daje 7.
 Zbog toga se pravila koja upravljaju konverzijom definišu samo na nivou
 para operanada.
 Za bilo koji par operanada različitih tipova proveravaju se sledeća pravila
 konverzije
\begin_inset Index idx
status open

\begin_layout Plain Layout
konverzija tipova! pravila
\end_layout

\end_inset

 i to u redosledu kojim su navedena:
\end_layout

\begin_layout Enumerate
Ako je bilo koji operand tipa 
\family typewriter
long double
\family default
, drugi se konvertuje u 
\family typewriter
long double
\family default
.
\end_layout

\begin_layout Enumerate
Ako je bilo koji operand tipa 
\family typewriter
double
\family default
, drugi se konvertuje u 
\family typewriter
double
\family default
.
\end_layout

\begin_layout Enumerate
Ako je bilo koji operand tipa 
\family typewriter
float
\family default
, drugi se konvertuje u 
\family typewriter
float
\family default
.
\end_layout

\begin_layout Enumerate
Bilo koji operand tipa 
\family typewriter
char
\family default
, 
\family typewriter
signed char
\family default
, 
\family typewriter
unsigned char
\family default
, 
\family typewriter
short
\family default
 ili 
\family typewriter
unsigned short
\family default
 konvertuje se u 
\family typewriter
int
\family default
.
\end_layout

\begin_layout Enumerate
Ako je bilo koji operand tipa 
\family typewriter
unsigned long
\family default
, drugi se konvertuje u 
\family typewriter
unsigned long
\family default
.
\end_layout

\begin_layout Enumerate
Ako je jedan operand tipa 
\family typewriter
long
\family default
 a drugi tipa 
\family typewriter
unsigned int
\family default
, oba operanda se konvertuju u tip 
\family typewriter
unsigned long
\family default
.
\end_layout

\begin_layout Enumerate
Ako je bilo koji operand tipa 
\family typewriter
long
\family default
, drugi se konvertuje u 
\family typewriter
long
\family default
.
\end_layout

\begin_layout Standard
Iako ova pravila na prvi pogled izgledaju složeno, princip je da se promenljiva
 čiji je opseg više ograničen uvek konvertuje u tip šireg opsega.
 Kada u izrazu učestvuju operandi različitih tipova, svi se konvertuju u
 tip najvećeg operanda (to je tzv.
 unapređivanje tipa).
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size small
int i = 3;
\end_layout

\begin_layout Standard

\family typewriter
\size small
float f = 0.5;
\end_layout

\begin_layout Standard

\family typewriter
\size small
cout << i * f << endl; //ispisuje 1.5
\end_layout

\begin_layout Standard
U ovom slučaju na ekranu se ispisuje 1.5 jer je tip 
\family typewriter
float
\family default
 složeniji od tipa 
\family typewriter
int
\family default
.
 Celobrojnu promenljivu 
\family typewriter
i
\family default
 kompajler pre prevođenja konvertuje u tip 
\family typewriter
float
\family default
 (prema pravilu broj 3), sprovodi množenje dva broja u pokretnom zarezu
 i daje rezultat koji je tipa 
\family typewriter
float
\family default
.
 Da smo rezultat množenja pre ispisa dodelili nekoj celobrojnoj promenljivoj,
 kao u sledećem primeru:
\end_layout

\begin_layout Standard

\family typewriter
\size small
i *=f;
\end_layout

\begin_layout Standard

\family typewriter
\size small
cout << i; //ispisuje 1
\end_layout

\begin_layout Standard
dobili bismo celobrojni rezultat, tj.
 1, jer se decimalni deo rezultata gubi prilikom dodele.
\end_layout

\begin_layout Standard
Problem konverzije najizraženiji je kod celobrojnog deljenja, što zbog nepažnje
 često prouzrokuje probleme.
\end_layout

\begin_layout Standard

\family typewriter
\size small
int brojilac = 1;
\end_layout

\begin_layout Standard

\family typewriter
\size small
int imenilac = 4;
\end_layout

\begin_layout Standard

\family typewriter
\size small
float razlomak = brojilac / imenilac;
\end_layout

\begin_layout Standard

\family typewriter
\size small
cout << razlomak << endl; //ispisuje 0
\end_layout

\begin_layout Standard
Iako smo rezultat deljenja dodelili promenljivoj tipa 
\family typewriter
float
\family default
, ta dodela tokom izvršavanja sledi tek nakon što je operacija deljenja
 dva cela broja završena.
 Pošto su i brojilac i imenilac celobrojne promenljive, izvodi se celobrojno
 deljenje koje kao rezultat daje 0.
 Da bi se izbegli ovakvi problemi, sve konstante u pokretnom zarezu treba
 pisati sa decimalnom tačkom:
\end_layout

\begin_layout Standard

\family typewriter
\size small
float diskutabilniRazlomak = 1 / 4; //daje 0
\end_layout

\begin_layout Standard

\family typewriter
\size small
floar razlomak = 1.
 / 4.; //daje 0.25
\end_layout

\begin_layout Standard
Izraz se može "primorati
\begin_inset Quotes erd
\end_inset

 da bude određenog tipa pomoću eksplicitne konverzije tipa
\begin_inset Index idx
status open

\begin_layout Plain Layout
tipovi podataka!eksplicitna konverzija
\end_layout

\end_inset

 (cast).
 Najopštiji oblik konverzije tipa je:
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
\size small
static_cast <tip> (izraz)
\end_layout

\begin_layout Standard
Ovde je 
\family typewriter
tip
\family default
 ciljni tip podataka u koji želimo da konvertujemo izraz.
 Eksplicitna konverzija tipa često se koristi kada je u pitanju nasleđeni
 kôd, a želimo da izbegnemo upozorenja prevodioca.
\end_layout

\begin_layout Standard

\family typewriter
\size small
float pi = 3.1415926;
\end_layout

\begin_layout Standard

\family typewriter
\size small
cout << 
\begin_inset Quotes sld
\end_inset

celi deo broja pi je: 
\begin_inset Quotes sld
\end_inset

 <<
\end_layout

\begin_layout Standard

\family typewriter
\size small
static_cast<int>(pi) << endl; //ispisuje 3
\end_layout

\begin_layout Standard

\family typewriter
\size small
//i ova sintaksa je podrzana, ali se ne preporucuje
\end_layout

\begin_layout Standard

\family typewriter
\size small
cout << 
\begin_inset Quotes sld
\end_inset

celi deo broja pi je: 
\begin_inset Quotes sld
\end_inset

 << (int) pi << endl;
\end_layout

\begin_layout Standard
Operatori konverzije su unarni i imaju isti prioritet kao i drugi unarni
 operatori.
\end_layout

\begin_layout Section
Simboličke konstante
\end_layout

\begin_layout Standard
U programima se često koriste promenljive čija vrednost tokom izvršavanja
 ne treba da se menja.
 To mogu biti matematičke konstante, ali i neki parametri poput maksimalne
 dužine niza i sl.
 Da bi se sprečilo slučajno menjanje takvih promenljivih, one se deklarišu
 kao konstantne
\begin_inset Index idx
status open

\begin_layout Plain Layout
simboličke konstante
\end_layout

\end_inset

 pomoću ključne reči
\family typewriter
 const
\family default
.
 Tada ih kompajler proverava i prijavljuje grešku prilikom pokušaja da se
 one u programu izmene.
\end_layout

\begin_layout Standard

\family typewriter
\size small
const double pi = 3.141592653;
\end_layout

\begin_layout Standard

\family typewriter
\size small
pi = 2 * pi; //greska!
\end_layout

\begin_layout Standard
Konstantna promenljiva prilikom definicije mora da bude i inicijalizovana:
\end_layout

\begin_layout Standard

\family typewriter
\size small
const int mojaKonstanta; //greska!
\end_layout

\begin_layout Standard
Drugi pristup definisanju konstantnih promenljivih nasleđen je iz jezika
 C i koristi preprocesorsku direktivu 
\family typewriter
#define
\family default
 (Dodatak B):
\end_layout

\begin_layout Standard

\family typewriter
\size small
#define PI 3.141592653
\end_layout

\begin_layout Standard
U ovom slučaju kompajler će pre prevođenja svako pojavljivanje konstante
 
\family typewriter
PI
\family default
 u programu zameniti odgovarajućom vrednošću.
 
\end_layout

\begin_layout Standard

\family typewriter
\size small
double precnik = 2;
\end_layout

\begin_layout Standard

\family typewriter
\size small
double obimKruga = precnik * PI;
\end_layout

\begin_layout Standard

\family typewriter
\size small
PI = 2 * PI; //greska!
\end_layout

\begin_layout Standard
Na prvi pogled nema razlike između ova dva pristupa, jer će i prilikom korišćenj
a preprocesorske direktive kompajler javiti grešku zato što se konstantna
 vrednost mora naći sa leve strane operacije dodele, što nije dozvoljeno.
 Međutim, ako se konstanta definiše pomoću direktive
\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorske direktive!
\family typewriter
define
\end_layout

\end_inset

 
\family typewriter
#define
\family default
, njen naziv neće postojati u simboličkoj tabeli koju generiše kompajler,
 pa neće biti vidljiv tokom debagovanja programa, što je veliki nedostatak.
 Zbog toga se preporučuje C++ stil definisanja konstantnih promenljivih
 pomoću ključne reči 
\family typewriter
const
\family default
.
\end_layout

\begin_layout Section*
Pitanja
\end_layout

\begin_layout Standard
1.
 Koja od sledećih imena su prihvatljiva u jeziku C++?
\end_layout

\begin_layout Standard
a) 
\family typewriter
danUNedelji
\end_layout

\begin_layout Standard
b) 
\family typewriter
3dGrafik
\end_layout

\begin_layout Standard
c) 
\family typewriter
_broj_zaposlenog
\end_layout

\begin_layout Standard
d) 
\family typewriter
Jun1997
\end_layout

\begin_layout Standard
e) 
\family typewriter
Mesavina#3
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
2.
 Ispravno deklarisane promenljive su:
\end_layout

\begin_layout Standard
a) int ime prezime;
\end_layout

\begin_layout Standard
b) int ime_prezime;
\end_layout

\begin_layout Standard
c) int ImePrezime;
\end_layout

\begin_layout Standard
d) int 5deset; 
\end_layout

\begin_layout Standard
e) int prezime_25;
\end_layout

\begin_layout Standard
f) int _ime; 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
3.
 U kojim slučajevima su ispravno napisane naredbe za deklarisanje promenljivih:
\end_layout

\begin_layout Standard
a) 
\family typewriter
int duzina; int sirina; 
\end_layout

\begin_layout Standard
b) 
\family typewriter
int duzina, sirina; 
\end_layout

\begin_layout Standard
c) 
\family typewriter
int duzina; sirina; 
\end_layout

\begin_layout Standard
d) 
\family typewriter
int duzina, int sirina; 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
4.
 Reči main i Main su istog značenja u jeziku C++ ? 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
5.
 Definicija promenljive: 
\end_layout

\begin_layout Standard
a) rezerviše prostor u memoriji za promenljivu
\end_layout

\begin_layout Standard
b) inicijalizuje promenljivu
\end_layout

\begin_layout Standard
c) određuje samo tip promenljive 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
6.
 Tip podataka definiše: 
\end_layout

\begin_layout Standard
a) skup mogućih vrednosti tipa
\end_layout

\begin_layout Standard
b) skup različitih podataka tipa
\end_layout

\begin_layout Standard
c) skup dozvoljenih operacija nad vrednostima tipa 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
7.
 Celobrojni tip vrednosti možemo predstaviti sa:
\end_layout

\begin_layout Standard
a) 
\family typewriter
int
\end_layout

\begin_layout Standard
b) 
\family typewriter
short
\end_layout

\begin_layout Standard
c) 
\family typewriter
char
\end_layout

\begin_layout Standard
d) 
\family typewriter
long
\end_layout

\begin_layout Standard
e) 
\family typewriter
unsigned
\end_layout

\begin_layout Standard
f) 
\family typewriter
sve od navedenog
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
8.
 Promenljive čija je vrednost inicijalizovana su:
\end_layout

\begin_layout Standard
a) 
\family typewriter
int a;
\family default
 
\end_layout

\begin_layout Standard
b) 
\family typewriter
int b = 2;
\family default
 
\end_layout

\begin_layout Standard
c) 
\family typewriter
float d; 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
9.
 Promenljiva mora da bude deklarisana pre nego što se upotrebi.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
10.
 Promenljiva može da bude deklarisana bilo gde u C++ programu.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) netačno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
11.
 Nazivi promenljivih mogu da počinju brojem.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) netačno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
12.
 Ako promenljiva treba da sadrži vrednosti od 32 do 6000, koji tip podataka
 bi bio najpogodniji?
\end_layout

\begin_layout Standard
a) 
\family typewriter
short int
\end_layout

\begin_layout Standard
b) 
\family typewriter
int
\end_layout

\begin_layout Standard
c) 
\family typewriter
long
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
13.
 Tip svake promenljive u jeziku C++ mora biti poznat tokom kompajliranja.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
14.
 Tip 
\family typewriter
char
\family default
 se može koristiti i kao 
\begin_inset Quotes eld
\end_inset

mali
\begin_inset Quotes erd
\end_inset

 
\family typewriter
int
\family default
.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
15.
 Tip 
\family typewriter
float
\family default
 je precizniji od tipa 
\family typewriter
double
\family default
.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
16.
 Koje vrednosti može da ima promenljiva tipa 
\family typewriter
bool
\family default
?
\end_layout

\begin_layout Standard
a) true i false
\end_layout

\begin_layout Standard
b) 0 i 1
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
17.
 Svaka vrednost različita od nule tumači se kao 
\family typewriter
true
\family default
.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
18.
 Sledeći podaci:
\end_layout

\begin_layout Standard

\family typewriter
72
\end_layout

\begin_layout Standard

\family typewriter
'A'
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Quotes eld
\end_inset

Hello world
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
2.87
\end_layout

\begin_layout Standard
su primeri:
\end_layout

\begin_layout Standard
a) promenljivih
\end_layout

\begin_layout Standard
b) literala ili konstanti
\end_layout

\begin_layout Standard
c) stringova
\end_layout

\begin_layout Standard
d) ničega od navedenog
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
19.
 Pravilno deklarisane i inicijalizovane promenljive su: 
\end_layout

\begin_layout Standard
a) 
\family typewriter
Int a = 5;
\end_layout

\begin_layout Standard
b) 
\family typewriter
double b = ”abc”; 
\end_layout

\begin_layout Standard
c) 
\family typewriter
int f = 6, t = 5;
\family default
 
\end_layout

\begin_layout Standard
d) 
\family typewriter
char c = 18.25;
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
20.
 Koje su od sledećih službene reči u jeziku C++: 
\end_layout

\begin_layout Standard
a) public
\end_layout

\begin_layout Standard
b) static 
\end_layout

\begin_layout Standard
c) main
\end_layout

\begin_layout Standard
d) class 
\end_layout

\begin_layout Standard
e) tacno 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
21.
 Koji od sledećih tipova zahteva najmanje memorije za predstavljanje celih
 brojeva:
\end_layout

\begin_layout Standard
a) 
\family typewriter
int
\end_layout

\begin_layout Standard
b) 
\family typewriter
short
\end_layout

\begin_layout Standard
c) 
\family typewriter
char
\end_layout

\begin_layout Standard
d) 
\family typewriter
float
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
22.
 Sledeća operacija dodele je važeća: 
\family typewriter
72 = iznos
\family default
.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) netačno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
23.
 Koji tip kompajler dodeljuje literalu 
\family typewriter
12.2
\family default
? 
\end_layout

\begin_layout Standard
a) 
\family typewriter
float
\end_layout

\begin_layout Standard
b) 
\family typewriter
double
\end_layout

\begin_layout Standard
c) 
\family typewriter
int
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
24.
 String konstanta se piše pod navodnicima.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
25.
 Heksadecimalne konstante počinju sa: 
\end_layout

\begin_layout Standard
a) 
\family typewriter
0
\end_layout

\begin_layout Standard
b) 
\family typewriter
0x
\end_layout

\begin_layout Standard
c) 
\family typewriter
x
\end_layout

\begin_layout Standard
d) 
\family typewriter
16
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
26.
 Koje od sledećih nisu validne naredbe dodele?
\end_layout

\begin_layout Standard
a) 
\family typewriter
ukupno = 9;
\end_layout

\begin_layout Standard
b) 
\family typewriter
72 = iznos;
\end_layout

\begin_layout Standard
c) 
\family typewriter
zarada = 12000;
\end_layout

\begin_layout Standard
d) 
\family typewriter
slovo := 'D';
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
27.
 Kojom se od sledećih naredbi ispravno dodeljuje vrednost 
\family typewriter
17
\family default
 promenljivoj 
\family typewriter
x
\family default
?
\end_layout

\begin_layout Standard
a) 
\family typewriter
x = 17;
\end_layout

\begin_layout Standard
b) 
\family typewriter
x := 17;
\end_layout

\begin_layout Standard
c) 
\family typewriter
x == 17;
\end_layout

\begin_layout Standard
d) 
\family typewriter
17 = x;
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
28.
 Operator logičke negacije (
\family typewriter
!
\family default
) je:
\end_layout

\begin_layout Standard
a) unarni
\end_layout

\begin_layout Standard
b) binarni
\end_layout

\begin_layout Standard
c) ternarni
\end_layout

\begin_layout Standard
d) ništa od navedenog
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
29.
 Koja od sledećih je string konstanta?
\end_layout

\begin_layout Standard
a) 
\family typewriter

\begin_inset Quotes eld
\end_inset

H
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
b) 
\family typewriter
'H'
\end_layout

\begin_layout Standard
c) 
\family typewriter
H
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
30.
 Koja od sledećih je znakovna konstanta?
\end_layout

\begin_layout Standard
a) 
\family typewriter

\begin_inset Quotes eld
\end_inset

H
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
b) 
\family typewriter
'H'
\end_layout

\begin_layout Standard
c) 
\family typewriter
H
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
31.
 Pravilno prihvatanje ulaza sa konzole u C++ je: 
\end_layout

\begin_layout Standard
a) 
\family typewriter
cout<<
\end_layout

\begin_layout Standard
b) 
\family typewriter
cout>>
\end_layout

\begin_layout Standard
c) 
\family typewriter
cin>>
\end_layout

\begin_layout Standard
d) 
\family typewriter
cin<< 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
32.
 Ispravno napisana naredba za izlaz na konzolu je: 
\end_layout

\begin_layout Standard
a) 
\family typewriter
cout>>
\end_layout

\begin_layout Standard
b) 
\family typewriter
cout<<
\end_layout

\begin_layout Standard
c) 
\family typewriter
cin<<
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
33.
 Deklarisana je i inicijalizovana promenljiva 
\family typewriter
int a = 1;
\family default
 posle naredbe 
\family typewriter
a++;
\family default
 njena vrednost je: 
\end_layout

\begin_layout Standard
a) 3
\end_layout

\begin_layout Standard
b) 1
\end_layout

\begin_layout Standard
c) 2
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
34.
 Deklarisana je i inicijalizovana promenljiva 
\family typewriter
int a = 10;
\family default
 posle naredbe 
\family typewriter
a += 3;
\family default
 njena vrednost je: 
\end_layout

\begin_layout Standard
a) 7
\end_layout

\begin_layout Standard
b) 10
\end_layout

\begin_layout Standard
c) 13
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
35.
 Redosled izvršavanja operatora je:
\end_layout

\begin_layout Standard
a) unapred definisan
\end_layout

\begin_layout Standard
b) nije bitan
\end_layout

\begin_layout Standard
c) može se menjati zagradama
\end_layout

\begin_layout Standard
d) sve navedeno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
36.
 Izraz 
\family typewriter
a = b
\family default
 je: 
\end_layout

\begin_layout Standard
a) dodela vrednosti promenljive 
\family typewriter
b
\family default
 promenljivoj 
\family typewriter
a
\end_layout

\begin_layout Standard
b) poređenje vrednosti promenljivih 
\family typewriter
a
\family default
 i 
\family typewriter
b
\end_layout

\begin_layout Standard
c) dodela vrednosti promenljive 
\family typewriter
a
\family default
 promenljivoj 
\family typewriter
b
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
37.
 Izraz 
\family typewriter
x++
\family default
 može se napisati i kao:
\end_layout

\begin_layout Standard
a) 
\family typewriter
x = x + 1
\end_layout

\begin_layout Standard
b) 
\family typewriter
x = x - 1
\end_layout

\begin_layout Standard
c) 
\family typewriter
x == x
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
38.
 Kolika je vrednost promenljive 
\family typewriter
j
\family default
 nakon izvršavanja sledećeg koda? 
\end_layout

\begin_layout Standard

\family typewriter
int i, j; 
\end_layout

\begin_layout Standard

\family typewriter
i=5; 
\end_layout

\begin_layout Standard

\family typewriter
j=5+--i;
\end_layout

\begin_layout Standard
a) 10
\end_layout

\begin_layout Standard
b) 9
\end_layout

\begin_layout Standard
c) 11
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
39.
 Šta radi sledeći deo kôda? 
\end_layout

\begin_layout Standard

\family typewriter
int i=3, j=5,temp; 
\end_layout

\begin_layout Standard

\family typewriter
temp=i; 
\end_layout

\begin_layout Standard

\family typewriter
i=j; 
\end_layout

\begin_layout Standard

\family typewriter
j=temp;
\end_layout

\begin_layout Standard
a) Vrednost promenljive 
\family typewriter
j
\family default
 dodeljuje promenljivoj 
\family typewriter
i
\family default
 
\end_layout

\begin_layout Standard
b) Vrednost promenljive 
\family typewriter
i
\family default
 dodeljuje promenljivoj 
\family typewriter
j
\end_layout

\begin_layout Standard
c) Međusobno zamenjuje vrednosti promenljivama 
\family typewriter
i
\family default
 i 
\family typewriter
j
\family default
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
40.
 
\family typewriter
%
\family default
 je operator: 
\end_layout

\begin_layout Standard
a) celobrojnog deljenja
\end_layout

\begin_layout Standard
b) ostatka celobrojnog deljenja
\end_layout

\begin_layout Standard
c) izračunavanja procenta
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
41.
 Izraz 
\family typewriter
x=x+12
\family default
 može se napisati i kao 
\family typewriter
x+=12
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
42.
 Koji od sledećih operatora su logički?
\end_layout

\begin_layout Standard
a) 
\family typewriter
&&
\end_layout

\begin_layout Standard
b) 
\family typewriter
##
\end_layout

\begin_layout Standard
c) 
\family typewriter
||
\end_layout

\begin_layout Standard
d) 
\family typewriter
//
\end_layout

\begin_layout Standard
e) 
\family typewriter
!
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
43.
 Ako se na promenljivu 
\family typewriter
c
\family default
 primeni operator inkrementiranja u prefiksnoj formi, onda se to piše kao:
 
\end_layout

\begin_layout Standard
a) 
\family typewriter
c++
\end_layout

\begin_layout Standard
b) 
\family typewriter
++c
\end_layout

\begin_layout Standard
c) 
\family typewriter
c = c+1
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
44.
 Operator 
\family typewriter
sizeof
\family default
: 
\end_layout

\begin_layout Standard
a) vraća veličinu tipa u bitovima 
\end_layout

\begin_layout Standard
b) vraća veličinu tipa u bajtovima
\end_layout

\begin_layout Standard
c) služi za preimenovanje tipova 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
45.
 Operator 
\family typewriter
typedef
\family default
:
\end_layout

\begin_layout Standard
a) vraća veličinu tipa u bitovima 
\end_layout

\begin_layout Standard
b) vraća veličinu tipa u bajtovima
\end_layout

\begin_layout Standard
c) služi za preimenovanje tipova 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
46.
 Kolika je vrednost promenljive 
\family typewriter
broj4
\family default
 nakon sledećih naredbi: 
\end_layout

\begin_layout Standard

\family typewriter
int broj1=0, broj2=0, broj3=0, broj4=0; 
\end_layout

\begin_layout Standard

\family typewriter
broj4 = (broj1=10, broj2=20, broj3=30); 
\end_layout

\begin_layout Standard
a) 10
\end_layout

\begin_layout Standard
b) 20
\end_layout

\begin_layout Standard
c) 30
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
47.
 Šta će ispisati sledeći kôd?
\end_layout

\begin_layout Standard

\family typewriter
int a = 10;
\end_layout

\begin_layout Standard

\family typewriter
float b = 20.;
\end_layout

\begin_layout Standard

\family typewriter
cout << a / b;
\end_layout

\begin_layout Standard
a) 0
\end_layout

\begin_layout Standard
b) 0.5
\end_layout

\begin_layout Chapter
Naredbe za kontrolu toka programa
\end_layout

\begin_layout Standard
Izvršavanje iole korisnih programa nikada nije pravolinijsko, več se često
 javlja potreba da se delovi kôda ponavljaju, ili da se u zavisnosti od
 nekog uslova izvršava određeni deo kôda, a da se drugi deo preskače.
 Grananje toka programa i ponavljanje delova kôda omogućuju posebne naredbe
 koje je C++ preuzeo iz jezika C.
\end_layout

\begin_layout Section
Blokovi naredbi
\end_layout

\begin_layout Standard
Delovi programa koji se uslovno izvode ili čije se izvršavanje ponavlja
 grupišu se u blokove naredbi
\begin_inset Index idx
status open

\begin_layout Plain Layout
blokovi naredbi
\end_layout

\end_inset

.
 Nekoliko naredbi se grupiše unutar vitičastih zagrada, i postaje blok naredbi
 ili složena naredba.
 Primer za to su naredbe funkcije 
\family typewriter
main()
\family default
, koje se uvek nalaze između para otvorenih i zatvorenih zagrada.
 Blok naredbi se može posmatrati i kao jedna složena naredba; gde god je
 u jeziku C++ dozvoljeno pisanje naredbe, može se napisati i blok naredbi
 omeđen zagradama.
 Važno svojstvo blokova jeste to da su promenljive koje su definisane unutar
 bloka vidljive samo u njemu.
 Zbog toga će se program:
\end_layout

\begin_layout LyX-Code

\size small
int main() { 	
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
{ 		
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int a = 1; 		
\end_layout

\begin_layout LyX-Code

\size small
cout << a << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 	
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
kompajlirati bez grešaka, ali ako se deklaracija promenljive izmesti izvan
 bloka, kompajler će prijaviti grešku:
\end_layout

\begin_layout LyX-Code

\size small
int main() { 	
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
{ 		
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int a = 1; 		
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
cout << a << endl; //greska! a vise ne postoji	
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Promenljive koje su deklarisane unutar bloka zovu se 
\shape italic
lokalne promenljive
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
lokalne promenljive
\end_layout

\end_inset

 za taj blok.
 Ograničenje oblasti važenja promenljive zove se 
\shape italic
doseg
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
doseg
\end_layout

\end_inset

 (scope) i omogućuje da se unutar blokova deklarišu promenljive sa istim
 imenom koje je već upotrebljeno izvan bloka.
 Lokalna promenljiva će unutar bloka zakloniti promenljivu istog imena koja
 je već deklarisana izvan bloka:
\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int a = 5;	
\end_layout

\begin_layout LyX-Code

\size small
{ 		
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int a = 1;
\end_layout

\begin_layout LyX-Code

\size small
cout << a << endl; //ispisuje 1		
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
cout << a << endl; //ispisuje 5	
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Opseg važnosti (doseg) promenljivih kasnije ćemo detaljnije proučiti.
 Za sada, zapamtimo i da ako se blok u naredbama za kontrolu toka sastoji
 samo od jedne naredbe, onda se vitičaste zagrade mogu i izostaviti.
\end_layout

\begin_layout Section
Naredba if
\end_layout

\begin_layout Standard
Kompletan oblik naredbe
\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!if
\end_layout

\end_inset


\family typewriter
\size footnotesize
 
\size default
if
\begin_inset Index idx
status open

\begin_layout Plain Layout
if
\end_layout

\end_inset


\family default
 je:
\end_layout

\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
if (izraz) 
\end_layout

\begin_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
naredba;
\end_layout

\end_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
else 
\end_layout

\begin_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
naredba;
\end_layout

\end_deeper
\begin_layout Standard
Deo 
\family typewriter
else
\family default
 u naredbi nije obavezan.
 Iza ključnih reči 
\family typewriter
if
\family default
 i 
\family typewriter
else
\family default
 mogu se nalaziti i blokovi naredbi, koji se smeštaju unutar vitičastih
 zagrada.
\end_layout

\begin_layout Standard
Ako je izraz tačan, izvršiće se naredbe iza
\family typewriter
 if
\family default
; u suprotnom, izvršiće se blok iza 
\family typewriter
else
\family default
, ako postoji.
 Nikako se ne može desiti da budu izvršene i naredbe iza 
\family typewriter
if
\family default
 i naredbe iza 
\family typewriter
else
\begin_inset Index idx
status open

\begin_layout Plain Layout
else
\end_layout

\end_inset


\family default
.
 Sledeći program koristi naredbu 
\family typewriter
if else
\family default
 da bi odredio neke osobine celog broja koji se unosi sa tastature:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//grananje naredbom if else
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int a; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Unesite ceo broj: "; 
\end_layout

\begin_layout LyX-Code

\size small
cin >> a; 
\end_layout

\begin_layout LyX-Code

\size small
if(a<0) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "uneti broj je negativan" << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
if(a%2) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "uneti broj je neparan"; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "uneti broj je paran"; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
unesite ceo broj: -5 
\end_layout

\begin_layout Standard

\series bold
\size small
uneti broj je negativan
\end_layout

\begin_layout Standard

\series bold
\size small
uneti broj je neparan
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Uslovni izraz koji kontroliše 
\family typewriter
if
\family default
 može da bude bilo koji važeći C++ izraz koji kao rezultat daje logičke
 vrednosti 
\family typewriter
true
\family default
 ili 
\family typewriter
false
\family default
, što početnike ponekad zna da zbuni.
 U izrazu ne moraju da se koriste isključivo relacioni i logički operatori,
 ili operandi tipa 
\family typewriter
bool
\family default
.
 Kao što smo već pominjali, vrednost 0 se automatski konvertuje u 
\family typewriter
false
\family default
, a sve vrednosti različite od nule se konvertuju u 
\family typewriter
true
\family default
.
 Zbog toga bilo koji izraz čiji je rezultat 0 ili neka vrednost različita
 od nule može da se koristi za kontrolisanje naredbe 
\family typewriter
if
\family default
.
 Kao primer, proučimo program koji učitava dva cela broja sa tastature i
 prikazuje rezultat celobrojnog deljenja.
 Da bi se izbegla greška deljenja nulom, koristi se naredba 
\family typewriter
if
\family default
 kojom se upravlja pomoću drugog unetog broja (delioca): 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int a, b; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Unesite deljenik: "; 
\end_layout

\begin_layout LyX-Code

\size small
cin >> a; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Unesite delilac: "; 
\end_layout

\begin_layout LyX-Code

\size small
cin >> b; 
\end_layout

\begin_layout LyX-Code

\size small
if(b) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Rezultat je " << a/b; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Deljenje nulom nije dozvoljeno"; 
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\paragraph_spacing single
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite deljenik: 50 
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite delilac: 10
\end_layout

\begin_layout Standard

\series bold
\size small
Rezultat je: 10
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite deljenik: 50
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite delilac: 0
\end_layout

\begin_layout Standard

\series bold
\size small
Deljenje nulom nije dozvoljeno.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Uočite da se unesena vrednost delioca
\family typewriter
\size footnotesize
 
\size default
b
\family default
 koristi kao uslov u 
\family typewriter
if
\family default
 grananju.
 Ako je 
\family typewriter
b
\family default
 nula, onda uslov koji kontroliše grananje ima vrednost 
\family typewriter
false
\family default
 i izvršava se 
\family typewriter
else
\family default
 deo.
 U suprotnom, ako 
\family typewriter
b
\family default
 nije nula, izvršava se deljenje (deo 
\family typewriter
if
\family default
).
 Nije neophodno da se uslov piše kao 
\family typewriter
if(b == 0)
\family default
.
\end_layout

\begin_layout Subsection
Ugnježđene naredbe if 
\end_layout

\begin_layout Standard
Ugnježđena naredba
\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!ugnježđeni if
\end_layout

\end_inset

 
\family typewriter
if
\family default
 je naredba 
\family typewriter
if
\family default
 koja se nalazi unutar druge naredbe 
\family typewriter
if
\family default
 ili 
\family typewriter
else
\family default
.
 Ugnježđivanje 
\family typewriter
if
\family default
 naredbi veoma se često koristi u programiranju, a najvažnije je zapamtiti
 da se deo 
\family typewriter
else
\family default
 uvek odnosi na najbližu 
\family typewriter
if
\family default
 naredbu unutar istog bloka u kome se nalazi 
\family typewriter
else
\family default
, a koja već nije povezana sa nekom 
\family typewriter
else
\family default
 naredbom.
 Evo primera koji to objašnjava: 
\end_layout

\begin_layout LyX-Code

\size small
if(i) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
if(j) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
rezultat = 1;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
if(k)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
rezultat = 2;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
//ovaj else odnosi se na if(k)
\end_layout

\begin_layout LyX-Code

\size small
else 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
rezultat = 3;
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
//ovaj else odnosi se na if(i)
\end_layout

\begin_layout LyX-Code

\size small
else
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
rezultat = 4;
\end_layout

\end_deeper
\begin_layout Subsection
If else if lestvica 
\end_layout

\begin_layout Standard
Česta konstrukcija u programiranju zasnovana na ugnježđenim naredbama 
\family typewriter
if
\family default
 jeste tzv.
 if-else-if lestvica
\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!if-else-if lestvica
\end_layout

\end_inset

, koja izgleda ovako: 
\end_layout

\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
if (uslov) 
\end_layout

\begin_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
naredba;
\end_layout

\end_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
else if (uslov)
\end_layout

\begin_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
naredba;
\end_layout

\end_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
else if (uslov)
\end_layout

\begin_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
naredba;
\end_layout

\end_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
...
\end_layout

\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
else
\end_layout

\begin_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
naredba;
\end_layout

\end_deeper
\begin_layout Standard
Uslovni izrazi proveravaju se s vrha naniže; čim se naiđe na uslov koji
 ima vrednost 
\family typewriter
true
\family default
, izvršava se naredba povezana sa njim, a ostatak lestvice se preskače.
 Ako nijedan uslov nema vrednost 
\family typewriter
true
\family default
, izvršava se poslednja 
\family typewriter
else
\family default
 naredba.
 Poslednji 
\family typewriter
else
\family default
 ima ulogu podrazumevanog (default) uslova, jer se izvršava ako nijedan
 izraz nije tačan.
 Ako poslednji 
\family typewriter
else
\family default
 ne postoji, a svi ostali uslovi imaju vrednost 
\family typewriter
false
\family default
, ne dešava se ništa.
 Primer programa koji računa diskriminantu kvadratne jednačine ilustruje
 korišćenje 
\family typewriter
if else
\family default
 
\family typewriter
if
\family default
 lestvice:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
float a, b, c; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Unesite koeficijente kvadratne jednacine" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cin >> a >> b >> c; 
\end_layout

\begin_layout LyX-Code

\size small
float diskriminanta = b * b - 4 * a * c; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Kvadratna jednacina ima "; 
\end_layout

\begin_layout LyX-Code

\size small
if(diskriminanta > 0) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "dva realna korena"; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else if(diskriminanta < 0) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "dva kompleksna korena"; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "dvostruki realan koren"; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite koeficijente kvadratne jednacine: 
\end_layout

\begin_layout Standard

\series bold
\size small
1
\end_layout

\begin_layout Standard

\series bold
\size small
3
\end_layout

\begin_layout Standard

\series bold
\size small
5
\end_layout

\begin_layout Standard

\series bold
\size small
Kvadratna jednacina ima dva kompleksna korena.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsection
Uslovni izraz (operator ? :)
\end_layout

\begin_layout Standard
Iako ne spada u naredbe za kontrolu toka programa, uslovni operator
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!?:
\end_layout

\end_inset

 je sličan naredbi if else pa ćemo ga ovde ukratko objasniti.
 Sintaksa uslovnog operatora je:
\end_layout

\begin_layout Standard
\align left

\family typewriter
\shape slanted
\size small
uslov ? izraz1 : izraz2;
\end_layout

\begin_layout Standard
Ovaj operator zove se ternarni, jer zahteva tri operanda.
 Ako 
\family typewriter
uslov
\family default
 ima vrednost 
\family typewriter
true
\family default
, izvršava se 
\family typewriter
izraz1
\family default
, a u suprotnom, izvršava se 
\family typewriter
izraz2
\family default
.
 U sledećem primeru:
\end_layout

\begin_layout Standard

\family typewriter
\size small
x = (x > 0) ? x : -x; //apsolutna vrednost x
\end_layout

\begin_layout Standard
izračunava se apsolutna vrednost promenljive x.
 Ako je x pozitivan, izračunava se prvi izraz, tj.
 x ostaje nepromenjen.
 Ako je x negativan, izvršava se drugi izraz i menja se znak.
 Uslovni operator treba koristiti samo za vrlo jednostavna ispitivanja,
 kada ceo kôd staje u jedan red, jer u suprotnom kôd postaje nečitljiv.
\end_layout

\begin_layout Section
Naredba switch 
\end_layout

\begin_layout Standard
Druga naredba koja u jeziku C++ omogućuje izbor jeste naredba
\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!switch
\end_layout

\end_inset

 
\family typewriter
switch
\begin_inset Index idx
status open

\begin_layout Plain Layout
switch
\end_layout

\end_inset


\family default
.
 Ona omogućuje višestruko grananje, odnosno izbor između nekoliko mogućnosti.
 Iako se isti efekat može postići i nizom ugnježđenih naredbi 
\family typewriter
if
\family default
, u mnogim slučajevima korišćenje naredbe 
\family typewriter
switch
\family default
 je efikasnije.
 Opšti oblik naredbe je sledeći:
\end_layout

\begin_layout LyX-Code
\align left

\shape slanted
\size small
switch (izraz) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align left

\shape slanted
\size small
case (konstanta1):
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align left

\shape slanted
\size small
niz naredbi
\end_layout

\begin_layout LyX-Code
\align left

\shape slanted
\size small
break;
\end_layout

\end_deeper
\begin_layout LyX-Code
\align left

\shape slanted
\size small
case (konstanta2):
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align left

\shape slanted
\size small
niz naredbi
\end_layout

\begin_layout LyX-Code
\align left

\shape slanted
\size small
break;
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code
\align left

\shape slanted
\size small
...
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align left

\shape slanted
\size small
default:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align left

\shape slanted
\size small
niz naredbi
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code
\align left

\shape slanted
\size small
}
\end_layout

\begin_layout Standard
Vrednost izraza, koji mora biti celobrojan, redom se upoređuje sa nizom
 konstanti; kada se utvrdi jednakost, izvršava se naredba (ili blok naredbi)
 pridružena ispunjenom uslovu.
 Često je izraz koji kontroliše naredbu 
\family typewriter
switch
\family default
 neka celobrojna promenljiva.
 Konstante u delu 
\family typewriter
case
\family default
 moraju da budu celobrojne.
 Mogu da postoje i 
\family typewriter
case
\family default
 delovi bez pratećeg niza naredbi.
 Niz naredbi iza grananja 
\family typewriter
default
\begin_inset Index idx
status open

\begin_layout Plain Layout
default
\end_layout

\end_inset


\family default
 izvršava se ako nijedan prethodni uslov nije ispunjen.
 Blok 
\family typewriter
default 
\family default
može se staviti bilo gde u naredbi 
\family typewriter
switch
\family default
, ali se zbog preglednosti po pravilu stavlja na kraj.
 Takođe, on nije obavezan; ako ne postoji, ne dešava se ništa.
 
\end_layout

\begin_layout Standard
Naredba 
\family typewriter
switch
\family default
 razlikuje se od grananja 
\family typewriter
if
\family default
 po tome što može da proverava samo jednakost (tj.
 da li postoji poklapanje vrednosti izraza i konstanti u delovima 
\family typewriter
case
\family default
), dok u naredbi 
\family typewriter
if
\family default
 uslovni izraz može da bude bilo kog tipa.
 Sve konstante u delovima 
\family typewriter
case
\family default
 moraju da budu različite (naravno, ako se naredbe 
\family typewriter
switch
\family default
 ugnježđuju, mogu imati iste vrednosti konstanti, ali je to vrlo redak slučaj).
 Naredba 
\family typewriter
switch
\family default
 je obično efikasnija od ugnježđenih naredbi 
\family typewriter
if
\family default
.
 Naredba
\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!break
\end_layout

\end_inset

 
\family typewriter
break
\family default
 koja sledi iza niza naredbi pridruženih grananju case tehnički nije obavezna,
 ali se skoro uvek koristi.
 Kada se završi izvršavanje niza naredbi pridruženog grananju 
\family typewriter
case
\family default
, naredba 
\family typewriter
break
\family default
 prouzrokuje izlazak iz naredbe 
\family typewriter
switch
\family default
 i nastavak izvršavanja programa iza nje.
 Kada na kraju grananja ne bi bilo naredbe 
\family typewriter
break
\begin_inset Index idx
status open

\begin_layout Plain Layout
break
\end_layout

\end_inset


\family default
, nastavilo bi se izvršavanje svih preostalih 
\family typewriter
case
\family default
 grananja do kraja naredbe 
\family typewriter
switch
\family default
, a to obično nije ono što želimo.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int dan; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Koji je danas dan po redu u nedelji? "; 
\end_layout

\begin_layout LyX-Code

\size small
cin >> dan; 
\end_layout

\begin_layout LyX-Code

\size small
switch(dan) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
case(1): 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "ponedeljak" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
break; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
case(2): 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "utorak" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
break; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
case(3): 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "sreda" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
break; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
case(4): 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "cetvrtak" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
break; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
case(5): 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "petak" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
break; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
case(6): 
\end_layout

\begin_layout LyX-Code

\size small
case(7): 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "vikend!" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
break; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
default: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "nema toliko dana u nedelji!" << endl; 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
\paragraph_spacing single
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Koji je danas dan po redu u nedelji? 6 
\end_layout

\begin_layout Standard

\series bold
\size small
vikend!
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Section
Petlja for 
\end_layout

\begin_layout Standard
Često je u programima potrebno ponavljati delove kôda.
 Ako je broj ponavljanja unapred poznat, najpogodnije je koristiti petlju
\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!for
\end_layout

\end_inset

 
\family typewriter
for
\begin_inset Index idx
status open

\begin_layout Plain Layout
for
\end_layout

\end_inset


\family default
 čija je opšta sintaksa: 
\end_layout

\begin_layout Standard
\align left

\family typewriter
\shape slanted
\size small
for(inicijalizacija; izraz; inkrement) blok naredbi;
\end_layout

\begin_layout Standard
Inicijalizacija je obično naredba dodele kojom se postavlja početna vrednost
 promenljive koja kontroliše petlju, tj.
 koja se ponaša kao brojač.
 Izraz je uslovni izraz koji određuje da li će petlja biti ponovljena, a
 inkrement definiše korak za koji se kontrolna promenljiva petlje menja
 u svakoj iteraciji (ponavljanju).
 Ova tri važna dela for petlje moraju biti razdvojena tačkom-zarezom.
 Petlja for nastaviće da se izvršava sve dok je rezultat kontrolnog izraza
 
\family typewriter
true
\family default
.
 Kada taj uslov postane 
\family typewriter
false
\family default
, izvršavanje petlje će biti prekinuto i nastaviće se od prve naredbe iza
 bloka naredbi.
 
\end_layout

\begin_layout Standard
Često je promenljiva koja kontroliše 
\family typewriter
for
\family default
 petlju potrebna samo unutar petlje.
 Zbog toga se ona najčešće i deklariše u delu 
\family typewriter
for
\family default
 petlje koji obavlja inicijalizaciju.
 Ipak, treba imati na umu da je tada doseg (scope) kontrolne promenljive
 samo 
\family typewriter
for
\family default
 petlja, te da se ona izvan nje ne vidi.
 
\end_layout

\begin_layout Standard

\family typewriter
\size small
//deklaracija kontrolne promenljive
\end_layout

\begin_layout Standard

\family typewriter
\size small
//u inicijalizacionom delu for petlje
\end_layout

\begin_layout Standard

\family typewriter
\size small
for(int i=0; i<10; i++)
\end_layout

\begin_layout Standard
Kao primer proučimo program koji koristi petlju for za ispis kvadratnog
 korena brojeva između 1 i 99.
 
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <cmath> 
\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int broj; 
\end_layout

\begin_layout LyX-Code

\size small
double kv_koren; 
\end_layout

\begin_layout LyX-Code

\size small
for(broj=1; broj<100; broj++) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
kv_koren = sqrt(static_cast<double>(broj)); 
\end_layout

\begin_layout LyX-Code

\size small
cout << kv_koren << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
U ovom primeru, kontrolna promenljiva petlje zove se 
\family typewriter
broj
\family default
.
 Ovaj program koristi standardnu funkciju 
\family typewriter
sqrt()
\family default
 za izračunavanje kvadratnog korena.
 Pošto argument ove funkcije mora biti tipa 
\family typewriter
double
\family default
, neophodno je konvertovati brojač 
\family typewriter
for
\family default
 petlje koji je celobrojan u tip 
\family typewriter
double
\family default
.
 Takođe, potrebno je navesti i zaglavlje
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja!
\family typewriter
cmath
\end_layout

\end_inset

 
\family typewriter
<cmath>
\family default
 u kome se nalaze matematičke funcije.
\end_layout

\begin_layout Standard
Petlja 
\family typewriter
for
\family default
 može se izvršavati „unapred“ ili „unazad“, tj.
 kontrolna promenljiva se može povećavati ili smanjivati za bilo koji iznos.
 Na primer, sledeći program ispisuje brojeve od 50 do –50, u koracima koji
 se smanjuju za po 10: 
\end_layout

\begin_layout LyX-Code

\size small
for(int i=50; i>=50; i-=10)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << i << endl;
\end_layout

\end_deeper
\begin_layout Standard
Važno je zapamtiti da se uslovni izraz 
\family typewriter
for
\family default
 petlje uvek proverava na početku.
 To znači da se telo for petlje neće izvršiti nijednom ako je vrednost kontrolno
g izraza na početku 
\family typewriter
false
\family default
.
 Evo i primera:
\end_layout

\begin_layout LyX-Code

\size small
for(int brojac=10; brojac < 5; brojac++)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << brojac; //ova naredba nikad se nece izvrsiti
\end_layout

\end_deeper
\begin_layout Standard
Ova petlja se neće izvršiti nijednom jer je vrednost njene kontrolne promenljive
 brojac veća od 5 kada se prvi put uđe u petlju.
 
\end_layout

\begin_layout Standard
Naredba 
\family typewriter
for
\family default
 je jedna od najkorisnijih u jeziku C++ jer ima mnogo varijacija.
 Na primer, dozvoljava korišćenje nekoliko kontrolnih promenljivih: 
\end_layout

\begin_layout LyX-Code

\size small
int x, y;
\end_layout

\begin_layout LyX-Code

\size small
for(x=0, y=10; x <=y; ++x, --y)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << x << ' ' << y << endl;
\end_layout

\end_deeper
\begin_layout Standard
U ovom primeru zarezi razdvajaju dve naredbe za inicijalizaciju i dva izraza
 za inkrementiranje; to je neophodno da bi kompajler razumeo da postoje
 dve naredbe inicijalizacije i dve naredbe inkrementiranja.
 Takođe, za razliku od većine drugih programskih jezika, C++ omogućuje da
 delovi petlje 
\family typewriter
for
\family default
 budu izostavljeni, kao u sledećem primeru: 
\end_layout

\begin_layout LyX-Code

\size small
//for petlja bez inkrementa
\end_layout

\begin_layout LyX-Code

\size small
for(int i=0; i != 123 ; ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << 
\begin_inset Quotes sld
\end_inset

unesite ceo broj: 
\begin_inset Quotes sld
\end_inset

;
\end_layout

\begin_layout LyX-Code

\size small
cin >> i;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
U ovom primeru deo za inkrementiranje je prazan.
 Kad god se izvrši petlja, proverava se da li kontrolna promenljiva ima
 vrednost 123, i ništa više.
 Petlja se završava kada korisnik programa preko tastature unese 123.
\end_layout

\begin_layout Standard
Još jedna moguća varijacija 
\family typewriter
for
\family default
 petlje jeste da se deo inicijalizacije izmesti izvan petlje, kao u sledećem
 primeru: 
\end_layout

\begin_layout LyX-Code

\size small
//for petlja koja ispisuje brojeve od 1 do 10
\end_layout

\begin_layout LyX-Code

\size small
int i = 1; //i je inicijalizovan van for petlje
\end_layout

\begin_layout LyX-Code

\size small
for( ; i <=10; ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << i << ' ';
\end_layout

\begin_layout LyX-Code

\size small
i++;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Ovde je deo za inicijalizaciju prazan, a promenljiva 
\family typewriter
x
\family default
 je inicijalizovana pre ulaska u petlju.
 Izmeštanje inicijalizacije izvan petlje obično se radi kada se početna
 vrednost dobija složenim postupkom koji nema veze sa telom 
\family typewriter
for
\family default
 petlje.
 Primetite takođe da je u ovom primeru deo inkrementiranja kontrolne promenljive
 smešten unutar tela 
\family typewriter
for
\family default
 petlje.
 
\end_layout

\begin_layout Standard
Moguće je napisati i 
\family typewriter
for
\family default
 petlju koja nema telo, kao u sledećem primeru:
\end_layout

\begin_layout LyX-Code

\size small
//for petlja koja sabira brojeve od 1 do 10
\end_layout

\begin_layout LyX-Code

\size small
int j=0;
\end_layout

\begin_layout LyX-Code

\size small
for(int i=0; i < 10; j+=++i);
\end_layout

\begin_layout LyX-Code

\size small
cout << j << endl; //ispisuje 55
\end_layout

\begin_layout Standard
Beskonačna petlja
\begin_inset Index idx
status open

\begin_layout Plain Layout
beskonačna petlja
\end_layout

\end_inset

 (tj.
 petlja koja se nikada ne završava)u jeziku C++ piše se ovako:
\end_layout

\begin_layout LyX-Code

\size small
for ( ; ; ) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//beskonacna petlja
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Iako postoje određeni poslovi koji ne treba nikada da se završe (npr.
 izvršavanje komandnog procesora u operativnim sistemima), većina „beskonačnih
 petlji“ zapravo su obične petlje sa specijalnim uslovom završetka.
 Za izlazak iz „beskonačne“ petlje koristi se naredba 
\family typewriter
break
\family default
 o kojoj će biti reči u nastavku ovog poglavlja.
 
\end_layout

\begin_layout Section
Petlja while 
\end_layout

\begin_layout Standard
Druga vrsta petlje
\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!while
\end_layout

\end_inset

 podržana u jeziku C++ je 
\family typewriter
while
\begin_inset Index idx
status open

\begin_layout Plain Layout
while
\end_layout

\end_inset


\family default
, čiji je opšti oblik 
\end_layout

\begin_layout Standard
\align left

\family typewriter
\shape slanted
\size small
while(izraz) blok naredbi;
\end_layout

\begin_layout Standard
Izraz definiše uslov koji kontroliše petlju i može da bude bilo koji validan
 izraz.
 Petlja se izvršava sve dok izraz ima vrednost 
\family typewriter
true
\family default
; kada postane 
\family typewriter
false
\family default
, izvršavanje programa nastavlja se u redu odmah iza petlje.
 Petlja 
\family typewriter
while
\family default
 je najkorisnija za ponavljanje delova kôda čiji broj ponavljanja nije unapred
 poznat.
 Kao primer, proučimo program koji računa faktorijel broja koji se unosi
 preko tastature.
 Zanimljivo je da nema suštinske razlike između petlji 
\family typewriter
for
\family default
 i 
\family typewriter
while
\family default
, jer se svaka 
\family typewriter
while
\family default
 petlja uz malo prilagođavanje može napisati kao petlja 
\family typewriter
for
\family default
:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//izracunavanje faktorijela
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <cmath> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int broj; 
\end_layout

\begin_layout LyX-Code

\size small
int faktorijel=1; 
\end_layout

\begin_layout LyX-Code

\size small
int i=2; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Unesite ceo broj: "; 
\end_layout

\begin_layout LyX-Code

\size small
cin >> broj; 
\end_layout

\begin_layout LyX-Code

\size small
while(i<=broj) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
faktorijel *=i; 
\end_layout

\begin_layout LyX-Code

\size small
i++; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Faktorijel broja " << broj << " je: " << 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
faktorijel << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\paragraph_spacing single
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite ceo broj: 5 
\end_layout

\begin_layout Standard

\series bold
\size small
Faktorijel broja 5 je 120
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Section
Petlja do-while
\end_layout

\begin_layout Standard
Često je potrebno da se određena operacija obavi, pa da se u zavisnosti
 od njenog rezultata odlučuje da li će se ona ponavljati ili ne.
 Za tu svrhu služi petlja
\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!do-while
\end_layout

\end_inset

 
\family typewriter
do-while
\begin_inset Index idx
status open

\begin_layout Plain Layout
do-while
\end_layout

\end_inset


\family default
, čija je sintaksa:
\end_layout

\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
do 
\end_layout

\begin_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
blok naredbi
\end_layout

\end_deeper
\begin_layout LyX-Code
\paragraph_spacing single

\shape slanted
\size small
while(izraz);
\end_layout

\begin_layout Standard
Sledeći primer koristi 
\family typewriter
do-while
\family default
 petlju za izvršavanje sve dok korisnik ne unese broj 15:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//primer petlje do while
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 	
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
const int TAJNI_BROJ = 15; 	
\end_layout

\begin_layout LyX-Code

\size small
int broj = 0; 	
\end_layout

\begin_layout LyX-Code

\size small
do { 		
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Unesite tajni broj: "; 		
\end_layout

\begin_layout LyX-Code

\size small
cin >> broj; 	
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} while (broj != TAJNI_BROJ);  	
\end_layout

\begin_layout LyX-Code

\size small
cout << "Pogodili ste tajni broj!" << endl; 	
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\paragraph_spacing single
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite tajni broj: 6 
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite tajni broj: 20
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite tajni broj: 15
\end_layout

\begin_layout Standard

\series bold
\size small
Pogodili ste tajni broj!
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Treba zapamtiti suštinsku razliku između petlji 
\family typewriter
while
\family default
 i 
\family typewriter
do-while
\family default
, a to je da se petlja 
\family typewriter
do-while
\family default
 sigurno izvršava barem jednom, jer se uslov petlje proverava na dnu, za
 razliku od petlje 
\family typewriter
while
\family default
 kod koje se uslov proverava na vrhu pa može da se desi da se uopšte ne
 izvrši.
\end_layout

\begin_layout Section
Naredbe break i continue
\end_layout

\begin_layout Standard
Naredbu 
\family typewriter
break
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!break
\end_layout

\end_inset

 smo već susreli u grananju 
\family typewriter
switch
\family default
, ali se ona može koristiti i za prekid izvršavanja petlji 
\family typewriter
for
\family default
, 
\family typewriter
while
\family default
 i 
\family typewriter
do while
\family default
.
 Ova naredba prouzrokuje prekid izvršavanja petlje i skok na prvu naredbu
 iza petlje.
 U sledećem primeru 
\family typewriter
for
\family default
 petlja se prekida kada vrednost kontrolne promenljive 
\family typewriter
x 
\family default
postane 3:
\end_layout

\begin_layout LyX-Code

\size small
for(int x=10; x > 0; x--) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
if(x == 3) 
\end_layout

\begin_layout LyX-Code

\size small
cout << "odbrojavanje zavrseno!"; 
\end_layout

\begin_layout LyX-Code

\size small
break; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Kada su petlje ugnježđene (odnosno, kada se jedna petlja nalazi unutar druge),
 
\family typewriter
break
\family default
 prekida samo unutrašnju petlju.
 Naredba 
\family typewriter
break
\family default
 je najkorisnija kada postoji neki specijalan uslov koji trenutno prekida
 ponavljanje naredbi, a najčešće se koristi za izlazak iz 
\begin_inset Quotes eld
\end_inset

beskonačnih
\begin_inset Quotes erd
\end_inset

 petlji.
\end_layout

\begin_layout Standard
Moguće je prekinuti i samo jedan ciklus (iteraciju) petlje, što se postiže
 pomoću naredbe
\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!continue
\end_layout

\end_inset

 
\family typewriter
continue
\begin_inset Index idx
status open

\begin_layout Plain Layout
continue
\end_layout

\end_inset


\family default
.
 Ova naredba preskače kompletan kôd do kraja tekuće iteracije petlje i prenosi
 izvršavanje na proveru uslova koji kontroliše petlju.
 Na primer, sledeći kôd ispisuje parne brojeve između 1 i 100:
\end_layout

\begin_layout LyX-Code

\size small
for(int x=0; x <= 100; x++) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
if(x%2) //preskace neparne brojeve 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
continue; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << x << endl; 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
U petljama 
\family typewriter
while
\family default
 i 
\family typewriter
do while
\family default
, naredba 
\family typewriter
continue
\family default
 prenosi kontrolu direktno na proveru kontrolne promenljive, a zatim se
 izvršavanje petlje nastavlja.
\end_layout

\begin_layout Standard
Naredbe 
\family typewriter
break
\family default
 i 
\family typewriter
continue
\family default
 u programima treba koristiti samo kada su zaista neophodne, jer narušavaju
 strukturiranost programa.
 
\end_layout

\begin_layout Section
Ugnježđene petlje
\end_layout

\begin_layout Standard
Petlje se mogu nalaziti jedna unutar druge, što se veoma često koristi u
 programiranju.
 Dobar primer za primenu ugnježđenih petlji
\begin_inset Index idx
status open

\begin_layout Plain Layout
ugnježđene petlje
\end_layout

\end_inset

 je digitalni sat, sa poljima koja prikazuju sate, minute i sekunde.
 Vrednost za sate promeni se jednom za vreme dok se vrednost za minute promeni
 60 puta, a za isto vreme se vrednost za sekunde promeni 3600 puta.
 U nastavku je dat primer ugnježđenih 
\family typewriter
for
\family default
 petlji za digitalni sat:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//primer ugnjezdjenih for petlji
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
for(int sat=0; sat<24; sat++) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
for(int minut=0; minut<60; minut++) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
for(int sekund=0; sekund<60; sekund++) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << sat << ":" << minut << ":" << sekund << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\family typewriter
\series bold
\size small
0:0:0 
\end_layout

\begin_layout Standard

\family typewriter
\series bold
\size small
0:0:1
\end_layout

\begin_layout Standard

\family typewriter
\series bold
\size small
0:0:2
\end_layout

\begin_layout Standard

\family typewriter
\series bold
\size small
...
\end_layout

\begin_layout Standard

\family typewriter
\series bold
\size small
23:59:58
\end_layout

\begin_layout Standard

\family typewriter
\series bold
\size small
23:59:59
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Section
Naredba bezuslovnog skoka (goto)
\end_layout

\begin_layout Standard
Naredba 
\family typewriter
goto
\family default
 u jeziku C++služi za bezuslovni skok
\begin_inset Index idx
status open

\begin_layout Plain Layout
bezuslovni skok
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!goto
\end_layout

\end_inset

 na lokaciju koja je navedena u nastavku iza ključne reči 
\family typewriter
goto
\begin_inset Index idx
status open

\begin_layout Plain Layout
goto
\end_layout

\end_inset


\family default
.
 Iako je naredba 
\family typewriter
goto
\family default
 gotovo sasvim proterana iz upotrebe zbog toga što čini kôd nečitljivim,
 a nije ni neophodna jer se uvek može pronaći elegantnije rešenje, ipak
 se ponekad koristi za kontrolu programa.
 Da bi se koristila, zahteva da se naredba na koju se 
\begin_inset Quotes eld
\end_inset

skače
\begin_inset Quotes erd
\end_inset

 označi identifikatorom iza koga sledi dvotačka, kao u sledećem primeru:
\end_layout

\begin_layout LyX-Code

\size small
if(a ==0) goto deljenjeNulom;
\end_layout

\begin_layout LyX-Code

\size small
//naredbe
\end_layout

\begin_layout LyX-Code

\size small
deljenjeNulom:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << 
\begin_inset Quotes sld
\end_inset

deljenje nulom nije dozvoljeno!
\begin_inset Quotes srd
\end_inset

;
\end_layout

\end_deeper
\begin_layout Section*
Pitanja
\end_layout

\begin_layout Standard
1.
 Blok koda odvaja se zagradama:
\end_layout

\begin_layout Standard
a) ( )
\end_layout

\begin_layout Standard
b) [ ] 
\end_layout

\begin_layout Standard
c) {} 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
2.
 Doseg (scope) promenljive ograničen je na blok u kome je definisana.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset

3.
 Promenljiva 
\family typewriter
x
\family default
 nakon naredbe 
\family typewriter
x = (10 > 11) ? 10 : 11;
\family default
 ima vrednost: 
\end_layout

\begin_layout Standard
a) 10
\end_layout

\begin_layout Standard
b) 11
\end_layout

\begin_layout Standard
c) 0
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
4.
 Delovi petlje 
\family typewriter
for
\family default
 mogu biti prazni.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
5.
 Petlja 
\family typewriter
for(i=0;i<=20;i++)
\family default
 ima: 
\end_layout

\begin_layout Standard
a) 20 ciklusa
\end_layout

\begin_layout Standard
b) 21 ciklus
\end_layout

\begin_layout Standard
c) 19 ciklusa 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
6.
 Petlja 
\family typewriter
for(i=1;i<=20;i++)
\family default
 ima: 
\end_layout

\begin_layout Standard
a) 20 ciklusa
\end_layout

\begin_layout Standard
b) 21 ciklus
\end_layout

\begin_layout Standard
c) 19 ciklusa
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
7.
 Šta radi sledeći deo kôda: 
\family typewriter
for( ; ; )
\family default
 
\end_layout

\begin_layout Standard
a) pogrešan kôd
\end_layout

\begin_layout Standard
b) beskonačna petlja
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
8.
 Koliko je 
\family typewriter
ch
\family default
 u sledećem primeru? 
\end_layout

\begin_layout Standard

\family typewriter
int i=7; 
\end_layout

\begin_layout Standard

\family typewriter
char ch; 
\end_layout

\begin_layout Standard

\family typewriter
ch =(i==3) ? 'A' : 'B'; 
\end_layout

\begin_layout Standard
a) 'B'
\end_layout

\begin_layout Standard
b) 'A'
\end_layout

\begin_layout Standard
c) 7
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
9.
 Izraz koji kontroliše grananje tipa 
\family typewriter
switch
\family default
 mora da bude logičkog tipa.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
10.
 Naredba u jeziku C++ koja služi za bezuslovan skok je: 
\end_layout

\begin_layout Standard
a) 
\family typewriter
break
\end_layout

\begin_layout Standard
b) 
\family typewriter
continue
\end_layout

\begin_layout Standard
c) 
\family typewriter
goto
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
11.
 Telo petlje 
\family typewriter
while
\family default
 može biti prazno.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
12.
 Telo petlje 
\family typewriter
do while
\family default
 izvršava se barem jednom.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
13.
 U telu petlje mogu se deklarisati promenljive.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
14.
 U ugnježđenoj petlji, naredba 
\family typewriter
break
\family default
 prekida samo petlju u kojoj se nalazi.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
15.
 Jedno od ograničenja petlje 
\family typewriter
for
\family default
 jeste da se u delu za inicijalizaciju može inicijalizovati samo jedna promenlji
va.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
16.
 Naredba 
\family typewriter
continue
\family default
 služi za prelazak na sledeći ciklus petlje.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
17.
 Koju vrednost ima promenljiva
\family typewriter
 y
\family default
 posle izvršavanja sledećeg kôda: 
\end_layout

\begin_layout Standard

\family typewriter
int x=3, y=3; 
\end_layout

\begin_layout Standard

\family typewriter
switch(x+3) { 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case(6): 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

y =0; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case(7): 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

y =1; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

default: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

y++; 
\end_layout

\begin_layout Standard

\family typewriter
} 
\end_layout

\begin_layout Standard
a) 1
\end_layout

\begin_layout Standard
b) 2
\end_layout

\begin_layout Standard
c) 3
\end_layout

\begin_layout Standard
d) 4
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
18.
 Šta se prikazuje na ekranu kao rezultat izvršavanja ovog kôda: 
\end_layout

\begin_layout Standard

\family typewriter
char ch=’a’; 
\end_layout

\begin_layout Standard

\family typewriter
switch(ch) { 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case ’a': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case’A’: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

cout<<ch; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

break; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case ’b’: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case ’B’: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

cout<<ch; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

break; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case’c’: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case ’C’: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

cout<<ch; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

break; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case ’d’: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case ’D’: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

cout< <ch; 
\end_layout

\begin_layout Standard
} 
\end_layout

\begin_layout Standard
a) a
\end_layout

\begin_layout Standard
b) A
\end_layout

\begin_layout Standard
c) Aa
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
19.
 Sledeći deo kôda: 
\end_layout

\begin_layout Standard

\family typewriter
int x; 
\end_layout

\begin_layout Standard

\family typewriter
double d =1.5; 
\end_layout

\begin_layout Standard

\family typewriter
switch(d) { 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case 1.0: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

x =1; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case 1.5: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

x=2; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

case 2.0: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

x=3; 
\end_layout

\begin_layout Standard

\family typewriter
} 
\end_layout

\begin_layout Standard
je
\end_layout

\begin_layout Standard
a) pogrešan, jer nedostaju naredbe break
\end_layout

\begin_layout Standard
b) pogrešan, jer nedostaje naredba default
\end_layout

\begin_layout Standard
c) pogrešan jer kontrolna promenljiva d u naredbi switch ne može biti tipa
 double 
\end_layout

\begin_layout Standard
d) ispravan
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
20.
 Šta se prikazuje na ekranu kao rezultat sledećeg kôda: 
\end_layout

\begin_layout Standard

\family typewriter
int k=20; 
\end_layout

\begin_layout Standard

\family typewriter
while (k>0) 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

cout <<k; 
\end_layout

\begin_layout Standard
a) kôd je pogrešan i neće se izvršavati
\end_layout

\begin_layout Standard
b) neće se prikazati ništa
\end_layout

\begin_layout Standard
c) stalno će se prikazivati 20 u beskonačnoj petlji
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
21.
 Šta se prikazuje na ekranu kao rezultat izvršavanja sledećeg kôda: 
\end_layout

\begin_layout LyX-Code

\family typewriter
int i=1; 
\end_layout

\begin_layout LyX-Code

\family typewriter
do { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
i++; } while(i<5); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
cout<<
\begin_inset Quotes srd
\end_inset

i= 
\begin_inset Quotes sld
\end_inset

<< i;
\family default
 
\end_layout

\begin_layout Standard
a) ništa se neće prikazati 
\end_layout

\begin_layout Standard
b) stalno će se prikazivati i=1 u beskonačnoj petlji 
\end_layout

\begin_layout Standard
c) i=5
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
22.
 Šta se prikazuje na ekranu kao rezultat izvršavanja sledećeg kôda: 
\end_layout

\begin_layout Standard

\family typewriter
int zbir = 0; 
\end_layout

\begin_layout Standard

\family typewriter
for(int i=0;i<10;i++) 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

zbir +=i; 
\end_layout

\begin_layout Standard

\family typewriter
cout <<zbir;
\end_layout

\begin_layout Standard
a) 10
\end_layout

\begin_layout Standard
b) 11
\end_layout

\begin_layout Standard
c) 45
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
23.
 Da li će izvršavanje sledećeg dela kôda biti beskonačno? 
\end_layout

\begin_layout Standard

\family typewriter
int stanje = 10; 
\end_layout

\begin_layout Standard

\family typewriter
while(true) { 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

if(stanje<9) 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

break; 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

stanje = stanje - 9; 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
a) da
\end_layout

\begin_layout Standard
b) ne
\end_layout

\begin_layout Chapter
Nizovi, stringovi i pokazivači
\end_layout

\begin_layout Standard
U ovom poglavlju bavićemo se nizovima, stringovima i pokazivačima.
 Iako na prvi pogled izgleda da su to tri nepovezane teme, nije tako.
 U jeziku C++ nizovi, stringovi i pokazivači su toliko povezani da razumevanje
 jednog pojma veoma olakšava rad sa drugima.
 
\end_layout

\begin_layout Standard

\shape italic
Niz
\shape default
 (array)
\begin_inset Index idx
status open

\begin_layout Plain Layout
nizovi
\end_layout

\end_inset

 je skup promenljivih istog tipa kojima se pristupa preko zajedničkog imena.
 Nizovi mogu imati samo jednu ili više dimenzija, mada se najčešće koriste
 jednodimenzionalni nizovi.
 Nizovi su pogodan način za pravljenje liste povezanih promenljivih, a najčešće
 se koriste nizovi znakova.
 
\end_layout

\begin_layout Standard
U jeziku C++ ne postoji ugrađen tip string, već su stringovi implementirani
 kao nizovi znakova.
 Ovakav pristup nudi veću slobodu i prilagodljivost u odnosu na jezike u
 koje je ugrađen tip string.
 
\end_layout

\begin_layout Standard
Pokazivač je promenljiva koja sadrži neku memorijsku adresu.
 Pokazivači se najčešće koriste za pristupanje drugim objektima u memoriji,
 a često su ti objekti nizovi.
 U stvari, pokazivači i nizovi su u mnogo čvršćoj vezi nego što se na prvi
 pogled čini, o čemu će biti reči u nastavku poglavlja.
\end_layout

\begin_layout Section
Jednodimenzionalni nizovi
\end_layout

\begin_layout Standard
Jednodimenzionalni niz
\begin_inset Index idx
status open

\begin_layout Plain Layout
nizovi!jednodimenzionalni
\end_layout

\end_inset

 je skup povezanih promenljivih istog tipa.
 Nizovi se često koriste u programiranju, a u jeziku C++ opšti oblik deklaracije
 niza je 
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
\shape slanted
tip ime_niza [dimenzija];
\shape default
 
\end_layout

\begin_layout Standard
Tip deklariše
\begin_inset Index idx
status open

\begin_layout Plain Layout
nizovi!deklaracija
\end_layout

\end_inset

 osnovni tip elemenata koji sačinjavaju niz.
 Dimenzija određuje broj elemenata koje niz može da sadrži.
 Na primer, sledeća naredba deklariše niz koji sadrži deset celih brojeva:
 
\end_layout

\begin_layout Standard

\family typewriter
int primer[10];
\end_layout

\begin_layout Standard
Pojedinačnim elementima niza pristupa se preko indeksa, koji određuje poziciju
 elementa u nizu.
 U jeziku C++, indeks prvog elementa niza je 0.
 Pošto niz iz primera ima deset elemenata, vrednosti njihovih indeksa su
 od 0 do 9.
 Elementu niza pristupa se preko njegovog indeksa koji se navodi u uglastim
 zagradama.
 Tako je prvi element niza primer 
\family typewriter
primer[0]
\family default
, a poslednji je 
\family typewriter
primer[9]
\family default
.
 
\end_layout

\begin_layout Standard
Nizovi se u programiranju često koriste zato što olakšavaju rad sa povezanim
 promenljivama.
 Na primer, sledeći program pravi niz od deset elemenata, svakom od njih
 dodeljuje vrednost, a zatim prikazuje sadržaj elemenata niza:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int i; 
\end_layout

\begin_layout LyX-Code

\size small
int primer[10]; //rezervise prostor za 10 celih brojeva 
\end_layout

\begin_layout LyX-Code

\size small
//inicijalizacija elemenata niza 
\end_layout

\begin_layout LyX-Code

\size small
for(i=0; i<10;i++) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
primer[i] = i; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
//prikaz elemenata niza 
\end_layout

\begin_layout LyX-Code

\size small
for(i=0; i<10;i++) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "primer[" << i << "] = " << primer[i] << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\paragraph_spacing single
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
primer[0] = 0;
\end_layout

\begin_layout Standard

\series bold
\size small
primer[1] = 1;
\end_layout

\begin_layout Standard

\series bold
\size small
primer[2] = 2;
\end_layout

\begin_layout Standard

\series bold
\size small
...
\end_layout

\begin_layout Standard

\series bold
\size small
primer[9] = 9;
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
U jeziku C++ elementi niza smeštaju se u susedne memorijske lokacije.
 Prvi element nalazi se na najnižoj adresi, a poslednji na najvišoj.
 
\end_layout

\begin_layout Standard
Direktna dodela jednog niza drugom nije dozvoljena, već se vrednosti moraju
 dodeljivati element po element:
\end_layout

\begin_layout LyX-Code

\size small
int a[10], b[10];
\end_layout

\begin_layout LyX-Code

\size small
a = b; //greska!
\end_layout

\begin_layout LyX-Code

\size small
for(int i=0; i<10; i++) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
a[i]=b[i]; //ispravno kopiranje niza
\end_layout

\end_deeper
\begin_layout Standard
Jezik C++ ne proverava granice niza
\begin_inset Index idx
status open

\begin_layout Plain Layout
nizovi!provera granica
\end_layout

\end_inset

 (bounds checking), što znači da programera ništa ne sprečava da "prekorači
\begin_inset Quotes erd
\end_inset

 kraj niza.
 Drugim rečima, ako je indeks poslednjeg elementa niza N, može da se indeksira
 element sa indeksom većim od N a da to ne izazove nikakve greške tokom
 kompajliranja ili izvršavanja programa.
 Na primer, kompajler će prevesti i izvršiti sledeći kôd a da se ni najmanje
 ne pobuni:
\end_layout

\begin_layout LyX-Code

\size small
int krah[10], i;
\end_layout

\begin_layout LyX-Code

\size small
for(i=0; i<100; i++) krah[i]=i;
\end_layout

\begin_layout Standard
U ovom slučaju petlja će se ponoviti 100 puta, iako niz krah ima samo deset
 elemenata.
 To će prouzrokovati menjanje memorijskih lokacija koje nisu dodeljene nizu
 
\family typewriter
krah
\family default
.
 Prekoračivanje granica niza može da prouzrokuje katastrofalne posledice.
 Ako se prekoračenje granice desi u operaciji dodele, menja se memorija
 u kojoj se mogu naći neke druge promenljive, a ako se desi tokom čitanja,
 program će raditi sa neispravnim podacima.
 Međutim, kada bi provera granica niza bila ugrađena u jezik (kao npr.
 u Javi), C++ kôd ne bi bio toliko brz i efikasan.
 Od programera se očekuje da bude oprezan, tj.
 da deklariše niz tako da sadrži potreban broj elemenata i da ne dozvoli
 prekoračivanje granice niza.
\end_layout

\begin_layout Section
Višedimenzionalni nizovi
\end_layout

\begin_layout Standard
C++ podržava i višedimenzionalne nizove
\begin_inset Index idx
status open

\begin_layout Plain Layout
nizovi!višedimenzionalni
\end_layout

\end_inset

, a najjednostavniji oblik je dvodimenzionalni niz.
 To je zapravo niz jednodimenzionalnih nizova.
 Na primer, dvodimenzionalni celobrojni niz 
\family typewriter
dvaD
\family default
 dimenzija 10 i 20 deklariše se kao:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int dvaD[10][20];
\end_layout

\begin_layout Standard
Za razliku od nekih drugih programskih jezika koji koriste zarez za razdvajanje
 dimenzija niza, u jeziku C++ svaka dimenzija stavlja se u sopstvene uglaste
 zagrade.
 Slično, elementima niza se pristupa tako što se indeksi navode u sopstvenim
 uglastim zagradama (npr.
 
\family typewriter
dvaD[3][5]
\family default
).
 U sledećem primeru kreira se i inicijalizuje dvodimenzionalni niz 
\family typewriter
brojevi
\family default
:
\end_layout

\begin_layout LyX-Code

\size small
const int BROJ_REDOVA = 3; 
\end_layout

\begin_layout LyX-Code

\size small
const int BROJ_KOLONA = 4; 
\end_layout

\begin_layout LyX-Code

\size small
//deklaracija niza sa 3 reda i 4 kolone 
\end_layout

\begin_layout LyX-Code

\size small
int brojevi[BROJ_REDOVA][BROJ_KOLONA]; 
\end_layout

\begin_layout LyX-Code

\size small
for(int red=0; red<BROJ_REDOVA; red++) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
for(int kolona=0; red<BROJ_KOLONA; kolona++) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
brojevi[red][kolona] = 4*red + kolona + 1; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
U ovom primeru,
\family typewriter
 brojevi[0][0] 
\family default
imaće vrednost 1, 
\family typewriter
brojevi[0][1]
\family default
 vrednost 2, 
\family typewriter
brojevi[0][2] 
\family default
vrednost 3 itd.
 Vrednost elementa 
\family typewriter
brojevi[2][3]
\family default
 biće 12.
 
\end_layout

\begin_layout Standard
Dvodimenzionalni nizovi čuvaju se u matrici red-kolona, u kojoj prvi indeks
 označava red, a drugi kolonu.
 To znači da kada se elementima dvodimenzionalnog niza pristupa na način
 na koji se stvarno čuvaju u memoriji, desni indeks se menja brže od levog.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
levi indeks (red)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
desni indeks (kolona)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Treba imati na umu da se ukupna memorija potrebna za sve elemente niza određuje
 tokom prevođenja, i da je ta memorija rezervisana za niz dogod on postoji.
 U slučaju dvodimenzionalnog niza, u memoriji se odvaja sledeći broj bajtova:
 
\end_layout

\begin_layout Standard
broj redova × broj kolona × sizeof(tip elemenata niza).
 
\end_layout

\begin_layout Standard
Recimo, za najčešći slučaj računara na kome tip 
\family typewriter
int
\family default
 zauzima 4 bajta, celobrojni niz sa 10 redova i pet kolona zauzimao bi 200
 bajtova.
\end_layout

\begin_layout Standard
Nizovi mogu imati i više od dve dimenzije, i tada se deklarišu kao:
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
\shape slanted
tip ime_niza [dimenzija1][dimenzija2]...[dimenzijaN];
\end_layout

\begin_layout Standard
Međutim, nizovi sa više od tri dimenzije izuzetno se retko koriste u praksi,
 jer zauzimaju mnogo memorije (na primer, četvorodimenzionalni niz znakova
 dimenzija 100×60×90×40 zauzimao bi preko 20 MB u memoriji), pa bi 
\begin_inset Quotes eld
\end_inset

pojeo
\begin_inset Quotes erd
\end_inset

 slobodnu memoriju za ostatak programa.
\end_layout

\begin_layout Section
Stringovi
\end_layout

\begin_layout Standard
Najčešće se jednodimenzionalni nizovi koriste za čuvanje znakova.
 Jezik C++ podržava dve vrste niza znakova
\begin_inset Index idx
status open

\begin_layout Plain Layout
nizovi znakova
\end_layout

\end_inset

 (stringova).
 Prvi je niz znakova koji se završava nulom
\begin_inset Index idx
status open

\begin_layout Plain Layout
C stringovi
\end_layout

\end_inset

 (null-terminated string), nasleđen iz jezika C.
 On sadrži znakove koji sačinjavaju string, i na kraju null (odnosno nulu,
 tj.
 znak 
\backslash
0).
 Ova vrsta stringova se često koristi zato što je veoma efikasna i programeru
 omogućuje detaljnu kontrolu nad operacijama sa stringovima.
 Druga vrsta je klasa 
\family typewriter
string
\family default
 koja se nalazi u biblioteci klasa jezika C++.
 Treba zapamtiti da u jeziku C++ string nije osnovni (ugrađen tip).
 U ovom poglavlju pozabavićemo se stringovima koji se završavaju nulom (C
 stringovima).
\end_layout

\begin_layout Standard
Kada se deklariše
\begin_inset Index idx
status open

\begin_layout Plain Layout
nizovi znakova!deklaracija
\end_layout

\end_inset

 niz znakova koji se završava nulom, on treba da se deklariše tako da bude
 za jedan duži od broja znakova u stringu koji treba da sadrži.
 Na primer, ako želimo da deklarišemo niz 
\family typewriter
str
\family default
 u koji treba da stane string od deset znakova, deklarisaćemo ga kao:
\end_layout

\begin_layout Standard

\family typewriter
\size small
char str[11];
\end_layout

\begin_layout Standard
Zadavanje dimenzije 11 rezerviše prostor za nulu na kraju niza znakova.
 U Poglavlju 2 pominjali smo da C++ dozvoljava definisanje string konstanti,
 tj.
 niza znakova koji se pišu pod navodnicima (npr.
 "cao", "Ja volim C++", "Tri praseta", "").
 Na kraj string konstanti nije neophodno 
\begin_inset Quotes eld
\end_inset

ručno
\begin_inset Quotes erd
\end_inset

 dodavati nulu, jer C++ kompajler to radi automatski.
 Tako će string “Tri praseta” u memoriji izgledati ovako:
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="12">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
String "" se zove null string, jer sadrži samo nulu, a koristan je za predstavlj
anje praznog stringa.
 
\end_layout

\begin_layout Subsection
Učitavanje stringa sa tastature
\end_layout

\begin_layout Standard
Najlakši način za čitanje stringa
\begin_inset Index idx
status open

\begin_layout Plain Layout
stringovi!učitavanje preko tastature
\end_layout

\end_inset

 unetog preko tastature jeste korišćenje niza znakova u naredbi 
\family typewriter
cin
\begin_inset Index idx
status open

\begin_layout Plain Layout
cin
\end_layout

\end_inset


\family default
, kao u sledećem primeru:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char str[80]; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Unesite string: "; 
\end_layout

\begin_layout LyX-Code

\size small
cin >> str; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Uneli ste: " << str << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\paragraph_spacing single
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite string: Ovo je string
\end_layout

\begin_layout Standard

\series bold
\size small
Uneli ste: Ovo
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Kada program ponovo prikaže učitan string, prikazaće samo reč “Ovo”, a ne
 celu rečenicu, zato što U/I sistem prestaje sa učitavanjem stringa kada
 naiđe na prvu belinu (whitespace).
 Pod belinama podrazumevamo razmake, tabulatore i znakove za nov red.
 Taj problem rešićemo upotrebom funkcije 
\family typewriter
gets()
\begin_inset Index idx
status open

\begin_layout Plain Layout
gets()
\end_layout

\end_inset


\family default
 koja je takođe deo standardne C++ biblioteke.
 Da bismo učitali string, pozvaćemo funkciju 
\family typewriter
gets()
\family default
kojoj ćemo kao argument proslediti ime niza bez indeksa, a kao rezultat
 taj niz će sadržati string učitan sa tastature.
 Funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
gets()
\end_layout

\end_inset

 
\family typewriter
gets()
\family default
 nastaviće da učitava znake (uključujući i beline) sve dok se ne unese carriage
 return (znak za nov red).
 Funkcija 
\family typewriter
gets()
\family default
 nalazi se u zaglavlju
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja!
\family typewriter
cstdio
\end_layout

\end_inset

 
\family typewriter
<cstdio>
\family default
 pa se ono mora navesti:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char str[80]; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Unesite string: "; 
\end_layout

\begin_layout LyX-Code

\size small
gets(str); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Uneli ste: " << str << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
Uočite da se u naredbi 
\family typewriter
cout
\family default
 može direktno koristiti 
\family typewriter
str
\family default
.
 U opštem slučaju, ime niza znakova koji sadrži string može se koristiti
 svuda gde može da se koristi string konstanta.
 Takođe, zapamtite da ni 
\family typewriter
cin
\family default
 ni 
\family typewriter
gets()
\family default
 ne proveravaju granice niza koji prihvata unos sa tastature.
 Ako korisnik unese string koji je duži od dimenzije niza, memorija će biti
 izmenjena.
 Kasnije ćemo upoznati alternativu za 
\family typewriter
gets()
\family default
 kojom se izbegava taj problem.
\end_layout

\begin_layout Subsection
Funkcije C++ biblioteke za stringove
\end_layout

\begin_layout Standard
U C++ je ugrađen veliki broj funkcija za rad sa stringovima
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!rad sa stringovima
\end_layout

\end_inset

, a najčešće korišćene su prikazane u Tabeli 4.1:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 4.1
\series default
: Najčešće korišćene funkcije za rad sa stringovima.
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Funkcija
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
strcpy
\begin_inset Index idx
status open

\begin_layout Plain Layout
strcpy()
\end_layout

\end_inset

(s1, s2)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kopira string s2 u string s1.
 Niz s1 mora da bude dovoljno dugačak, 
\end_layout

\begin_layout Plain Layout
jer će se u suprotnom biti prekoračena granica niza.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
strcat
\begin_inset Index idx
status open

\begin_layout Plain Layout
strcat()
\end_layout

\end_inset

(s1, s2)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dodaje s2 na kraj s1; s2 ostaje neizmenjen.
 s1 mora da bude dovoljno dugačak 
\end_layout

\begin_layout Plain Layout
da u njega stane sadrži prvobitni sadržaj i ceo niz s2.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
strcmp
\begin_inset Index idx
status open

\begin_layout Plain Layout
strcmp()
\end_layout

\end_inset

(s1, s2)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Poredi stringove s1 i s2; ako su jednaki, vraća 0, ako je s1 > s2 
\end_layout

\begin_layout Plain Layout
(po leksikografskom redu) vraća 1, u suprotnom vraća negativan broj.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
strlen
\begin_inset Index idx
status open

\begin_layout Plain Layout
strlen()
\end_layout

\end_inset

(s) 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća dužinu stringa s.
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Standardna C++ biblioteka nudi i ugrađene funkcije za rad sa znakovima
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!rad sa znakovima
\end_layout

\end_inset

, definisane u zaglavlju
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja!
\family typewriter
cctype
\end_layout

\end_inset

 
\family typewriter
<cctype>
\family default
; Tabela 4.2 prikazuje one koje se najčešće koriste.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 4.2
\series default
: Najčešće korišćene funkcije za rad sa znakovima.
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Funkcija
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
toupper(c)
\begin_inset Index idx
status open

\begin_layout Plain Layout
toupper()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
prevodi znak u veliko slovo (uppercase) 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
tolower(c)
\begin_inset Index idx
status open

\begin_layout Plain Layout
tolower()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
prevodi znak u malo slovo (lowercase) 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
isupper(c)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true ako je znak veliko slovo 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
islower(c)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false ako je znak veliko slovo 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
isalnum(c)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true ako je znak alfanumerički 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
isdigit(c)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true ako je znak cifra
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
isspace(c)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true ako je znak razmak
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Sledeći primer ilustruje korišćenje funkcija 
\family typewriter
strcpy
\family default
 i 
\family typewriter
toupper
\family default
 za prevođenje stringa u sva velika slova:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <cstring> 
\end_layout

\begin_layout LyX-Code

\size small
#include <cctype> 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char str[80]; 
\end_layout

\begin_layout LyX-Code

\size small
strcpy(str, "Ovo je test!"); 
\end_layout

\begin_layout LyX-Code

\size small
for(int i=0; str[i]; i++) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
str[i] = toupper(str[i]); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << str << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
\paragraph_spacing single
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
OVO JE TEST!
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Uočite da je uslov završetka petlje for napisan kao
\family typewriter
 str[i]
\family default
; kada se stigne do poslednjeg znaka niza, on će imati vrednost nula, što
 se automatski tumači kao 
\family typewriter
false
\family default
 i izvršavanje petlje se prekida.
 Nema potrebe da se uslov petlje piše kao
\family typewriter
 str[i] == 0
\family default
.
\end_layout

\begin_layout Section
Inicijalizacija nizova
\end_layout

\begin_layout Standard
Nizovi
\begin_inset Index idx
status open

\begin_layout Plain Layout
nizovi!inicijalizacija
\end_layout

\end_inset

 se mogu inicijalizovati slično drugim promenljivama:
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
\shape slanted
\size small
tip ime_niza[dimenzija]= {skup_vrednosti};
\end_layout

\begin_layout Standard

\family typewriter
Skup_vrednosti
\family default
 je niz vrednosti razdvojenih zarezima istog tipa kao što je tip niza.
 Prva vrednost dodeljuje se prvom elementu niza, druga drugom i tako redom.
 U sledećem primeru inicijalizuje se celobrojni niz 
\family typewriter
kvadratni_metri
\family default
:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int kvadratni_metri[5]={30, 50, 70, 80, 100};
\end_layout

\begin_layout Standard
Ovo znači da će 
\family typewriter
kvadratni_metri[0]
\family default
 imati vrednost 30, a 
\family typewriter
kvadratni_metri[4]
\family default
 će imati vrednost 100.
 Nizovi znakova koji sadrže stringove mogu se kraće inicijalizovati na sledeći
 način:
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
char ime_niza[dimenzija]= 
\begin_inset Quotes eld
\end_inset

string
\begin_inset Quotes erd
\end_inset

; 
\end_layout

\begin_layout Standard
Na primer, ovako se niz 
\family typewriter
\size small
str
\family default
\size default
 inicijalizuje stringom “C++”:
\end_layout

\begin_layout Standard

\family typewriter
\size small
char str[4]=
\begin_inset Quotes srd
\end_inset

C++
\begin_inset Quotes srd
\end_inset

;
\end_layout

\begin_layout Standard
što je isto kao kada bismo napisali
\end_layout

\begin_layout Standard

\family typewriter
\size small
char str[4]={'C', '+', '+','
\backslash
0'};
\end_layout

\begin_layout Standard
Pošto se stringovi moraju završavati nulom, niz znakova koji se deklariše
 mora da bude dovoljno dugačak da u njega stane i nula na kraju.
 Zbog toga je dimenzija niza str u ovom primeru 4, iako “C++” ima samo tri
 znaka.
 Kada se za inicijalizaciju koriste string konstante, kompajler automatski
 dodaje završnu nulu.
\end_layout

\begin_layout Subsection
Inicijalizacija nizova bez dimenzija
\end_layout

\begin_layout Standard
Kada se niz istovremeno deklariše i inicijalizuje, moguće je izostaviti
 dimenziju niza i ostaviti kompajleru da je automatski odredi.
 Kompajler će odrediti dimenziju prebrojavanjem inicijalizacionih vrednosti
 i kreiraće niz koji je dovoljno dugačak da te vrednosti u njega stanu.
 Na primer, 
\end_layout

\begin_layout Standard

\family typewriter
\size small
int vrednosti[] = {2, 3, 4};
\end_layout

\begin_layout Standard
pravi niz brojeva sa tri elementa koji sadrže vrednosti 2, 3 i 4.
 Pošto dimenzija niza nije eksplicitno zadata, niz kao što je 
\family typewriter
vrednosti
\family default
 zove se niz bez dimenzije (unsized array).
 Nizovi bez dimenzija su prilično korisni.
 Na primer, pretpostavimo da koristimo inicijalizaciju niza koji treba da
 sadrži tabelu sa Web adresama, npr.
 
\end_layout

\begin_layout Standard

\family typewriter
\size small
char e1[15] = 
\begin_inset Quotes sld
\end_inset

www.google.com
\begin_inset Quotes srd
\end_inset

;
\end_layout

\begin_layout Standard

\family typewriter
\size small
char e2[15] = 
\begin_inset Quotes sld
\end_inset

www.amazon.com
\begin_inset Quotes srd
\end_inset

;
\end_layout

\begin_layout Standard

\family typewriter
\size small
char e3[18] = 
\begin_inset Quotes sld
\end_inset

www.microsoft.com
\begin_inset Quotes srd
\end_inset

;
\end_layout

\begin_layout Standard
Očigledno je da je vrlo zamorno ručno prebrojavati znakove da bi se odredila
 odgovarajuća dimenzija niza, a velika je i šansa da se pogreši u brojanju.
 Bolje je prepustiti kompajleru da prebrojava znakove:
\end_layout

\begin_layout Standard

\family typewriter
\size small
char e1[] = 
\begin_inset Quotes sld
\end_inset

www.google.com
\begin_inset Quotes srd
\end_inset

;
\end_layout

\begin_layout Standard

\family typewriter
\size small
char e2[] = 
\begin_inset Quotes sld
\end_inset

www.amazon.com
\begin_inset Quotes srd
\end_inset

;
\end_layout

\begin_layout Standard

\family typewriter
\size small
char e3[] = 
\begin_inset Quotes sld
\end_inset

www.microsoft.com
\begin_inset Quotes srd
\end_inset

;
\end_layout

\begin_layout Standard
Osim što je manje zamorna, inicijalizacija nizova bez dimenzija
\begin_inset Index idx
status open

\begin_layout Plain Layout
nizovi!inicijalizacija bez dimenzija
\end_layout

\end_inset

 omogućuje da se bilo koji string izmeni, a da se usput ne zaboravi na promenu
 dimenzije niza.
 Inicijalizacije nizova bez dimenzija nisu ograničene samo na jednodimenzionalne
 nizove.
 U slučaju višedimenzionalnih nizova, dozvoljeno je izostaviti (samo) prvu
 dimenziju.
 Na taj način mogu se napraviti tabele promenljivih dužina, tako da kompajler
 automatski odvoji dovoljno mesta u memoriji za njih.
 Na primer, ovde je niz 
\family typewriter
kvadrati
\family default
 deklarisan kao niz bez dimenzije:
\end_layout

\begin_layout LyX-Code

\size small
//niz koji sadrzi brojeve i njihove kvadrate
\end_layout

\begin_layout LyX-Code

\size small
int kvadrati[][2] = { 2, 4
\end_layout

\begin_layout LyX-Code

\size small
                      3, 9,
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
                   4, 16,
\end_layout

\begin_layout LyX-Code

\size small
                   5, 25 }
\end_layout

\end_deeper
\begin_layout Standard
Prednost ovakve deklaracije je u tome što se tabela može skraćivati ili
 produžavati bez menjanja dimenzija niza.
\end_layout

\begin_layout Section
Nizovi stringova
\end_layout

\begin_layout Standard
Specijalan oblik dvodimenzionalnog niza je 
\shape italic
niz stringova
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
niz stringova
\end_layout

\end_inset

.
 Takav niz se veoma često koristi u programiranju (npr.
 modul baza podataka koji tumači ulazne komande upoređuje ih sa nizom stringova
 koji sadrži važeće komande).
\end_layout

\begin_layout Standard
Da bi se napravio niz stringova u jeziku C++ koristi se dvodimenzionalni
 niz znakova, u kome dimenzija levog indeksa određuje broj stringova, a
 dimenzija desnog indeksa zadaje maksimalnu dužinu stringa koju može da
 sadrži (uključujući i nulu na kraju).
 Na primer, sledeća naredba deklariše i inicijalizuje niz od 7 stringova,
 od kojih svaki može da sadrži maksimalno 10 znakova (sa nulom na kraju
 kao jedanaestim znakom).
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
char daniUNedelji[7][11] = { 
\begin_inset Quotes sld
\end_inset

Ponedeljak
\begin_inset Quotes srd
\end_inset

, 
\begin_inset Quotes sld
\end_inset

Utorak
\begin_inset Quotes srd
\end_inset

, 
\begin_inset Quotes sld
\end_inset

Sreda
\begin_inset Quotes srd
\end_inset

, 
\begin_inset Newline newline
\end_inset

      
\begin_inset Quotes sld
\end_inset

Cetvrtak
\begin_inset Quotes srd
\end_inset

, 
\begin_inset Quotes sld
\end_inset

Petak
\begin_inset Quotes srd
\end_inset

, 
\begin_inset Quotes sld
\end_inset

Subota
\begin_inset Quotes srd
\end_inset

, 
\begin_inset Quotes sld
\end_inset

Nedelja
\begin_inset Quotes srd
\end_inset

 };
\end_layout

\begin_layout Standard
Pojedinačnim stringovima unutar niza pristupa se navođenjem samo levog indeksa:
\end_layout

\begin_layout Standard

\family typewriter
\size small
daniUNedelji[3] //cetvrtak
\end_layout

\begin_layout Standard
Da bi se pristupilo pojedinačnim znakovima unutar trećeg stringa, koristi
 se sledeća sintaksa:
\end_layout

\begin_layout Standard

\family typewriter
\size small
daniUNedelji[3][2] //slovo t u stringu cetvrtak
\end_layout

\begin_layout Standard
Sledeći program ilustruje kako se niz stringova može iskoristiti za pravljenje
 vrlo jednostavnog telefonskog imenika.
 Dvodimenzionalni niz sadrži parove imena i brojeva; da bi se prikazao broj,
 potrebno je uneti ime.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//jednostavan telefonski imenik
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char str[80]; 
\end_layout

\begin_layout LyX-Code

\size small
int i; 
\end_layout

\begin_layout LyX-Code

\size small
//definicija niza od 10 stringova 
\end_layout

\begin_layout LyX-Code

\size small
//u svaki moze da stane 79 znakova 
\end_layout

\begin_layout LyX-Code

\size small
char brojevi[10][80] = { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
"Pera", "065-2341123", 
\end_layout

\begin_layout LyX-Code

\size small
"Deki", "063-5654667", 
\end_layout

\begin_layout LyX-Code

\size small
"Sandra", "062-32563434", 
\end_layout

\begin_layout LyX-Code

\size small
"Laza", "061-3453453" 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Unesite ime:"; 
\end_layout

\begin_layout LyX-Code

\size small
cin >> str; 
\end_layout

\begin_layout LyX-Code

\size small
for(i=0;i<10;i+=2) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
if(!strcmp(brojevi[i], str)) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Broj je: " << brojevi[i+1] << endl; 
\end_layout

\begin_layout LyX-Code

\size small
break;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
if(i==10) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Broj nije pronadjen." << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite ime: Deki
\end_layout

\begin_layout Standard

\series bold
\size small
Broj je: 063-1123400
\end_layout

\begin_layout Standard

\series bold
\size small
Unesite ime: Filip
\end_layout

\begin_layout Standard

\series bold
\size small
Broj nije pronadjen.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Obratite pažnju na uslov poređenja u 
\family typewriter
for
\family default
 petlji: 
\family typewriter
if(!strcmp(brojevi[i], str))
\family default
.
 Funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
strcmp()
\end_layout

\end_inset

 
\family typewriter
strcmp()
\family default
 poredi dva znakovna niza, i ako ustanovi da su jednaki, vraća nulu.
 Zbog toga se u uslovu poređenja mora koristiti operator negacije (!).
 Ako se ustanovi da su string unesen preko tastature i neki element niza
 znakova sa parnim indeksom jednaki (parni indeksi zato što se poredi po
 imenima, a ne po brojevima), onda se dohvata sledeći element sa neparnim
 indeksom u naredbi 
\family typewriter
brojevi[i+1]
\family default
, a to je broj koji odgovara imenu.
 Ako se ime ne pronađe, indeks niza će biti 10 (obratite pažnju i da je
 brojač 
\family typewriter
for
\family default
 petlje 
\family typewriter
i
\family default
 deklarisan van petlje da bi bio dostupan i izvan nje).
\end_layout

\begin_layout Section
Pokazivači
\end_layout

\begin_layout Standard
Pokazivači
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači!definicija
\end_layout

\end_inset

 su jedna od najsnažnijih mogućnosti jezika C/C++, ali njihovo savladavanje
 je obično problematično, naročito za početnike u programiranju.
 Iako ih je lako pogrešno upotrebiti, oni su veoma bitni za programiranje
 u jeziku C++ jer omogućuju dinamičku alokaciju memorije i druge funkcionalnosti
 koje ćemo detaljno proučiti u nastavku knjige.
 U ovom poglavlju objasnićemo osnove rada sa pokazivačima.
\end_layout

\begin_layout Standard

\shape italic
Pokazivač
\shape default
 (pointer) je promenljiva koja sadrži memorijsku adresu.
 Svaka promenljiva ima adresu, a to je broj koji određuje njen položaj u
 radnoj memoriji računara (Slika 4.1).
 Najčešće se na adresi koju sadrži pokazivač nalazi neka druga promenljiva,
 pa se kaže da 
\begin_inset Quotes eld
\end_inset

pokazivač pokazuje na promenljivu
\begin_inset Quotes erd
\end_inset

.
 Na primer, ako x sadrži adresu y, kaže se da 
\begin_inset Quotes eld
\end_inset

x pokazuje na y
\begin_inset Quotes erd
\end_inset

.
 Pošto memorijska adresa nije običan ceo broj, ni pokazivač ne može biti
 predstavljen kao obična promenljiva, već se deklariše na poseban način:
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
\shape slanted
\size small
tip *promenljiva;
\end_layout

\begin_layout Standard
Ovde je 
\family typewriter
tip
\family default
 osnovni tip pokazivača, tj.
 tip podataka na koji on pokazuje.
 Na primer, ako želimo da deklarišemo promenljivu 
\family typewriter
ip
\family default
 kao pokazivač na ceo broj (tip 
\family typewriter
int
\family default
), upotrebićemo deklaraciju:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int *ip; //pokazivac na ceo broj
\end_layout

\begin_layout Standard
Kada se u naredbi deklaracije ispred imena promenljive nalazi zvezdica,
 ta promenljiva postaje pokazivač.
 
\end_layout

\begin_layout Standard
\align center

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 1
width "70text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Slike/Program4.39.png
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 4.1: Izgled memorije u računaru.
\end_layout

\begin_layout Subsection
Pokazivač NULL 
\end_layout

\begin_layout Standard
Kada se pokazivač deklariše, a pre nego što mu se dodeli adresa na koju
 će da pokazuje, on će sadržati proizvoljnu vrednost.
 Ako pokušate da upotrebite pokazivač pre nego što mu se dodeli vrednost,
 to će vrlo verovatno 
\begin_inset Quotes eld
\end_inset

srušiti
\begin_inset Quotes erd
\end_inset

 program jer može doći do nasumičnog prepisivanja sadržaja memorije.
 Iako ne postoji siguran način za zaobilaženje neinicijalizovanog pokazivača,
 C++ programeri su usvojili postupak kojim se izbegava većina grešaka vezana
 za pokazivače koji nisu inicijalizovani.
 Po tom dogovoru, ako pokazivač sadrži vrednost NULL
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači!NULL
\end_layout

\end_inset

 (nula), onda ne pokazuje ni na šta.
 Tako, ako se svim pokazivačima koji se trenutno ne koriste dodeli vrednost
 NULL i u programu se proverava se da li je sadrže, može se izbeći slučajno
 pogrešno korišćenje neinicijalizovanog pokazivača.
 To je dobra programerska praksa koje se treba pridržavati.
 Preprocesorska direktiva u zaglavlju 
\family typewriter
iostream
\family default
 definiše vrednost konstante 
\family typewriter
NULL
\family default
 kao 0 i ona se najčešće koristi za inicijalizaciju pokazivača koji ne pokazuju
 ni na šta.
 Sledeći kôd proverava da li je vrednost pokazivača NULL:
\end_layout

\begin_layout LyX-Code

\size small
int *pbroj;
\end_layout

\begin_layout LyX-Code

\size small
//pokazivac koji ne pokazuje ni na sta
\end_layout

\begin_layout LyX-Code

\size small
pbroj = NULL;
\end_layout

\begin_layout LyX-Code

\size small
pbroj = 0; //isto sto i pbroj = NULL
\end_layout

\begin_layout LyX-Code

\size small
//provera da li pokazivac pokazuje na nesto
\end_layout

\begin_layout LyX-Code

\size small
if(!pbroj)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << 
\begin_inset Quotes sld
\end_inset

pbroj ne pokazuje ni na sta
\begin_inset Quotes srd
\end_inset

 << endl;
\end_layout

\end_deeper
\begin_layout Subsection
Operacije sa pokazivačima
\end_layout

\begin_layout Standard
Postoje dva specijalna operatora koji se koriste sa pokazivačima: * i &.
 Operator adresiranja
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači!operator &
\end_layout

\end_inset

 (&) je unarni operator koji vraća memorijsku adresu svog operanda.
 Na primer, naredba 
\family typewriter
pbroj = &broj;
\family default
 pokazivačkoj promenljivoj 
\family typewriter
pbroj
\family default
 dodeljuje memorijsku adresu promenljive 
\family typewriter
broj
\family default
, odnosno adresu lokacije u memoriji na kojoj se nalazi promenljiva 
\family typewriter
broj
\family default
.
 Dakle, operator & daje adresu promenljive ispred koje se nalazi.
 
\end_layout

\begin_layout Standard

\family typewriter
\size small
int broj;
\end_layout

\begin_layout Standard

\family typewriter
\size small
int *pbroj;
\end_layout

\begin_layout Standard

\family typewriter
\size small
//vrednost pokazivaca je adresa promenljive
\end_layout

\begin_layout Standard

\family typewriter
\size small
pbroj = &broj;
\end_layout

\begin_layout Standard
Da bismo bolje razumeli ovu dodelu, pretpostavimo da se promenljiva 
\family typewriter
broj
\family default
 nalazi na adresi 1008 i da ima vrednost 99; nakon dodele pomoću operatora
 & iz prethodnog primera, promenljiva 
\family typewriter
pbroj
\family default
 imaće vrednost 1008 (tj.
 imaće vrednost adrese u memoriji na kojoj se nalazi promenljiva 
\family typewriter
broj
\family default
), kao što je ilustrovano na Slici 4.2.
\end_layout

\begin_layout Standard
\align center

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 1
width "50text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Slike/Program4.25.png
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 4.2: Simbolički prikaz operatora adresiranja.
\end_layout

\begin_layout Standard
Operator indirekcije
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači!operator *
\end_layout

\end_inset

 (*) je takođe unarni, a daje vrednost promenljive koja se nalazi na adresi
 koju sadrži operand.
 Ovaj operator se zove i operator dereferenciranja jer vraća vrednost promenljiv
e na koju pokazuje pokazivač.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size small
int broj = 99;
\end_layout

\begin_layout Standard

\family typewriter
\size small
int vrednost;
\end_layout

\begin_layout Standard

\family typewriter
\size small
int *pbroj;
\end_layout

\begin_layout Standard

\family typewriter
\size small
pbroj = &broj; //pbroj pokazuje na broj
\end_layout

\begin_layout Standard

\family typewriter
\size small
vrednost = *pbroj; //vrednost je 99
\end_layout

\begin_layout Standard
Ako promenljiva 
\family typewriter
broj
\family default
 ima vrednost 99 kao u prethodnom primeru, onda se pomoću operatora * iz
 memorije dohvata vrednost na koju pokazuje 
\family typewriter
pbroj
\family default
, a to je u našem primeru 99.
 
\end_layout

\begin_layout Standard
Oba pokazivačka operatora (& i *) su višeg prioriteta od svih aritmetičkih
 operatora osim unarnog minusa.
 Korišćenje pokazivača često se zove i indirekcija jer se promenljivoj pristupa
 indirektno, tj.
 preko pokazivača.
\end_layout

\begin_layout LyX-Code

\size small
int *pbroj = NULL; 
\end_layout

\begin_layout LyX-Code

\size small
int broj1 = 55, broj2 = 99; 
\end_layout

\begin_layout LyX-Code

\size small
pbroj = &broj1; //pbroj sada pokazuje na broj1 
\end_layout

\begin_layout LyX-Code

\size small
(*pbroj)+=11; //broj 1 je sada 66 
\end_layout

\begin_layout LyX-Code

\size small
pbroj = &broj2; //pbroj sada pokazuje na broj2 
\end_layout

\begin_layout LyX-Code

\size small
broj1 = (*pbroj) * 10; //broj1 postaje 990
\end_layout

\begin_layout Subsection
Osnovni tip pokazivača
\end_layout

\begin_layout Standard
U prethodnom primeru videli smo da je promenljivoj moguće dodeliti vrednost
 indirektno, preko pokazivača.
 Međutim, kako C++ zna koliko bajtova treba da kopira sa adrese na koju
 pokazuje pokazivač? Osnovni tip
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači!osnovni tip
\end_layout

\end_inset

 pokazivača određuje tip podataka sa kojima on može da radi.
 U prethodnim primerima koristili smo pokazivače na cele brojeve (tip 
\family typewriter
int*
\family default
).
 U tom slučaju, ako pretpostavimo da tip 
\family typewriter
int
\family default
 zauzima 4 bajta, kopiraće se 4 bajta podataka počev od adrese na koju pokazuje
 pokazivač i dodeliće se odgovarajućoj promenljivoj.
 Kada bismo koristili pokazivače na double (tip 
\family typewriter
double*
\family default
), kopiralo bi se 8 bajtova, jer je toliko potrebno za tip 
\family typewriter
double
\family default
.
 
\end_layout

\begin_layout Standard
Važno je obezbediti da pokazivač uvek pokazuje na odgovarajući tip podataka.
 Ako se pokazivač deklariše kao tip 
\family typewriter
int*
\family default
, kompajler pretpostavlja da svaki objekat na koji on pokazuje mora biti
 ceo broj.
 Ako nije tako, nevolja je na vidiku.
 Na primer, sledeći kôd je pogrešan: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
int *p;
\end_layout

\begin_layout Standard

\family typewriter
\size small
double f;
\end_layout

\begin_layout Standard

\family typewriter
\size small
p = &f; //greska!
\end_layout

\begin_layout Standard
jer se pokazivač na tip 
\family typewriter
double
\family default
 ne može dodeliti pokazivaču na 
\family typewriter
int
\family default
.
 Odnosno, &f kreira pokazivač na 
\family typewriter
double
\family default
, ali je 
\family typewriter
p
\family default
 pokazivač na 
\family typewriter
int
\family default
.
 Iako dva pokazivača moraju da pokazuju na isti tip da bi se mogli dodeljivati
 jedan drugome, to ograničenje se može zaobići konverzijom tipova (iako
 to skoro nikad nije pametno, jer osnovni tip pokazivača, tj.
 tip objekta na koji treba da pokazuje određuje kako će se kompajler ponašati
 prema stvarnim objektima na koje pokazuje).
 
\end_layout

\begin_layout Subsection
Dodela vrednosti promenljivoj preko pokazivača
\end_layout

\begin_layout Standard
Pokazivač se može koristiti sa leve strane operacije dodele za dodelu vrednosti
 sa desne strane lokaciji na koju pokazivač pokazuje.
 Ako je 
\family typewriter
p
\family default
 pokazivač na 
\family typewriter
int
\family default
, onda sledeća naredba dodeljuje vrednost 101 lokaciji, tj.
 promenljivoj na koju pokazuje 
\family typewriter
p
\family default
: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
*p = 101; 
\end_layout

\begin_layout Standard
Za inkrementiranje ili dekrementiranje vrednosti na koju pokazuje pokazivač,
 može se upotrebiti naredba
\end_layout

\begin_layout Standard

\family typewriter
\size small
(*p)++; 
\end_layout

\begin_layout Standard
Zagrade su neophodne jer je operator * nižeg prioriteta od operatora ++.Sledeći
 primer ilustruje dodelu vrednosti promenljivoj preko pokazivača.
 
\end_layout

\begin_layout LyX-Code

\size small
int *pbroj = NULL;
\end_layout

\begin_layout LyX-Code

\size small
int broj = 10; 
\end_layout

\begin_layout LyX-Code

\size small
pbroj = &broj; //pbroj pokazuje na broj 
\end_layout

\begin_layout LyX-Code

\size small
cout << broj << endl; //ispisuje 10 
\end_layout

\begin_layout LyX-Code

\size small
(*pbroj)++; //broj se inkrementira preko pokazivaca 
\end_layout

\begin_layout LyX-Code

\size small
cout << broj << endl; //ispisuje 11
\end_layout

\begin_layout Subsection
Pokazivačka aritmetika
\end_layout

\begin_layout Standard
Pokazivači se mogu koristiti u većini C++ izraza, ali uz poštovanje nekih
 posebnih pravila.
 Sa pokazivačima se koriste samo četiri aritmetička operatora
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači!aritmetika
\end_layout

\end_inset

: ++, – –, + i –.
 Rezultat operacija sa pokazivačima direktno zavisi od njegovog osnovnog
 tipa.
\end_layout

\begin_layout Standard
Pretpostavimo da je 
\family typewriter
p
\family default
 pokazivač na 
\family typewriter
int
\family default
 čija je trenutna vrednost 2000 (tj.
 sadrži adresu 2000).
 Pod pretpostavkom da tip 
\family typewriter
int
\family default
 zauzima 4 bajta, nakon izraza 
\family typewriter
p++;
\family default
 sadržaj pokazivača 
\family typewriter
p
\family default
 biće 2004, a ne 2001, zato što kad god se 
\family typewriter
p
\family default
 inkrementira, pokazuje na sledeći ceo broj.
 Isto važi i za dekrementiranje; ako 
\family typewriter
p
\family default
 ima vrednost 2000, nakon naredbe 
\family typewriter
p--;
\family default
 imaće vrednost 1996.
 
\end_layout

\begin_layout Standard
Kad god se pokazivač inkrementira, pokazivaće na lokaciju sledećeg elementa
 svog osnovnog tipa.
 Ako se radi o pokazivaču na znakove, operacije inkrementiranja i dekrementiranj
a izgledaće 
\begin_inset Quotes eld
\end_inset

uobičajeno
\begin_inset Quotes erd
\end_inset

 jer tip 
\family typewriter
char
\family default
 zauzima jedan bajt (Slika 4.3).
 
\end_layout

\begin_layout Standard
Na pokazivače se takođe može primenjivati sabiranje i oduzimanje.
 Na primer, izraz 
\family typewriter
p = p + 9;
\family default
 pomera 
\family typewriter
p
\family default
 na deveti element njegovog osnovnog tipa u odnosu na onaj na koji trenutno
 pokazuje.
 
\end_layout

\begin_layout Subsection
Pokazivači i nizovi
\end_layout

\begin_layout Standard
U jeziku C++ pokazivači i nizovi
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači! i nizovi
\end_layout

\end_inset

 su blisko povezani, i često se mogu uporedo koristiti.
 Proučimo sledeći primer:
\end_layout

\begin_layout Standard

\family typewriter
\size small
char str[80];
\end_layout

\begin_layout Standard

\family typewriter
\size small
char *p;
\end_layout

\begin_layout Standard

\family typewriter
\size small
p = str;
\end_layout

\begin_layout Standard
\align center

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 1
width "40text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Slike/Program4.34.png
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 4.3: Aritmetičke operacije sa pokazivačima zavise od njegovog osnovnog
 tipa.
\end_layout

\begin_layout Standard
Ovde je 
\family typewriter
str
\family default
 niz od 80 znakova, a 
\family typewriter
p
\family default
 je pokazivač na znakove.
 U trećem redu, pokazivaču 
\family typewriter
p
\family default
 se dodeljuje adresa prvog elementa niza 
\family typewriter
str
\family default
 (odnosno, posle ove dodele, 
\family typewriter
p
\family default
 će pokazivati na 
\family typewriter
str[0]
\family default
).
 To je zato što u je jeziku C++ ime niza (bez indeksa) zapravo pokazivač
 na prvi element niza.
 Treba ipak zapamtiti da je ime niza konstantan pokazivač i nijedna naredba
 ne može da mu promeni vrednost (npr.
 ne može se pomeriti inkrementiranjem).
 
\end_layout

\begin_layout Standard
Kad god se u izrazima koristi ime niza bez indeksa, dobija se pokazivač
 na prvi element niza.
 Pošto nakon dodele 
\family typewriter
p = str;
\family default
 pokazivač 
\family typewriter
p
\family default
 pokazuje na početak niza 
\family typewriter
str
\family default
, nadalje 
\family typewriter
p
\family default
 može da se koristi za pristup elementima niza 
\family typewriter
str
\family default
.
 Na primer, ako želimo da pristupimo petom elementu niza 
\family typewriter
str
\family default
, možemo da upotrebimo sintaksu 
\family typewriter
str[4]
\family default
 ili 
\family typewriter
*(p+4)
\family default
.
 Pokazivaču se dodaje 4 jer trenutno pokazuje na prvi element niza 
\family typewriter
str
\family default
.
\end_layout

\begin_layout Standard
Zagrade oko izraza 
\family typewriter
p+4
\family default
 su neophodne zato što je operator * većeg prioriteta od operatora +.
 Kada ih ne bi bilo, prvo bi se pronašla vrednost na koju pokazuje 
\family typewriter
p
\family default
 (prvi element niza), a zatim bi se ona sabrala sa 4.
\end_layout

\begin_layout Standard
C++ tako nudi dva načina za pristupanje elementima niza: pokazivačku aritmentiku
 i indeksiranje.
 Pokazivačka aritmetika je često brža od indeksiranja, naročito ako se elementim
a niza pristupa redom.
 Obično je potrebno više mašinskih instrukcija za indeksiranje niza nego
 za rad preko pokazivača.
 Zbog toga se u profesionalno napisanom C++ kôdu češće koriste pokazivači.
 Početnicima je obično lakše da koriste indeksiranje dok u potpunosti ne
 savladaju rad sa pokazivačima.
\end_layout

\begin_layout Standard
Kao što smo upravo videli, nizu je moguće pristupati preko pokazivačke aritmetik
e.
 Ali, važi i obrnuto: pokazivač je moguće indeksirati kao da se radi o nizu.
 Ako je 
\family typewriter
p
\family default
 pokazivač na prvi element niza znakova, onda je naredba 
\family typewriter
p[i]
\family default
 funkcionalno identična sa 
\family typewriter
*(p+i)
\family default
.
 
\end_layout

\begin_layout Standard
Kao primer navodimo program koji mala slova stringa prevodi u velika i obrnuto.
 U prvom slučaju program je napisan korišćenjem tehnike indeksiranja nizova:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char str[] = "Ovo Je Test"; 
\end_layout

\begin_layout LyX-Code

\size small
for(int i=0; str[i]; i++) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
if(isupper(str[i])) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
str[i] = tolower(str[i]); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else if(islower(str[i])) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
str[i] = toupper(str[i]); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << str << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\paragraph_spacing single
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
oVO jE tEST
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Program koristi bibliotečke funkcije 
\family typewriter
isupper
\begin_inset Index idx
status open

\begin_layout Plain Layout
isupper()
\end_layout

\end_inset


\family default
 i 
\family typewriter
islower
\begin_inset Index idx
status open

\begin_layout Plain Layout
islower()
\end_layout

\end_inset


\family default
 da bi odredio da li je znak malo ili veliko slovo.
 Funkcija 
\family typewriter
isupper
\family default
 vraća 
\family typewriter
true
\family default
 kada joj je argument veliko slovo, a 
\family typewriter
islower
\family default
 vraća 
\family typewriter
true
\family default
 kada je argument malo slovo.
 U 
\family typewriter
for
\family default
 petlji 
\family typewriter
str
\family default
 se indeksira, proverava se da li je znak malo ili veliko slovo i obrće
 se.
 Petlja se završava kada se dođe do kraja stringa, tj.
 do nule na kraju niza; pošto se 0 tumači kao 
\family typewriter
false
\family default
, petlja se prekida.
\end_layout

\begin_layout Standard
Isti ovaj program napisan pomoću pokazivača izgleda ovako:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char str[] = "Ovo Je Test";
\end_layout

\begin_layout LyX-Code
char *p = str;
\end_layout

\begin_layout LyX-Code

\size small
while(*p) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
if(isupper(*p)) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
*p = tolower(*p); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else if(islower(*p)) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
*p = toupper(*p); 
\end_layout

\end_deeper
\begin_layout LyX-Code
p++;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
cout << str << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
U ovoj verziji, 
\family typewriter
p
\family default
 se postavlja na početak niza 
\family typewriter
str
\family default
.
 Zatim se unutar petlje 
\family typewriter
while
\family default
 slovo na koje pokazuje
\family typewriter
 p
\family default
 proverava i menja, a nakon toga se 
\family typewriter
p
\family default
 inkrementira.
 Petlja se završava kada
\family typewriter
 p
\family default
 stigne do znaka nula kojim se završava niz 
\family typewriter
str
\family default
.
\end_layout

\begin_layout Section
Dinamička alokacija memorije
\end_layout

\begin_layout Standard
Promenljive se mogu kreirati i uništavati i tokom izvršavanja programa.
 Često se dešava da ne znamo tačno koliko nam je promenljivih potrebno.
 Pretpostavimo na primer da hoćemo da napišemo program koji računa srednju
 ocenu proizvoljnog broja testova.
 Kako ćemo smestiti rezultate pojedinačnih testova u memoriju ako ne znamo
 tačno koliko ima testova? C++ omogućuje 
\begin_inset Quotes eld
\end_inset

usputno
\begin_inset Quotes erd
\end_inset

 definisanje promenljivih, što se zove dinamička alokacija memorije, a moguće
 je samo uz korišćenje pokazivača.
\end_layout

\begin_layout Standard

\shape italic
Dinamička alokacija memorije
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dinamička alokacija memorije
\end_layout

\end_inset

 znači da program tokom izvršavanja traži od računara da odvoji deo neiskorišćen
e memorije da bi u njega smestio promenljive određenog tipa.
 Pretpostavimo da nam je potrebna promenljiva tipa
\family typewriter
 int
\family default
.
 Program će od računara zatražiti da odvoji prostor za ceo broj, a računar
 će programu vratiti početnu memorijsku adresu gde će broj biti smešten.
 Memoriji koja je odvojena (alocirana) program može da pristupi samo preko
 adrese, pa je za njeno korišćenje neophodan pokazivač.
\end_layout

\begin_layout Standard
Dinamička alokacija se često koristi za podršku strukturama kao što su povezane
 liste, stabla i sl.
 Naravno, dinamičku alokaciju možete da upotrebite kad god vam se učini
 da bi bila pogodna, i ona se koristi u većini realnih programa.
 Memorija koja se dinamički alocira uzima se iz oblasti koja se zove hrpa
 (heap).
 Hrpa se razlikuje od drugih zona memorije koje koristi C++ program, kao
 što su memorija za statičke i lokalne promenljive (Slika 4.4).
 Ako se promenljiva deklariše kao statička ili globalna (deklarisanjem van
 svih funkcija), prostor za promenljivu se alocira iz zone globalnih podataka,
 i to pre nego što izvršavanje programa počne.
 Tek kada se funkcija 
\family typewriter
main()
\family default
 završi, računar dealocira prostor za statičke i globalne promenljive.
 Automatska (lokalna) promenljiva, tj.
 promenljiva deklarisana unutar bloka, kreira se u zoni zvanoj stek kada
 program ulazi u blok, a uništava se kada program napušta blok.
 Prostor za lokalne promenljive se alocira i dealocira tokom izvršavanja
 programa, i to se dešava automatski (programer nema kontrolu nad alokacijom
 i dealokacijom lokalnih promenljivih).
\end_layout

\begin_layout Standard
\align center

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 1
width "80text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Slike/Program4.40.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 4.4: Simbolički prikaz korišćenja memorije u C++ programima.
\end_layout

\begin_layout Standard
Dinamičko alociranje memorije zahteva se operatorom
\begin_inset Index idx
status open

\begin_layout Plain Layout
dinamička alokacija memorije!operator 
\family typewriter
new
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!
\family typewriter
new
\end_layout

\end_inset

 
\family typewriter
new
\family default
.
 Operator 
\family typewriter
new
\family default
 alocira memoriju i vraća pokazivač na promenljivu.
 Operator 
\family typewriter
delete
\family default
 oslobađa memoriju koja je prethodno alocirana pomoću operatora 
\family typewriter
new
\family default
.
 Opšta sintaksa ovih operatora je:
\end_layout

\begin_layout Standard
\paragraph_spacing single

\family typewriter
\shape slanted
pokazivac = new tip;
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
delete pokazivac;
\end_layout

\begin_layout Standard

\family typewriter
pokazivac
\family default
 je promenljiva koja prihvata adresu alocirane promenljive.
 Na primer, ako želimo da alociramo prostor za jednu celobrojnu promenljivu,
 to ćemo učiniti naredbom:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int *p = new int;
\end_layout

\begin_layout Standard
Dinamičko alociranje pojedinačnih promenljivih nema mnogo smisla, već se
 ono prvenstveno koristi za dinamičko kreiranje nizova.
 Niz od 100 celih brojeva može se dinamički alocirati naredbom:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int *p = new int[100];
\end_layout

\begin_layout Standard
Ako nema dovoljno memorije koja bi se alocirala, operator 
\family typewriter
new
\family default
 vraća vrednost 0 (
\family typewriter
NULL
\family default
), pa u programu to treba uvek proveriti:
\end_layout

\begin_layout LyX-Code

\size small
int *p = new int[100];
\end_layout

\begin_layout LyX-Code

\size small
if(!p) //isto sto i if (p == NULL)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << 
\begin_inset Quotes sld
\end_inset

greska u alociranju memorije!
\begin_inset Quotes srd
\end_inset

;
\end_layout

\end_deeper
\begin_layout Standard
Kada program završi sa korišćenjem dinamički alocirane memorije, treba je
 osloboditi pomoću operatora
\begin_inset Index idx
status open

\begin_layout Plain Layout
dinamička alokacija memorije!operator 
\family typewriter
delete
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!
\family typewriter
delete
\end_layout

\end_inset

 
\family typewriter
delete
\family default
.
 Operand za delete mora da bude pokazivač koji je korišćen za alokaciju
 operatorom 
\family typewriter
new
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
\size small
delete p; //ako p pokazuje na promenljivu
\end_layout

\begin_layout Standard

\family typewriter
\size small
delete [] p; //ako p pokazuje na niz
\end_layout

\begin_layout Section*
Pitanja
\end_layout

\begin_layout Standard
1.
 Indeks prvog elementa niza u jeziku C+ + je: 
\end_layout

\begin_layout Standard
a) 0
\end_layout

\begin_layout Standard
b) 1
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
2.
 Jezik C++ proverava granice niza.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset

3.
 Naredba 
\family typewriter
int broj[10]={0};
\family default
 
\end_layout

\begin_layout Standard
a) inicijalizuje sve elemente niza na vrednost 0
\end_layout

\begin_layout Standard
b) predstavlja prazan niz
\end_layout

\begin_layout Standard
c) deklariše samo jedan element u nizu 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
4.
 Naredba 
\family typewriter
cout << niz[2];
\family default
 
\end_layout

\begin_layout Standard
a) prikazuje vrednost trećeg elementa niza
\end_layout

\begin_layout Standard
b) prikazuje vrednost drugog elementa niza
\end_layout

\begin_layout Standard
c) prikazuje vrednost indeksa drugog elementa niza 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
5.
 Naredba 
\family typewriter
cin >> niz[1];
\family default
 
\end_layout

\begin_layout Standard
a) prikazuje vrednost prvog elementa niza
\end_layout

\begin_layout Standard
b) prikazuje vrednost drugog elementa niza
\end_layout

\begin_layout Standard
c) prihvata vrednost za drugi element niza sa standardnog ulaza 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
6.
 Niz je skup objekata: 
\end_layout

\begin_layout Standard
a) različitog tipa
\end_layout

\begin_layout Standard
b) istog tipa
\end_layout

\begin_layout Standard
c) mešovitog tipa 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
7.
 Niz po imenu brojevi koji sadrži 31 element tipa short int deklariše se
 kao: 
\end_layout

\begin_layout Standard
a) 
\family typewriter
short int brojevi[31];
\end_layout

\begin_layout Standard
b) 
\family typewriter
brojevi short[31];
\end_layout

\begin_layout Standard
c) 
\family typewriter
short int brojevi(31);
\end_layout

\begin_layout Standard
d) 
\family typewriter
short brojevi[31]; 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
8.
 Koje je ime trećeg elementa u nizu a?
\end_layout

\begin_layout Standard
a) a(2)
\end_layout

\begin_layout Standard
b) a[2] 
\end_layout

\begin_layout Standard
c) a[3] 
\end_layout

\begin_layout Standard
d) a(3) 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
9.
 Naredba 
\family typewriter
for
\family default
 mora se upotrebiti za inicijalizaciju svih elemenata niza na 0.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
10.
 Za sabiranje elemenata dvodimenzionalnog niza moraju se upotrebiti ugnježđene
 for petlje.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
11.
 C-string je niz znakova koji: 
\end_layout

\begin_layout Standard
a) počinje od početka reda
\end_layout

\begin_layout Standard
b) završava se znakom 
\backslash
0
\end_layout

\begin_layout Standard
c) ima najmanje jedan znak 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
12.
 Standardna biblioteka funkcija koje rade sa C stringovima je: 
\end_layout

\begin_layout Standard
a) 
\family typewriter
iostream
\end_layout

\begin_layout Standard
b) 
\family typewriter
cstdlib
\end_layout

\begin_layout Standard
c) 
\family typewriter
cstring
\family default
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
13.
 Funkcija 
\family typewriter
strcmp
\family default
: 
\end_layout

\begin_layout Standard
a) komprimuje niz
\end_layout

\begin_layout Standard
b) poredi dva stringa
\end_layout

\begin_layout Standard
c) kompajlira niz
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
14.
 Funkcija 
\family typewriter
tolower(ch)
\family default
: 
\end_layout

\begin_layout Standard
a) ispisuje znak na ekranu malim fontom
\end_layout

\begin_layout Standard
b) konvertuje znak u malo slovo
\end_layout

\begin_layout Standard
c) konvertuje znak u veliko slovo 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
15.
 Funkcija 
\family typewriter
toupper(ch)
\family default
: 
\end_layout

\begin_layout Standard
a) ispisuje znak na ekranu većim fontom
\end_layout

\begin_layout Standard
b) konvertuje znak u malo slovo
\end_layout

\begin_layout Standard
c) konvertuje znak u veliko slovo 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
16.
 Kada ustanovi da su dva stringa jednaka, funkcija strcmp vraća: 
\end_layout

\begin_layout Standard
a) 0
\end_layout

\begin_layout Standard
b) 1
\end_layout

\begin_layout Standard
c) pozitivan broj
\end_layout

\begin_layout Standard
d) negativan broj
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
17.
 Dimenzija niza znakova u koji treba da stane string 
\begin_inset Quotes eld
\end_inset

singidunum
\begin_inset Quotes erd
\end_inset

 je: 
\end_layout

\begin_layout Standard
a) 9
\end_layout

\begin_layout Standard
b) 10
\end_layout

\begin_layout Standard
c) 11
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
18.
 Funkcija koja sa tastature učitava niz znakova koji sadrži razmake je:
 
\end_layout

\begin_layout Standard
a) 
\family typewriter
cin
\end_layout

\begin_layout Standard
b) 
\family typewriter
gets
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
19.
 Funkcija koja vraća dužinu stringa je:
\end_layout

\begin_layout Standard
a) 
\family typewriter
strcpy
\end_layout

\begin_layout Standard
b) 
\family typewriter
strlen
\end_layout

\begin_layout Standard
c) 
\family typewriter
strcmp
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
20.
 String konstanta se piše pod navodnicima.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
21.
 Naredba 
\family typewriter
str[]=
\begin_inset Quotes srd
\end_inset

nizZnakova
\begin_inset Quotes srd
\end_inset

;
\family default
 je ispravna.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
22.
 Pokazivač je promenljiva: 
\end_layout

\begin_layout Standard
a) čija je vrednost adresa druge promenljive
\end_layout

\begin_layout Standard
b) koja pokazuje na funkciju
\end_layout

\begin_layout Standard
c) koja pokazuje na kraj programa 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
23.
 Svakom bajtu u memoriji dodeljuje se jedinstvena adresa.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
24.
 Ime niza je pokazivač na:
\end_layout

\begin_layout Standard
a) sve članove niza
\end_layout

\begin_layout Standard
b) veličinu niza 
\end_layout

\begin_layout Standard
c) prvi element niza 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
25.
 Adresa na koju pokazuje ime niza može se promeniti.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
26.
 Gde je greška u sledećem delu kôda ? 
\end_layout

\begin_layout Standard

\family typewriter
int* p = &i; 
\end_layout

\begin_layout Standard

\family typewriter
int i; 
\end_layout

\begin_layout Standard
a) u prvom redu
\end_layout

\begin_layout Standard
b) u drugom redu
\end_layout

\begin_layout Standard
c) u redosledu deklarisanja promenljivih 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
27.
 Na šta pokazuje pokazivač ako ima vrednost 0? 
\end_layout

\begin_layout Standard
a) na nultu memorijsku lokaciju
\end_layout

\begin_layout Standard
b) na prvi član niza
\end_layout

\begin_layout Standard
c) ni na šta 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
28.
 Šta radi sledeći deo koda? 
\end_layout

\begin_layout Standard

\family typewriter
int a[3]={1,2,3}; 
\end_layout

\begin_layout Standard

\family typewriter
int i; 
\end_layout

\begin_layout Standard

\family typewriter
for(i=0;i<3;++i) 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \qquad{}
\end_inset

cout<<*(a+i); 
\end_layout

\begin_layout Standard
a) sabira članove niza
\end_layout

\begin_layout Standard
b) ispisuje vrednosti pokazivača na članove niza
\end_layout

\begin_layout Standard
c) ispisuje članove niza
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
29.
 Pokazivač može da pokazuje ni na šta.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
30.
 Ako želim da pokazivač p pokazuje na promenljivu x, naredba kojom ću to
 postići je: 
\end_layout

\begin_layout Standard
a) 
\family typewriter
p=x;
\end_layout

\begin_layout Standard
b) 
\family typewriter
p=&x;
\end_layout

\begin_layout Standard
c) 
\family typewriter
p=*x;
\end_layout

\begin_layout Standard
d) 
\family typewriter
*p=x;
\family default
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
31.
 Šta će se ispisati na ekranu posle sledećih naredbi? 
\end_layout

\begin_layout Standard

\family typewriter
int *p; 
\end_layout

\begin_layout Standard

\family typewriter
int x = 100; 
\end_layout

\begin_layout Standard

\family typewriter
p=&x; 
\end_layout

\begin_layout Standard

\family typewriter
cout <<(*p);
\family default
 
\end_layout

\begin_layout Standard
a) 0
\end_layout

\begin_layout Standard
b) 100
\end_layout

\begin_layout Standard
c) memorijska adresa promenljive x
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
32.
 Kolika je vrednost promenljive x nakon sledećih naredbi? 
\end_layout

\begin_layout Standard

\family typewriter
int *p, x; 
\end_layout

\begin_layout Standard

\family typewriter
x=100; 
\end_layout

\begin_layout Standard

\family typewriter
p = &x; 
\end_layout

\begin_layout Standard

\family typewriter
p++; 
\end_layout

\begin_layout Standard
a) 100
\end_layout

\begin_layout Standard
b) 101
\end_layout

\begin_layout Standard
c) 104
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
33.
 Kolika je vrednost promenljive x nakon sledećih naredbi? 
\end_layout

\begin_layout Standard

\family typewriter
int *p, x; 
\end_layout

\begin_layout Standard

\family typewriter
x=100; 
\end_layout

\begin_layout Standard

\family typewriter
p = &x; 
\end_layout

\begin_layout Standard

\family typewriter
(*p)++; 
\end_layout

\begin_layout Standard
a) 100
\end_layout

\begin_layout Standard
b) 101
\end_layout

\begin_layout Standard
c) 104
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
34.
 Ako je 
\family typewriter
brojevi
\family default
 ime niza, onda se 
\family typewriter
brojevi[2]
\family default
 preko pokazivača može napisati kao:
\end_layout

\begin_layout Standard
a) 
\family typewriter
*(brojevi+2)
\end_layout

\begin_layout Standard
b) 
\family typewriter
&(brojevi+2)
\end_layout

\begin_layout Standard
c) 
\family typewriter
brojevi+2
\family default
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
35.
 Moguće je definisati niz pokazivača.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
36.
 U radu sa pokazivačima koriste se operatori: 
\end_layout

\begin_layout Standard
a) & 
\end_layout

\begin_layout Standard
b) .
 
\end_layout

\begin_layout Standard
c) * 
\end_layout

\begin_layout Standard
d) && 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
37.
 Jedini ceo broj koji se može direktno dodeliti pokazivaču je 0.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
38.
 Povratna vrednost operatora 
\family typewriter
new
\family default
 je:
\end_layout

\begin_layout Standard
a) pokazivač
\end_layout

\begin_layout Standard
b) 
\family typewriter
void
\end_layout

\begin_layout Standard
c) 
\family typewriter
int
\end_layout

\begin_layout Standard
d) ništa od navedenog 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
39.
 Operator 
\family typewriter
delete
\family default
 oslobađa memoriju koju je prethodno rezervisao operator 
\family typewriter
new
\family default
.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
40.
 Nemoguće je kreirati promenljive tokom izvršavanja programa.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Chapter
Funkcije
\end_layout

\begin_layout Standard

\shape italic
Funkcija
\shape default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!deklaracija 
\end_layout

\end_inset

je potprogram koji sadrži nekoliko C++ naredbi i izvodi određeni zadatak.
 Svi programi koje smo dosad pisali koristili su jednu funkciju 
\family typewriter
main()
\family default
.
 Funkcije su gradivni blokovi jezika C++ jer je program zapravo skup funkcija,
 a sve naredbe koje nešto "rade" nalaze se u funkcijama.
 Dakle, funkcije sadrže naredbe koje su izvršni deo programa.
 Iako veoma jednostavni programi kao što su primeri u ovoj knjizi imaju
 samo funkciju 
\family typewriter
main()
\family default
, većina komercijalnih programa ih ima na stotine.
 Sve C++ funkcije imaju isti oblik: 
\end_layout

\begin_layout LyX-Code

\shape slanted
povratni_tip ime (lista parametara) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
// telo funkcije 
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
}
\end_layout

\begin_layout Standard

\family typewriter
Povratni_tip
\family default
 zadaje tip podataka koje funkcija vraća, što može da bude bilo koji tip
 podataka osim niza.
 Ako funkcija ne vraća nikakvu vrednost, njen povratni tip mora da bude
 deklarisan kao 
\family typewriter
void
\family default
.
 Ime funkcije može da bude bilo koji važeći identifikator koji se već ne
 koristi u programu.
 Lista parametara je niz parova tip - identifikator razdvojenih zarezima.
 Parametri
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!parametri
\end_layout

\end_inset

 su promenljive koje prihvataju vrednosti stvarnih argumenata koji se prosleđuju
 funkciji prilikom njenog pozivanja.
 Ako funkcija nema parametre, onda je lista parametara prazna.
 Telo funkcije okružuju vitičaste zagrade, a čine ga naredbe koje definišu
 šta funkcija radi.
 Funkcija se završava i vraća u deo kôda iz koga je pozvana kada izvršavanje
 stigne do zatvorene zagrade.
\end_layout

\begin_layout Standard
Pošto su sve funkcije istog oblika, one liče na funkciju 
\family typewriter
main()
\family default
 koju smo već koristili.
 Sledeći primer sadrži dve funkcije: 
\family typewriter
main()
\family default
 i 
\family typewriter
funkcija()
\family default
.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//prototip funkcije
\end_layout

\begin_layout LyX-Code

\size small
void funkcija(); 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "u funkciji main" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
funkcija(); //poziv funkcije 
\end_layout

\begin_layout LyX-Code

\size small
cout << "ponovo u mainu" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "u funkciji" << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
u funkciji main
\end_layout

\begin_layout Standard

\series bold
\size small
u funkciji
\end_layout

\begin_layout Standard

\series bold
\size small
ponovo u mainu
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Izvršavanje započinje u funkciji 
\family typewriter
main()
\family default
, tj.
 izvršava se prva naredba 
\family typewriter
cout
\family default
.
 Zatim funkcija 
\family typewriter
main()
\family default
 poziva funkciju 
\family typewriter
mojaFunkcija()
\family default
.
 Primetite da se funkcija poziva navođenjem zagrada iza imena.
 U ovom slučaju poziv funkcije je naredba i zato mora da se završi tačkom-zarezo
m.
 Zatim se u funkciji 
\family typewriter
mojaFunkcija()
\family default
 izvršava naredba 
\family typewriter
cout
\family default
 i izvršavanje se vraća u 
\family typewriter
main()
\family default
 kada se stigne do zatvorene zagrade 
\family typewriter
}
\family default
.
 U funkciji 
\family typewriter
main()
\family default
 izvršavanje se nastavlja u redu kôda odmah ispod poziva 
\family typewriter
mojaFunkcija()
\family default
.
 Na kraju 
\family typewriter
main()
\family default
 izvršava drugu naredbu 
\family typewriter
cout
\family default
 i program se završava.
\end_layout

\begin_layout Standard
Način na koji se 
\family typewriter
mojaFunkcija()
\family default
 poziva i kako se iz nje vraća je specifičan primer postupka koji se primenjuje
 na sve funkcije.
 U opštem slučaju, da bi se funkcija pozvala, navodi se njeno ime iza koje
 slede zagrade.
 Nakon pozivanja funkcije izvršavanje 
\begin_inset Quotes eld
\end_inset

skače
\begin_inset Quotes erd
\end_inset

 u funkciju i nastavlja se unutar nje.
 Kada se funkcija izvrši, izvršavanje programa se vraća pozivaocu u naredbi
 koja se nalazi odmah iza poziva funkcije.
 Primetite da je u prethodnom programu ispred funcije 
\family typewriter
main()
\family default
 navedena naredba:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void mojaFunkcija(); //prototip funkcije
\end_layout

\begin_layout Standard
Iako ćemo se na prototipe funkcije
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!prototip
\end_layout

\end_inset

 kasnije vratiti da bismo ih detaljnije proučili, sada treba da znamo da
 prototip funkcije deklariše funkciju pre njene definicije.
 Prototip omogućuje kompajleru da pre prvog poziva funkcije zna njen povratni
 tip, broj i tipove eventualnih parametara.
 Pošto kompajler mora da zna te informacije pre prvog poziva funkcije, u
 ovom slučaju prototip mora da se navede pre funkcije 
\family typewriter
main()
\family default
.
 Ključna reč 
\family typewriter
void
\family default
 ispred prototipa funkcije 
\family typewriter
mojaFunkcija()
\family default
 i njene definicije znači da 
\family typewriter
mojaFunkcija()
\family default
 ne vraća nikakvu vrednost; povratni tip
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
void
\family default
, povratni tip funkcije
\end_layout

\end_inset

 takvih funkcija u jeziku C++ je 
\family typewriter
void
\family default
.
\end_layout

\begin_layout Section
Argumenti funkcije
\end_layout

\begin_layout Standard
Funkciji je moguće proslediti jednu ili više vrednosti.
 Vrednost koja se prosleđuje funkciji zove se 
\shape italic
argument
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!argumenti
\end_layout

\end_inset

.
 Kada se kreira funkcija koja prihvara jedan argument ili više njih, moraju
 se deklarisati i promenljive koje prihvataju te argumente, a one se zovu
 
\shape italic
parametri funkcije
\shape default
.
 U sledećem primeru definiše se funcija 
\family typewriter
kutija()
\family default
 koja računa zapreminu kutije i prikazuje rezultat, a ima tri parametra.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//program koji ilustruje pozivanje funkcije 
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//prototip funkcije 
\end_layout

\begin_layout LyX-Code

\size small
void kutija(int duzina, int sirina, int visina); 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_layout LyX-Code

\size small
kutija(2, 3, 4); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void kutija(int duzina, int sirina, int visina) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Zapremina kutije je " << 
\end_layout

\begin_layout LyX-Code

\size small
duzina * sirina * visina << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard
\align left

\series bold
\size small
Zapremina kutije je: 24
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Kad god se pozove funkcija 
\family typewriter
kutija()
\family default
, ona će izračunati zapreminu množenjem vrednosti koje joj se prosleđuju
 kao parametri: dužine, širine i visine.
 Deklaracije parametara međusobno su razdvojene zarezima, a navedene su
 unutar zagrada iza imena funkcije.
 Takva sintaksa se koristi za sve funkcije sa parametrima.
 Da bi se pozvala funcija 
\family typewriter
kutija()
\family default
, moraju se zadati tri argumenta, na primer 
\family typewriter
kutija (2, 3, 4);
\family default
 ili 
\family typewriter
kutija(8, 6, 9);
\family default
 
\end_layout

\begin_layout Standard
Vrednosti navedene između zagrada su argumenti koji se prosleđuju funkciji
 
\family typewriter

\begin_inset Newline linebreak
\end_inset

kutija()
\family default
, pri čemu se vrednost svakog argumenta kopira redom u odgovarajući parametar.
 To znači da se u pozivu 
\family typewriter
kutija(2, 3, 4)
\family default
, vrednost 2 kopira u dužinu, 3 u širinu, a 4 u visinu.
 Kada se argumenti prosleđuju funkciji, prvom parametru se dodeljuje vrednost
 prvog argumenta itd.
 (vrednosti se prosleđuju isključivo na osnovu pozicije).
 
\end_layout

\begin_layout Section
Povratak iz funkcije
\end_layout

\begin_layout Standard
U prethodnim primerima funkcija se vraćala na red u kome je pozvana kada
 je izvršavanje stiglo do zatvorene zagrade u funkciji.
 Iako je to prihvatljivo za neke funkcije, nije primenljivo na sve.
 Često je potrebno precizno kontrolisati kada se funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!povratak
\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

vraća
\begin_inset Quotes erd
\end_inset

 i za tu namenu služi naredba 
\family typewriter
return
\family default
.
 Naredba 
\family typewriter
return
\family default
 ima dva oblika: jedan koji vraća vrednost i drugi koji ne vraća ništa.
 Za početak razmotrimo naredbu
\begin_inset Index idx
status open

\begin_layout Plain Layout
naredbe!
\family typewriter
return
\end_layout

\end_inset

 
\family typewriter
return
\family default
 koja ne vraća vrednost.
 Ako je povratni tip funkcije 
\family typewriter
void
\family default
 (što znači da ona ne vraća ništa), onda se koristi oblik
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
return; 
\end_layout

\begin_layout Standard
Kada se naiđe na naredbu 
\family typewriter
return
\family default
, izvršavanje funkcije se prekida i vraća na mesto odakle je funkcije pozvana.
 Sav kôd koji se nalazi iza naredbe 
\family typewriter
return
\family default
 se ignoriše, kao u sledećem primeru:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija(); //prototip funkcije
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Pre poziva: " << endl; 
\end_layout

\begin_layout LyX-Code

\size small
funkcija(); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Posle poziva " << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "U funkciji" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "ovo nece biti prikazano"; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
pre poziva
\end_layout

\begin_layout Standard

\series bold
\size small
u funkciji
\end_layout

\begin_layout Standard

\series bold
\size small
posle poziva
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Funkcija može da ima nekoliko naredbi 
\family typewriter
return
\family default
.
 Ipak, povratak iz funkcije na više mesta može da naruši njenu strukturu
 i da oteža razumevanje kôda, pa više naredbi 
\family typewriter
return
\family default
 u istoj funkciji treba koristiti samo kada olakšavaju njeno razumevanje.
\end_layout

\begin_layout Standard
Funkcija može i da vraća vrednost pozivaocu, pa naredba
\family typewriter
 return
\family default
 služi i za dobijanje informacija od funkcije.
 Za vraćanje vrednosti koristi se drugi oblik naredbe 
\family typewriter
return
\family default
:
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
return vrednost; 
\end_layout

\begin_layout Standard
Ovde je vrednost ono što funkcija vraća kao rezultat, a mora biti istog
 tipa kao što je i tip funkcije.
 Ako se tip funkcije i tip vrednosti iza naredbe 
\family typewriter
return
\family default
 ne poklapaju, pojaviće se greška tokom kompajliranja.
 Tip funkcije može da bude bilo koji važeći C++ tip podataka osim niza.
 U sledećem primeru funkcija 
\family typewriter
kutija()
\family default
 je prepravljena tako da vraća zapreminu.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//prototip funkcije 
\end_layout

\begin_layout LyX-Code

\size small
int kutija(int duzina, int sirina, int visina);
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Zapremina kutije je: " << kutija(2, 3, 4) << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int kutija(int duzina, int sirina, int visina) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return duzina * sirina * visina; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard
\align left

\series bold
\size small
Zapremina kutije je: 24
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Ako se funkcija čiji povratni tip nije 
\family typewriter
void
\family default
 vraća zato što je izvršavanje stiglo da zatvorene zagrade, vraća se nedefinisan
a (nepoznata) vrednost, ali dobra praksa u programiranju nalaže da bilo
 koja ne-void funkcija treba da vrati vrednost putem eksplicitne naredbe
 
\family typewriter
return
\family default
.
\end_layout

\begin_layout Subsection
Funkcija exit()
\end_layout

\begin_layout Standard
C++ program prestaje da se izvršava kada stigne do kraja funkcije 
\family typewriter
main()
\family default
, ili do naredbe 
\family typewriter
return
\family default
 u funkciji 
\family typewriter
main()
\family default
.
 Kada se druge funkcije izvrše, program se ne završava, već se kontrola
 izvršavanja vraća na naredbu odmah iza poziva funkcije.
 Ponekad je poželjno ili čak neophodno da se program završi u nekoj funkciji
 koja nije 
\family typewriter
main()
\family default
.
 Da bi se to postiglo, koristi se funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
exit()
\end_layout

\end_inset

 
\family typewriter
exit()
\begin_inset Index idx
status open

\begin_layout Plain Layout
exit()
\end_layout

\end_inset


\family default
 koja prekida izvršavanje programa, bez obzira na to koja funkcija ili kontrolni
 mehanizam se izvršavaju.
 Da bi se koristila funkcija 
\family typewriter
exit()
\family default
 neophodno je navesti zaglavlje
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja!
\family typewriter
cstdlib
\end_layout

\end_inset

 
\family typewriter
cstdlib
\family default
.
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <cstdlib>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//prototip funkcije 
\end_layout

\begin_layout LyX-Code

\size small
void funkcija();
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
funkcija(); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "ovaj program zavrsava se pomocu funkcije exit" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "cao!" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
exit(0); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "ova poruka nikada nece biti prikazana " << 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
"jer je program vec zavrsen."; 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
exit()
\size small
 
\family default
\size default
ima jedan celobrojni argument koji se koristi za prosleđivanje izlaznog
 kôda operativnom sistemu; vrednost 0 standardno označava uspešan završetak.
 U zaglavlju 
\family typewriter
cstdlib
\family default
 definisane su dve konstante, 
\family typewriter
\size small
EXIT_SUCCESS
\family default
\size default
 i 
\family typewriter
\size small
EXIT_FAILURE
\family default
\size default
 koje se mogu koristiti ako se zna da neće biti posebne provere rezultata
 programa.
\end_layout

\begin_layout Section
Doseg promenljivih (scope)
\end_layout

\begin_layout Standard
Dosad smo koristili promenljive bez formalnog objašnjenja gde mogu da se
 deklarišu, koliko ostaju važeće i koji delovi programa mogu da im pristupaju.
 Ta svojstva određena su pravilima za 
\shape italic
doseg
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
doseg
\end_layout

\end_inset

 (scope) promenljivih u jeziku C++, koja upravljaju vidljivošću i životnim
 vekom promenljivih.
 Iako je sistem dosega u jeziku C++ prilično složen, izdvajaju se dva osnovna
 tipa: lokalni i globalni doseg.
 U ovom odeljku pozabavićemo se razlikama između promenljivih deklarisanih
 u lokalnom i globalnom dosegu i videćemo u kakvoj su oni vezi sa funkcijama.
 
\end_layout

\begin_layout Subsection
Lokalni doseg
\end_layout

\begin_layout Standard
Lokalni opseg važnosti se definiše u bloku (podsetimo se iz Poglavlja 3
 da su početak i kraj bloka kôda definisani zagradama).
 Kad god se započne nov blok, stvara se nova oblast važenja promenljivih
\begin_inset Index idx
status open

\begin_layout Plain Layout
oblast važenja promenljivih
\end_layout

\end_inset

 (doseg).
 Promenljiva koja je definisana unutar bloka zove se lokalna promenljiva
\begin_inset Index idx
status open

\begin_layout Plain Layout
promenljive!lokalne
\end_layout

\end_inset

.
 Sve promenljive definisane unutar bloka su lokalne za taj blok, tj.
 nisu vidljive niti dostupne izvan njega.
 U suštini, kada se deklariše lokalna promenljiva, ona se 
\begin_inset Quotes eld
\end_inset

lokalizuje
\begin_inset Quotes erd
\end_inset

 i sprečava se njeno neovlašćeno korišćenje i menjanje.
 
\end_layout

\begin_layout Standard
Lokalne promenljive “žive” samo dok se izvršava blok koda u kome su definisane.
 One nastaju unutar bloka i nestaju kada se blok završi.
 Najčešće korišćen blok koda u kome se definišu lokalne promenljive jeste
 funkcija: pošto se telo funkcije nalazi između zagrada, funkcija jeste
 blok, pa njenim naredbama i podacima ne može da se pristupi izvan nje (nije
 moguće, na primer, upotrebiti naredbu 
\family typewriter
goto
\family default
 da bi se 
\begin_inset Quotes eld
\end_inset

uskočilo
\begin_inset Quotes erd
\end_inset

 usred neke funkcije).
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//prototip funkcije 
\end_layout

\begin_layout LyX-Code

\size small
void funkcija();
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int promenljiva = 10; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "vrednost promenljive u mainu je: " << 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
promenljiva << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
funkcija(); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "vrednost promenljive u mainu " <<
\end_layout

\begin_layout LyX-Code

\size small
  "nakon poziva funkcije je: " << promenljiva << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int promenljiva = 88; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "vrednost promenljive u funkciji je: " << 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
promenljiva << endl; 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
vrednost promenljive u mainu je: 10
\end_layout

\begin_layout Standard

\series bold
\size small
vrednost promenljive u funkciji je 88
\end_layout

\begin_layout Standard

\series bold
\size small
vrednost promenljive u mainu nakom poziva funkcije je: 10
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Uobičajeno je da se sve promenljive potrebne u funkciji deklarišu na početku
 tela funkcije, prvenstveno zbog toga što funkcija postaje čitljivija.
 Međutim, to ne mora obavezno da bude tako: lokalna promenljiva može se
 deklarisati bilo gde unutar bloka, ali ta deklaracija mora da se nalazi
 pre njenog prvog korišćenja.
 
\end_layout

\begin_layout Standard
Parametri funkcije su unutar dosega funkcije, tj.
 oni su lokalni za funkciju i osim što prihvataju vrednosti argumenata,
 ponašaju se kao i sve druge lokalne promenljive.
\end_layout

\begin_layout Standard
Pošto se lokalna promenljiva pravi i uništava pri svakom ulasku i izlasku
 iz bloka u kome je deklarisana, njena vrednost neće biti zapamćena između
 dva izvršavanja.
 Naročito je važno razumeti korišćenje lokalnih promenljivih u funkciji:
 one se prave pri ulasku u funkciju, a uništavaju po izlasku, što znači
 da ne mogu da zadrže vrednost između dva poziva funkcije.
 Ako se lokalna promenljiva inicijalizuje, onda se inicijalizacija ponavlja
 pri svakom izvršavanju bloka, što ilustruje sledeći primer.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//prototip funkcije 
\end_layout

\begin_layout LyX-Code

\size small
void funkcija();
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
for(int i=0; i<3; i++) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
funkcija(); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//promenljiva se inicijalizuje pri svakom ulasku u funkciju 
\end_layout

\begin_layout LyX-Code

\size small
int promenljiva = 88; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "promenljiva: " << promenljiva << endl; 
\end_layout

\begin_layout LyX-Code

\size small
promenljiva++; //ovo nema nikakvog efekta 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
promenljiva: 88
\end_layout

\begin_layout Standard

\series bold
\size small
promenljiva: 88
\end_layout

\begin_layout Standard

\series bold
\size small
promenljiva: 88
\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsection
Globalni doseg
\end_layout

\begin_layout Standard
Globalni doseg
\begin_inset Index idx
status open

\begin_layout Plain Layout
doseg!globalni
\end_layout

\end_inset

 (global scope) je oblast deklarisanja koja se nalazi izvan svih funkcija.
 Globalne promenljive dostupne su u celom programu, tj.
 njihova oblast važnosti je ceo kôd programa, i zadržavaju svoju vrednost
 tokom celog izvršavanja programa.
 To znači da je njihova oblast važenja (doseg) ceo program.
 Globalne promenljive deklarišu se izvan svih funkcija.
 
\end_layout

\begin_layout Standard
Sledeći program ilustruje korišćenje globalne promenljive 
\family typewriter
brojac
\family default
 koja je deklarisana izvan svih funkcija, pre funkcije 
\family typewriter
main()
\family default
.
 Pošto se svaka promenljiva mora deklarisati pre prvog korišćenja, najbolje
 je da se globalne promenljive deklarišu na samom početku programa, izvan
 svih funkcija, pre funkcije 
\family typewriter
main()
\family default
, da bi bile dostupne celom programu.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija1(); 
\end_layout

\begin_layout LyX-Code

\size small
void funkcija2();
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int brojac; //globalna promenljiva
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
for(int i=0; i<10; i++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
brojac = i * 2; //ovo se odnosi na globalni brojac
\end_layout

\begin_layout LyX-Code

\size small
funkcija1();
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija1(){
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//pristup globalnom brojacu
\end_layout

\begin_layout LyX-Code

\size small
cout << 
\begin_inset Quotes sld
\end_inset

brojac: 
\begin_inset Quotes sld
\end_inset

 << brojac << endl;
\end_layout

\begin_layout LyX-Code

\size small
funkcija2();
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija2(){
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//ovaj brojac je lokalni za funkciju2
\end_layout

\begin_layout LyX-Code

\size small
int brojac;
\end_layout

\begin_layout LyX-Code

\size small
for(brojac=0; brojac<3; brojac++)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << 
\begin_inset Quotes sld
\end_inset

.
\begin_inset Quotes srd
\end_inset

;
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
brojac: 0
\end_layout

\begin_layout Standard

\series bold
\size small
...brojac: 2
\end_layout

\begin_layout Standard

\series bold
\size small
...brojac: 4
\end_layout

\begin_layout Standard

\series bold
\size small
...brojac: 6
\end_layout

\begin_layout Standard

\series bold
\size small
...
\end_layout

\begin_layout Standard

\series bold
\size small
...brojac: 18
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Globalne promenljive inicijalizuju se kada program počne da se izvršava.
 Ako nije navedena vrednost za inicijalizaciju globalne promenljive, ona
 se inicijalizuje na 0.
 Globalne promenljive smeštaju se u posebnu oblast memorije rezervisanu
 za tu namenu.
 Korisne su kada se isti podatak koristi u više funkcija, ili kada neka
 promenljiva treba da zadrži vrednost tokom celokupnog izvršavanja programa.
 
\end_layout

\begin_layout Standard
Ipak, korišćenje globalnih promenljivih treba izbegavati iz više razloga:
 
\end_layout

\begin_layout Itemize
zauzimaju memoriju sve vreme tokom izvršavanja programa, a ne samo onda
 kada su potrebne 
\end_layout

\begin_layout Itemize
ako se globalna promenljiva koristi u funkciji, ona postaje manje samostalna
 jer se oslanja na promenljivu koja je definisana izvan nje 
\end_layout

\begin_layout Itemize
globalne promenljive prouzrokuju greške u programima koje se teško otkrivaju,
 zbog promena vrednosti na raznim mestima u programu.
 
\end_layout

\begin_layout Subsection
Statičke promenljive
\end_layout

\begin_layout Standard
Umesto korišćenja globalnih promenljivih u funkcijama kada je potrebna promenlji
va koja pamti vrednosti između različitih poziva iste funkcije bolje je
 koristiti statičke promenljive.
 Deklaracija statičke promenljive postiže se dodavanjem modifikatora
\begin_inset Index idx
status open

\begin_layout Plain Layout
promenljive!statičke
\end_layout

\end_inset

 
\family typewriter
static
\family default
 ispred tipa promenljive:
\end_layout

\begin_layout LyX-Code

\size small
static int brojac;
\end_layout

\begin_layout Standard
Statička promenljiva inicijalizuje se samo jednom, pri prvom izvršavanju
 funkcije, pamti svoje vrednosti tokom celog izvršavanja programa, a dostupna
 je u bloku u kome je deklarisana.
 Sledeći kôd ilustruje korišćenje statičke promenljive za brojanje koliko
 je puta funkcija pozvana.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void zapamti(); //prototip funkcije
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
for(int i=0; i<=3; i++) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
zapamti(); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void zapamti() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
static int brojac = 0; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Ovo je " << ++brojac << " put da sam pozvana" << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Ovo je 1.
 put da sam pozvana
\end_layout

\begin_layout Standard

\series bold
\size small
Ovo je 2.
 put da sam pozvana
\end_layout

\begin_layout Standard

\series bold
\size small
Ovo je 3.
 put da sam pozvana
\end_layout

\begin_layout Standard

\series bold
\size small
Ovo je 4.
 put da sam pozvana
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Kada se modifikator 
\family typewriter
static
\family default
 primeni na globalnu
\begin_inset Index idx
status open

\begin_layout Plain Layout
promenljive!statičke globalne
\end_layout

\end_inset

 promenljivu, pravi se globalna promenljiva koja je poznata samo datoteci
 u kojoj je deklarisana.
 To znači da i pored toga što je promenljiva globalna, funkcije izvan datoteke
 u kojoj je deklarisana ne mogu da joj promene vrednost.
 Generalno, modifikator 
\family typewriter
static
\family default
 služi za ograničavanje vidljivosti promenljive i za sprečavanje sporednih
 efekata u velikim programima.
 
\end_layout

\begin_layout Section
Imenici
\end_layout

\begin_layout Standard

\shape italic
Imenici
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
imenici!deklaracija
\end_layout

\end_inset

 (namespaces) su noviji dodatak u standadnom jeziku C++ i omogućuju kreiranje
 oblasti važenja (dosega, scope) za globalne identifikatore da bi se izbegli
 sukobi, tj.
 preklapanja.
 Pre uvođenja mehanizma imenika, u jeziku C++ je postojala zbrka sa nazivima
 promenljivih i funkcija.
 Na primer, ako biste u svom programu definisali funkciju 
\family typewriter
toupper()
\family default
, u zavisnosti od njenih parametara moglo bi se desiti da preklopi funkciju
 
\family typewriter
toupper()
\family default
 standardne biblioteke, pošto su oba imena bila u istom globalnom imeniku.
\end_layout

\begin_layout Standard
Imenik omogućuje korišćenja istog imena u različitim kontekstima bez sukoba.
 Novi imenik se deklariše navođenjem ključne reči 
\family typewriter
namespace
\family default
 ispred deklarativne oblasti:
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
namespace ime { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
// deklaracije 
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
}
\end_layout

\begin_layout Standard
Sve što je deklarisano unutar imenika ima njegov doseg (scope).
 
\end_layout

\begin_layout Standard
U svim programima dosada koristili smo naredbu
\end_layout

\begin_layout Standard

\family typewriter
\size small
using namespace std; 
\end_layout

\begin_layout Standard
Direktiva
\begin_inset Index idx
status open

\begin_layout Plain Layout
imenici!direktiva 
\family typewriter
using
\end_layout

\end_inset

 
\family typewriter
using
\begin_inset Index idx
status open

\begin_layout Plain Layout
using
\end_layout

\end_inset


\family default
 uvozi sva imena iz imenika u datoteku, pa svim identifikatorima koji su
 definisani u imeniku nadalje može da se pristupi direktno.
 Bez direktive 
\family typewriter
using
\family default
, mora da se koristi operator razrešenja dosega (::), kao u sledećem primeru:
 
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
namespace imenik { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int vrednost = 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
std::cout << "unesite ceo broj: "; 
\end_layout

\begin_layout LyX-Code

\size small
std::cin >> imenik::vrednost; 
\end_layout

\begin_layout LyX-Code

\size small
std::cout << std::endl << "uneli ste: " << 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
imenik::vrednost << std::endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Imenik se ne može deklarisati unutar funkcije, već mu je namena suprotna:
 u njemu treba da se nađu funkcije, globalne promenljive i druga imena.
 Funkcija 
\family typewriter
main()
\family default
 ne sme da se nađe u nekom imeniku jer je kompajler ne bi prepoznao.
\end_layout

\begin_layout Standard
Specijalna vrsta imenika, tzv.
 bezimeni imenik
\begin_inset Index idx
status open

\begin_layout Plain Layout
imenici!bezimeni
\end_layout

\end_inset

 (unnamed namespace) omogućuje definisanje identifikatora koji su vidljivi
 samo unutar datoteke: 
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
namespace { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
// deklaracije 
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
}
\end_layout

\begin_layout Standard
Unutar datoteke koja sadrži bezimeni imenik identifikatori se mogu koristiti
 direktno, bez kvalifikacije, a van te datoteke su nepoznati.
 Zbog toga bezimene imenike treba koristiti umesto statičkih globalnih promenlji
vih.
 
\end_layout

\begin_layout Section
Nizovi i pokazivači kao argumenti funkcija
\end_layout

\begin_layout Standard
Kada se funkcijama umesto prostih ugrađenih tipova kao što su 
\family typewriter
int
\family default
 ili 
\family typewriter
double
\family default
 prosleđuju pokazivači i nizovi kao argumenti, potrebno je poznavati mehanizam
 njihovog prenošenja u funkciju.
 Kada se kao argument prosleđuje pokazivač
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači!kao argumenti funkcija
\end_layout

\end_inset

, parametar funkcije se mora deklarisati kao pokazivački tip, što ilustruje
 sledeći primer:
\end_layout

\begin_layout LyX-Code

\size small
//prosledjivanje pokazivaca funkciji
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija(int *p);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int i=0; 
\end_layout

\begin_layout LyX-Code

\size small
int *p; p=&i; //p pokazuje na i 
\end_layout

\begin_layout LyX-Code

\size small
//prosledjivanje pokazivaca kao argumenta funkcije 
\end_layout

\begin_layout LyX-Code

\size small
funkcija(p); 
\end_layout

\begin_layout LyX-Code

\size small
cout << i << endl; //i je sada 100 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void funkcija(int *p) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//promenljivoj na koju pokazuje p dodeljuje se 100 
\end_layout

\begin_layout LyX-Code

\size small
*p = 100;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\family typewriter
funkcija()
\family default
 prihvata jedan parametar koji je pokazivač na 
\family typewriter
int
\family default
.
 U funkciji 
\family typewriter
main()
\family default
, pokazivaču
\family typewriter
 p
\family default
 dodeljuje se adresa celobrojne promenljive 
\family typewriter
i
\family default
, a zatim se 
\family typewriter
funkcija()
\family default
 poziva sa pokazivačem 
\family typewriter
p
\family default
 kao argumentom.
 Kada pokazivački parametar prihvati
\family typewriter
 p
\family default
, i on će pokazivati na promenljivu 
\family typewriter
i
\family default
 iz funkcije 
\family typewriter
main()
\family default
.
 Dodela 
\family typewriter
*p = 100;
\family default
 zapravo je dodela vrednosti 100 promenljivoj 
\family typewriter
i
\family default
 preko pokazivača.
 U opštem slučaju, korišćenje pokazivačke promenljive
\family typewriter
 p
\family default
 nije neophodno; umesto toga, funkcija bi se mogla pozvati kao 
\family typewriter
funkcija(&i)
\family default
, čime bi joj se prosledila adresa promenljive
\family typewriter
 i
\family default
.
\end_layout

\begin_layout Standard
Veoma je važno shvatiti da kada funkcija kao parametar ima pokazivač, zapravo
 se u njoj radi sa promenljivom na koju taj pokazivač pokazuje, što znači
 da funkcija može da promeni vrednost objekta na koji taj pokazivač pokazuje.
\end_layout

\begin_layout Standard
Kada je parametar funkcije niz, prilikom stvarnog poziva sa argumentima
 prosleđuje se adresa prvog elementa niza, a ne ceo niz.
 Pošto je ime niza pokazivač na prvi element niza, to znači da se zapravo
 prosleđuje pokazivač na niz, pa funkcija može da promeni sadržaj niza koji
 se koristi kao stvarni argument prilikom poziva.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void prikaziNiz(int brojevi[10]);
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//prosledjivanje niza funkciji
\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int t[10], i; 
\end_layout

\begin_layout LyX-Code

\size small
//inicijalizacija niza 
\end_layout

\begin_layout LyX-Code

\size small
for(i=0;i<10;i++) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
t[i]=i; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
prikaziNiz(t); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void prikaziNiz(int brojevi[10]) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
for(int i=0;i<10;i++) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << brojevi[i] << " "; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
0 1 2 3 4 5 6 7 8 9
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Postoje tri načina da se parametar funkcije deklariše tako da može da primi
 niz.
 Prvi je da se parametar deklariše kao niz istog tipa i dimenzija kao onaj
 koji će se koristiti za poziv funkcije, kao u prethodnom primeru:
\end_layout

\begin_layout Standard

\family typewriter
void prikaziNiz(int brojevi[10]);
\end_layout

\begin_layout Standard
Iako je parametar 
\family typewriter
brojevi
\family default
 deklarisan kao niz od deset celih brojeva, C++ kompajler će ga automatski
 konvertovati u pokazivač na 
\family typewriter
int
\family default
.
 Drugi način je da se parametar deklariše kao niz bez dimenzija:
\end_layout

\begin_layout Standard

\family typewriter
void prikaziNiz(int brojevi[]);
\end_layout

\begin_layout Standard
Pošto C++ ne proverava granice niza, stvarne dimenzije niza nisu bitne za
 parametar (ali su za program jako bitne).
 I deklaraciju ovog tipa kompajler takođe konvertuje u pokazivač na 
\family typewriter
int
\family default
.
\end_layout

\begin_layout Standard
Treći način deklarisanja, koji se i najčešće koristi u profesionalnim C++
 programima, jeste da se parametar odmah deklariše kao pokazivač:
\end_layout

\begin_layout Standard

\family typewriter
void prikaziNiz(int *brojevi);
\end_layout

\begin_layout Standard
Važno je zapamtiti da se u slučaju korišćenja niza kao argumenta funkcije,
 toj funkciji prosleđuje adresa prvog elementa niza.
 To znači da će kôd funkcije potencijalno moći da izmeni stvarni sadržaj
 niza koji se koristi za pozivanje funkcije.
 Na primer, u sledećem programu funkcija 
\family typewriter
kub()
\family default
 svaki element niza zamenjuje njegovom kubnom vrednošću.
 U pozivu funkcije
\family typewriter
 kub()
\family default
 adresa niza se prosleđuje kao prvi argument, a njegova dimenzija kao drugi.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void prikaziNiz(int brojevi[10]);
\end_layout

\begin_layout LyX-Code

\size small
void kub(int*, int);
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int t[10], i; 
\end_layout

\begin_layout LyX-Code

\size small
//inicijalizacija niza 
\end_layout

\begin_layout LyX-Code

\size small
for(i=0; i<10;i++) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
t[i] = i+1; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << "originalan niz: "; 
\end_layout

\begin_layout LyX-Code

\size small
prikaziNiz(t); 
\end_layout

\begin_layout LyX-Code

\size small
kub(t, 10); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "izmenjen niz: "; 
\end_layout

\begin_layout LyX-Code

\size small
prikaziNiz(t); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//funkcija za prikaz niza 
\end_layout

\begin_layout LyX-Code

\size small
void prikaziNiz(int brojevi[10]) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
for(int i=0; i<10; i++) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << brojevi[i] << " "; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//primer funkcije koja menja vrednost niza 
\end_layout

\begin_layout LyX-Code

\size small
void kub(int *p, int n) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
while(n) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
*p = *p * *p * *p; 
\end_layout

\begin_layout LyX-Code

\size small
n--; 
\end_layout

\begin_layout LyX-Code

\size small
p++; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
originalan niz: 1 2 3 4 5 6 7 8 9 10
\end_layout

\begin_layout Standard

\series bold
\size small
izmenjen niz: 1 8 27 64 125 216 343 512 729 1000
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Section
Reference
\end_layout

\begin_layout Standard
U opštem slučaju, programski jezici podržavaju dva načina za prenos argumenata
 u funkciju.
 Prvi se zove 
\shape italic
prenos po vrednosti
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
prenos po vrednosti
\end_layout

\end_inset

 (pass-by-value) i sastoji se u kopiranju vrednosti argumenta u parametre
 funkcije.
 To znači da promene parametra unutar funkcije nemaju nikakvog efekta na
 argument koji se koristi za poziv funkcije.
 Ovo je standardan način prenosa argumenata u funkciju u jeziku C++.
 Drugi pristup je 
\shape italic
prenos po adresi
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
prenos po adresi
\end_layout

\end_inset

 ili prenos po referenci (pass-by-reference).
 Kod tog pristupa, u parametar se kopira adresa stvarnog argumenta, a ne
 njegova vrednost.
 Unutar funkcije ta adresa se koristi za posredan pristup stvarnom argumentu
 sa kojim je funkcija pozvana.
 To znači da promene parametra unutar funkcije menjaju stvarni argument
 sa kojim je pozvana.
 Iako je standardan način prenosa parametara u jeziku C++ po vrednosti,
 moguće je 
\begin_inset Quotes sld
\end_inset

ručno
\begin_inset Quotes srd
\end_inset

 ostvariti prenos po adresi, tako što se kao parametri funkcije zadaju pokazivač
i, o čemu smo diskutovali u prethodnom odeljku.
 Kao primer prenosa po adresi, pogledajmo program koji koristi funkciju
 
\family typewriter
swap()
\family default
 za zamenu vrednosti dve promenljive na koje pokazuju argumenti funkcije.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//prototip funkcije koja zamenjuje vrednosti 
\end_layout

\begin_layout LyX-Code

\size small
//svojih argumenata 
\end_layout

\begin_layout LyX-Code

\size small
void swap(int *x, int *y);
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int i=10, j=20; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "pocetne vrednosti: " << i <<", " << j << endl; 
\end_layout

\begin_layout LyX-Code

\size small
//funkciji swap prosledjuju se adrese argumenata 
\end_layout

\begin_layout LyX-Code

\size small
swap(&i, &j); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "posle zamene: " << i <<", " << j << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void swap(int *x, int *y) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int temp; 
\end_layout

\begin_layout LyX-Code

\size small
temp = *x; //sacuvaj vrednost na adresi x 
\end_layout

\begin_layout LyX-Code

\size small
*x = *y; //stavi y u x 
\end_layout

\begin_layout LyX-Code

\size small
*y = temp; //stavi x u y 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
pocetne vrednosti: 10, 20
\end_layout

\begin_layout Standard

\series bold
\size small
posle zamene: 20, 10
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
swap() 
\family default
deklariše dva pokazivačka parametra, x i y koji se koriste za zamenjivanje
 vrednosti promenljivih na koje pokazuju argumenti koji se prosleđuju funkciji.
 Pošto 
\family typewriter
swap()
\family default
 očekuje da primi dva pokazivača, kada se poziva kao argumenti se moraju
 proslediti adrese promenljivih koje treba da se zamene.
 
\end_layout

\begin_layout Subsection
Reference u funkcijama
\end_layout

\begin_layout Standard
Pristup 
\begin_inset Quotes sld
\end_inset

ručnog
\begin_inset Quotes srd
\end_inset

 prosleđivanja adrese preko pokazivača je prilično nezgodan, iz dva razloga.
 Prvo, primorava nas da sve operacije obavljamo preko poazivača, a drugo,
 ne smemo zaboraviti da prilikom pozivanja funkcije prosledimo adrese promenljiv
ih (umesto vrednosti).
 Umesto “ručnog” poziva po adresi pozivanjem funkcije sa argumentima pokazivačim
a, može se C++ kompajleru reći da automatski koristi prenos po adresi.
 To se postiže tako što se kao argumenti funkcije navode 
\shape italic
reference
\shape default
.
 
\end_layout

\begin_layout Standard
Kada je parametar funkcije referenca, njoj se automatski prosleđuje adresa
 argumenta.
 Unutar funkcije, operacije sa parametrom se automatski dereferenciraju,
 što znači da se ne radi sa adresom promenljive nego sa njenom vrednošću.
 Referenca se deklariše tako što se ispred imena promenljive navodi &, kao
 u sledećem primeru: 
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//prototip funkcije ciji su argumenti reference 
\end_layout

\begin_layout LyX-Code

\size small
void swap(int &x, int &y);
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int i=10, j=20; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "pocetne vrednosti: " << i <<", " << j << endl; 
\end_layout

\begin_layout LyX-Code

\size small
//funkciji swap prosledjuju se direktno argumenti 
\end_layout

\begin_layout LyX-Code

\size small
swap(i, j); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "posle zamene: " << i <<", " << j << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void swap(int &x, int &y) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int temp; 
\end_layout

\begin_layout LyX-Code

\size small
temp = x; //sacuvaj vrednost na adresi x 
\end_layout

\begin_layout LyX-Code

\size small
x = y; //stavi y u x 
\end_layout

\begin_layout LyX-Code

\size small
y = temp; //stavi x u y 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Uz korišćenje referenci, u funkciji nije potrebno koristiti operator dereferenci
ranja (*) kao što je slučaj sa pokazivačima.
 Takođe, treba znati da operacije koje se izvode nad parametrom koji je
 referenca utiču na samu vrednost parametra, a ne na njegovu adresu.
 
\end_layout

\begin_layout Standard
Funkcija čiji je argument referenca
\begin_inset Index idx
status open

\begin_layout Plain Layout
reference!kao parametri funkcija
\end_layout

\end_inset

 poziva se na isti način kao da se radi o prenosu po vrednosti.
 Primetite da je u prethodnom primeru funkcija 
\family typewriter
swap()
\family default
 deklarisana tako da prihvata reference kao argumente, a u redu gde se poziva,
 tj.
 u naredbi 
\family typewriter
swap(i,j);
\family default
 prosleđuju joj se stvarni argumenti, a ne njihove adrese.
 Parametar se inicijalizuje adresom argumenta, bez ikakvog kopiranja vrednosti.
 
\end_layout

\begin_layout Subsection
Samostalne reference
\end_layout

\begin_layout Standard
Referenca se koristi kao alijas (drugo ime) za promenljivu, tj.
 može se koristiti kao alternativni način za pristup promenljivoj.
 Prilikom deklaracije, nezavisna referenca
\begin_inset Index idx
status open

\begin_layout Plain Layout
reference!samostalne
\end_layout

\end_inset

 se uvek inicijalizuje i tokom celog svog životnog veka je vezana za objekat
 kojim je inicijalizovana.
 Reference se ne mogu “preusmeravati” na druge promenljive kao pokazivači.
 Ipak, reference se retko koriste samostalno; njihova najvažnija upotreba
 je u parametrima funkcija.
 
\end_layout

\begin_layout LyX-Code

\size small
long broj = 10; 
\end_layout

\begin_layout LyX-Code

\size small
//definisanje reference na promenljivu broj 
\end_layout

\begin_layout LyX-Code

\size small
long &rbroj = broj; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "broj pre: " << broj << endl; //ispisuje 10
\end_layout

\begin_layout LyX-Code

\size small
rbroj+=10; //povecava se broj preko reference 
\end_layout

\begin_layout LyX-Code

\size small
cout << "broj posle: " << broj << endl; //ispisuje 11
\end_layout

\begin_layout Subsection
Pokazivači i reference
\end_layout

\begin_layout Standard
Iako između pokazivača i referenci
\begin_inset Index idx
status open

\begin_layout Plain Layout
reference!i pokazivači
\end_layout

\end_inset

 ima dosta sličnosti, treba imati na umu i sledeće veoma bitne razlike:
\end_layout

\begin_layout Itemize
pokazivač se može preusmeriti tako da pokazuje na neki drugi objekat (promenljiv
u), a referenca ne može 
\end_layout

\begin_layout Itemize
pokazivač može da ne pokazuje ni na šta, a referenca od početka do kraja
 svog životnog veka pokazuje na jedan isti objekat 
\end_layout

\begin_layout Itemize
pristup objektu preko pokazivača obavlja se pomoću operatora *, dok je preko
 reference pristup neposredan 
\end_layout

\begin_layout Itemize
moguće je napraviti nizove pokazivača, ali ne i nizove referenci
\end_layout

\begin_layout Itemize
ne može se napraviti referenca na referencu
\end_layout

\begin_layout Subsection
Reference kao povratni tip funkcija
\end_layout

\begin_layout Standard
Kada je povratni tip referenca
\begin_inset Index idx
status open

\begin_layout Plain Layout
reference!kao povratni tip funkcije
\end_layout

\end_inset

, treba voditi računa o životnom veku promenljive povezane sa referencom.
 Pokazivač na lokalnu promenljivu, kao ni referenca na lokalnu promenljivu
 u funkciji nikada ne smeju da budu povratna vrednost funkcije.
 Pošto referenca nikada ne postoji samostalno, već je uvek alijas neke druge
 promenljive, objekat s kojim je povezana mora da postoji i nakon završetka
 izvršavanja funkcije.
 Referenca kao argument funkcije pravi se pri svakom pozivu funkcije, i
 uništava po završetku izvršavanja funkcije.
 To znači da u sledećem primeru promenljiva i koja je povratna vrednost
 funkcije neće postojati kada se funkcija vrati na mesto gde je pozvana:
\end_layout

\begin_layout LyX-Code

\size small
//funkcija ciji je povratni tip referenca na int
\end_layout

\begin_layout LyX-Code

\size small
int& f() {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int i = 10;
\end_layout

\begin_layout LyX-Code

\size small
return i; //promenljiva i vise ne postoji kada se funkcija zavrsi!
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Subsection
Korišćenje modifikatora const u funkcijama
\end_layout

\begin_layout Standard
Kada se modifikator 
\family typewriter
const
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
const
\family default
!u parametrima funkcije
\end_layout

\end_inset

 navede ispred imena parametra funkcije, to znači da odgovarajući argument
 nikako ne sme biti promenjen.
 Kompajler proverava da li se argument unutar funkcije menja i upozorava
 na to.
 Korišćenjem referenci može se izbeći nepotrebno kopiranje argumenata prilikom
 poziva funkcije, a ako se one koriste uz modifikator 
\family typewriter
const
\family default
, obezbeđuje se i dodatna zaštita od slučajne izmene argumenta.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int incr10(const int &broj);
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
const int primer = 20; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "pre poziva funkcije: " << primer << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "vrednost koja se vraca iz funkcije: " << 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
incr10(primer) << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << "posle poziva funkcije: " << primer << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int incr10(const int &broj) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//return broj+=10; ovo bi bila greska 
\end_layout

\begin_layout LyX-Code

\size small
return broj + 10; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
pre poziva funkcije: 20
\end_layout

\begin_layout Standard

\series bold
\size small
vrednost koja se vraća iz funkcije: 30
\end_layout

\begin_layout Standard

\series bold
\size small
posle poziva funkcije: 20
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Kada bi se u prethodnom primeru koristila naredba 
\family typewriter
return broj+=10;
\family default
 posredno bi se promenio objekat povezan sa referencom (tj.
 promenljiva 
\family typewriter
broj
\family default
) koja se prosleđuje kao argument, što bi bila greška jer je funkcija deklarisan
a sa parametrom koji je 
\family typewriter
const
\family default
.
 Zbog toga povratna vrednost funkcije mora biti privremeni objekat koji
 se kreira naredbom 
\family typewriter
broj+10
\family default
.
\end_layout

\begin_layout Section
Prototipovi funkcija
\end_layout

\begin_layout Standard
Prototipove funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!prototip
\end_layout

\end_inset

 već smo pomenuli na početku ovog poglavlja, a sada ćemo ih detaljno proučiti.
 Sve funkcije u jeziku C++ moraju da budu deklarisane pre prvog korišćenja.
 Od 
\shape italic
prototipa funkcije
\shape default
 kompajler dobija sledeće tri informacije: 
\end_layout

\begin_layout Itemize
koji je povratni tip funkcije
\end_layout

\begin_layout Itemize
koliko ima argumenata 
\end_layout

\begin_layout Itemize
kog su tipa argumenti
\end_layout

\begin_layout Standard
U sledećem primeru naveden je prototip funkcije koja očekuje pokazivač kao
 argument:
\end_layout

\begin_layout LyX-Code

\size small
void funkcija(int *p);
\end_layout

\begin_layout LyX-Code

\size small
int main() {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int x = 10;
\end_layout

\begin_layout LyX-Code

\size small
funkcija(x); //greska!
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Prototipovi omogućuju kompajleru da obavi tri važne operacije:
\end_layout

\begin_layout Enumerate
kažu kompajleru kakvu vrstu kôda treba da generiše prilikom poziva funkcije.
 Kompajler se različito ophodi prema različitim povratnim tipovima funkcija.
\end_layout

\begin_layout Enumerate
omogućuju pronalaženje i prijavljivanje svih nevažećih konverzija tipova
 između tipova argumenata sa kojima se funkcija poziva i tipova parametara
 sa kojima je funkcija definisana
\end_layout

\begin_layout Enumerate
omogućuju otkrivanje neslaganja između broja argumenata korišćenih u pozivu
 funkcije i broja parametara sa kojima je funkcija deklarisana u prototipu
\end_layout

\begin_layout Standard
Opšti oblik prototipa funkcije je isti kao i njena definicija, s tim što
 nema tela:
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
povratni_tip ime (tip param1, tip param2, ...
 tip paramN);
\end_layout

\begin_layout Standard
Korišćenje imena parametara u prototipu nije obavezno, ali je preporučljivo
 zbog čitljivosti.
\end_layout

\begin_layout Standard
Obično je lakše i bolje deklarisati prototip za svaku funkciju koja se koristi
 u programu umesto proveravati da li je svaka funkcija definisana pre prvog
 korišćenja, naročito u velikim programima u kojima se teško prati međusobno
 pozivanje funkcija.
 Ako se funkcija i definiše pre pvog pozivanja u programu, onda ta definicija
 služi i kao prototip.
\end_layout

\begin_layout Standard

\shape italic
Zaglavlja
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja
\end_layout

\end_inset

 (header files) sadrže prototipove svih funkcija koje čine standardnu C++
 biblioteku (zajedno sa različitim vrednostima i definicijama koje koriste
 te funkcije).
 Na početku datoteke koja poziva neku standardnu funkciju uvek se navodi
 zaglavlje u kome se ona nalazi da bi bio dostupan prototip te funkcije
 iz zaglavlja.
 
\end_layout

\begin_layout Standard
Funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
main()
\end_layout

\end_inset

 
\family typewriter
main()
\family default
 je posebna zato što je to prva funkcija koja se poziva prilikom izvršavanja
 programa.
 C++ svaki program započinje pozivom funkcije 
\family typewriter
main()
\family default
, bez obzira gde se ona u programu nalazi.
 Program može i mora da ima samo jednu funkciju 
\family typewriter
main() 
\family default
i za nju ne postoji prototip jer je ugrađena u jezik C++.
\end_layout

\begin_layout Section
Preklapanje funkcija
\end_layout

\begin_layout Standard
U jezku C++ može da postoji nekoliko funkcija istog imena, sa različitim
 brojem i(li) tipovima argumenata; to se zove 
\shape italic
preklapanje funkcija
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!preklapanje
\end_layout

\end_inset

 (function overloading).
 Ova mogućnost je vrlo korisna za funkcije koje obavljaju isti zadatak nad
 različitim tipovima podataka.
 Na primer, moguće je u istom programu imati dva prototipa za funkciju 
\family typewriter
min()
\family default
 koja pronalazi manji od svoja dva parametra:
\end_layout

\begin_layout Standard

\family typewriter
\size small
int min(int a, int b); //min za cele brojeve
\end_layout

\begin_layout Standard

\family typewriter
\size small
char min(char a, char b); //min za znake
\end_layout

\begin_layout Standard
Da bi dve funkcije bile preklopljene, nije dovoljno da im se razlikuje samo
 povratni tip, već i tip ili broj argumenata moraju biti različiti.
 Kada se poziva preklopljena funkcija, kompajler na osnovu tipa argumenata
 poziva odgovarajuću funkciju.
 
\end_layout

\begin_layout Standard
Vrednost preklapanja je u tome što omogućuje korišćenje skupa funkcija slične
 namene sa istim imenom.
 U prethodnom primeru, naziv 
\family typewriter
min
\family default
 označava opštu operaciju koja će biti sprovedena, a kompajleru se ostavlja
 da izabere pravu verziju u odgovarajućim okolnostima.
 Tako se pomoću mehanizma preklapanja ostvaruje polimorfizam
\begin_inset Index idx
status open

\begin_layout Plain Layout
polimorfizam
\end_layout

\end_inset

, o kome ćemo detaljnije učiti u Poglavlju 7.
 Druga prednost preklapanja je u tome što omogućuje definisanje različitih
 verzija iste funkcije specijalizovanih za tip podataka sam kojima funkcija
 radi.
 U sledećem primeru ilustrovano je kako funkcija 
\family typewriter
min()
\family default
 u slučaju celobrojnih argumenata nalazi manji broj, a znakove poredi nešto
 drugačije, uz zanemarivanje velikih i malih slova.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//prototipovi preklopljenih funkcija 
\end_layout

\begin_layout LyX-Code

\size small
int min(int a, int b); 
\end_layout

\begin_layout LyX-Code

\size small
char min(char a, char b);
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << min(2, 3) << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << min('a', 'B') << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int min(int a, int b) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int min; 
\end_layout

\begin_layout LyX-Code

\size small
(a>b) ? min=a : min=b; 
\end_layout

\begin_layout LyX-Code

\size small
return min; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//min za char ignorise velika slova 
\end_layout

\begin_layout LyX-Code

\size small
char min(char a, char b) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char min; 
\end_layout

\begin_layout LyX-Code

\size small
(tolower(a)>tolower(b)) ? min=a : min=b; 
\end_layout

\begin_layout LyX-Code

\size small
return min; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
9
\end_layout

\begin_layout Standard

\series bold
\size small
X
\end_layout

\begin_layout Standard

\series bold
\size small
9
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Kada se funkcije preklope, svaka verzija funkcije može da izvodi proizvoljne
 operacije, odnosno nema pravila koje bi diktiralo da preklopljene funkcije
 moraju da budu u nekakvoj vezi.
 Međutim, iako mogu da se koriste ista imena za funkcije koje nisu ni u
 kakvoj vezi, to nije dobar stil u programiranju, jer poništava ideju preklapanj
a.
\end_layout

\begin_layout Subsection
Podrazumevani argumenti funkcija
\end_layout

\begin_layout Standard
Parametru funkcije
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!podrazumevani argumenti
\end_layout

\end_inset

 može da se dodeli podrazumevana (default) vrednost koja će se koristiti
 kada u pozivu funkcije nije naveden odgovarajući argument za taj parametar.
 Podrazumevani argument zadaje se slično inicijalizaciji promenljive.
 Na primer,
\end_layout

\begin_layout Standard

\family typewriter
\size small
void mojaFunkcija(int x=0, int y= 100);
\end_layout

\begin_layout Standard
deklariše podrazumevane vrednosti svojih parametara na 0 i 100, redom.
 Sada se 
\family typewriter
mojaFunkcija() 
\family default
može pozvati na jedan od sledeća tri načina:
\end_layout

\begin_layout Standard

\family typewriter
\size small
mojaFunkcija(1, 2) //direktno prosledjivanje vrednosti
\end_layout

\begin_layout Standard

\family typewriter
\size small
mojaFunkcija(10); //promenljivoj x se prosledjuje vrednost, y je 100
\end_layout

\begin_layout Standard

\family typewriter
\size small
mojaFunkcija(); //x je 0 a y je 100
\end_layout

\begin_layout Standard
Podrazumevane (default) vrednosti mogu biti navedene samo jednom, i to prilikom
 prve deklaracije funkcije.
 Svi parametri koji prihvataju podrazumevane vrednosti moraju biti zadati
 sa desne strane parametara koji nemaju podrazumevane vrednosti; kada se
 počne sa dodeljivanjem podrazumevanih vrednosti, više se ne može zadavati
 parametar bez podrazumevane vrednosti:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void funkcija(int a=10, int b); //pogresno!
\end_layout

\begin_layout Standard
Iako su podrazumevani argumenti snažna alatka kada se ispravno koriste,
 često se dešava i da se zloupotrebljavaju.
 Njihova svrha je da omoguće funkciji da obavi svoj zadatak efikasno i lako,
 ali uz zadržavanje prilagodljivosti.
 U skladu sa tim, svi podrazumevani argumenti trebalo bi da odražavaju način
 na koji se funkcija inače koristi, odnosno zamenu za to.
 Ako ne postoji neka određena vrednost koja bi se dodelila parametru, nema
 razloga da se uvodi podrazumevani parametar.
 Zapravo, u tom slučaju razumljivost kôda bi bila smanjena.
 Takođe, podrazumevani argumenti ne bi smeli da prouzrokuju štetne sporedne
 efekte.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void saberi(int x=0, int y=100);
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
saberi(20, 30); 
\end_layout

\begin_layout LyX-Code

\size small
saberi(20); 
\end_layout

\begin_layout LyX-Code

\size small
saberi(); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void saberi(int x, int y) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << x + y << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
50
\end_layout

\begin_layout Standard

\series bold
\size small
120
\end_layout

\begin_layout Standard

\series bold
\size small
100
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Section
Rekurzivne funkcije
\end_layout

\begin_layout Standard
Rekurzivne 
\begin_inset Index idx
status open

\begin_layout Plain Layout
rekurzija 
\end_layout

\end_inset

funkcije
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!rekurzivne
\end_layout

\end_inset

 su funkcije koje pozivaju same sebe.
 Prava svrha rekurzivnih funkcija u programiranju jeste da svedu složene
 probleme na problem koji se može rešiti.
 Pogodne su za rešavanje problema koji se elegantnije rešavaju rekurzijom,
 kao što je na primer izračunavanje faktorijela.
\end_layout

\begin_layout Standard
Većina rekurzivnih funkcija može se napisati i 
\begin_inset Quotes eld
\end_inset

iterativno
\begin_inset Quotes erd
\end_inset

, uz korišćenje petlji.
 Rekurzija se izvršava sporije od iteracija, zato što se pri svakom pozivu
 funkcije prave nove kopije argumenata i lokalnih promenljivih na steku.
 Treba takođe voditi računa i o 
\begin_inset Quotes eld
\end_inset

dubini
\begin_inset Quotes erd
\end_inset

 rekurzije, jer se može desiti i da se stek “istroši”.
 Kao primer rekurzivne funkcije navodimo program koji ispisuje string obrnutim
 redosledom uz korišćenje pokazivačke aritmetike.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void ispisiStringNaopako(char*);
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char str[] = "Ovo je test"; 
\end_layout

\begin_layout LyX-Code

\size small
ispisiStringNaopako(str); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void ispisiStringNaopako(char *p) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
if(*p) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
ispisiStringNaopako(p+1); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << *p; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
\align left

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard
\align left

\series bold
\size small
tset ej ovO
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
obrniString()
\family default
 kao argument prihvata pokazivač na tip 
\family typewriter
char
\family default
; pošto je ime niza znakova zapravo pokazivač na prvi element niza, poziv
 funkcije
\family typewriter
 
\begin_inset Newline linebreak
\end_inset

obrniString()
\family default
 iz funkcije 
\family typewriter
main()
\family default
 sa argumentom tipa 
\family typewriter
char[]
\family default
 je validan.
 Funkcija 
\family typewriter
obrniString()
\family default
 poziva samu sebe, ali kao argument prosleđuje sledeći znak u nizu (pomeranjem
 pokazivača na sledeći znak naredbom 
\family typewriter
p+1
\family default
).
 Rekurzivno pozivanje se prekida kada se naiđe na poslednji znak u nizu,
 tj.
 nulu; tada se izvršava 
\family typewriter
else
\family default
 deo naredbe.
 Prilikom povratka iz funkcije izvršava se prva naredba iza mesta gde je
 funkcija pozvana, a to je 
\family typewriter
cout
\family default
.
 Tako se string ispisuje unazad.
\end_layout

\begin_layout Section*
Pitanja
\end_layout

\begin_layout Standard
1.
 Pravilno deklarisana funkcija je: 
\end_layout

\begin_layout Standard
a) main[]{ }
\end_layout

\begin_layout Standard
b) main{}( )
\end_layout

\begin_layout Standard
c) main(){ }
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
2.
 Funkcija čiji je povratni tip 
\family typewriter
void
\family default
: 
\end_layout

\begin_layout Standard
a) vraća celobrojnu vrednost 
\end_layout

\begin_layout Standard
b) vraća vrednost tipa 
\family typewriter
void
\family default
 
\end_layout

\begin_layout Standard
c) ne vraća vrednost 
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
3.
 Ako je data funkcija 
\family typewriter
double nadji(int x, int y, bool b) { ...
 }
\family default
 
\end_layout

\begin_layout Standard
a) ime funkcije je 
\family typewriter
nadji
\end_layout

\begin_layout Standard
b) povratna vrednost je
\family typewriter
 int
\end_layout

\begin_layout Standard
c) povratna vrednost je 
\family typewriter
bool
\end_layout

\begin_layout Standard
d) broj parametara funkcije je tri 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
4.
 Na koji način funkcija vraća vrednost na mesto odakle je pozvana? 
\end_layout

\begin_layout Standard
a) automatski
\end_layout

\begin_layout Standard
b) svojim imenom
\end_layout

\begin_layout Standard
c) preko parametara u zagradi 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
5.
 Funkcija koja se poziva iz programa main: 
\end_layout

\begin_layout Standard
a) mora biti deklarisana u programu main
\end_layout

\begin_layout Standard
b) mora biti deklarisana pre programa main
\end_layout

\begin_layout Standard
c) može biti deklarisana bilo gde u programu 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
6.
 Parametri se u funkciju mogu preneti:
\end_layout

\begin_layout Standard
a) po vrednosti ili po adresi
\end_layout

\begin_layout Standard
b) po imenu, vrednosti ili adresi
\end_layout

\begin_layout Standard
c) po adresi, imenu ili referenci 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
7.
 Definisanje različitih funkcija istog imena je: 
\end_layout

\begin_layout Standard
a) dozvoljeno
\end_layout

\begin_layout Standard
b) nije dozvoljeno
\end_layout

\begin_layout Standard
c) zavisi od prethodnog koda 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
8.
 Niz može da bude povratni tip funkcije.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
9.
 Niz može da bude parametar funkcije.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
10.
 U jeziku C++ postoji funkcija koja ne mora da ima prototip.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
11.
 Standardni način prenosa argumenata u funkciju je: 
\end_layout

\begin_layout Standard
a) po vrednosti
\end_layout

\begin_layout Standard
b) po adresi
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
12.
 Preklopljene funkcije mogu da se razlikuju samo po povratnom tipu.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
13.
 Deklaracija funkcije 
\family typewriter
void f(int a=10, int b);
\family default
 je ispravna.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
14.
 Kada se funkciji argumenti prenose po vrednosti, ona može da ih izmeni.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
15.
 Kada se funkciji argumenti prenose po adresi, ona može da ih izmeni.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
16.
 Prototip funkcije sprečava njeno pozivanje sa neodgovarajućim brojem i(li)
 tipovima argumenata.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
17.
 Naredba koja se koristi unutar tela funkcije za povratak iz funkcije i
 vraćanje rezultata je:
\end_layout

\begin_layout Standard
a) void
\end_layout

\begin_layout Standard
b) return
\end_layout

\begin_layout Standard
c) public
\end_layout

\begin_layout Standard
d) static 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
18.
 Globalne promenljive su dostupne:
\end_layout

\begin_layout Standard
a) samo jednom delu programa 
\end_layout

\begin_layout Standard
b) celom programu
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
19.
 Opseg važenja globalne promenljive je:
\end_layout

\begin_layout Standard
a) ceo program
\end_layout

\begin_layout Standard
b) funkcija main
\end_layout

\begin_layout Standard
c) ceo program posle mesta deklarisanja 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
20.
 Šta označava reč 
\family typewriter
static
\family default
 ako se napiše ispred promenljive?
\end_layout

\begin_layout Standard
a) promenljiva zadržava vrednost tokom izvršavanja programa
\end_layout

\begin_layout Standard
b) promenljiva se ne nalazi u memoriji 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
21.
 Oblast važenja lokalne promenljive je: 
\end_layout

\begin_layout Standard
a) ceo kôd
\end_layout

\begin_layout Standard
b) blok u kojem je definisana
\end_layout

\begin_layout Standard
c) funkcija main 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
22.
 Promenljiva koja je deklarisana unutar funkcije je:
\end_layout

\begin_layout Standard
a) globalna 
\end_layout

\begin_layout Standard
b) statička
\end_layout

\begin_layout Standard
c) lokalna 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
23.
 Statička globalna promenljiva je vidljiva samo u datoteci u kojoj je deklarisan
a.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
24.
 Kada se poziva funkcija čiji je parametar referenca, ispred naziva stvarnog
 argumenta funkcije treba da bude &.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
25.
 Funkcija nikako ne bi trebalo da vraća referencu na lokalnu promenljivu.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
26.
 Reference se mogu preusmeravati na druge objekte, isto kao pokazivači.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
27.
 Korišćenje referenci olakšavanje prenos argumenata u funkciju: 
\end_layout

\begin_layout Standard
a) po vrednosti
\end_layout

\begin_layout Standard
b) po adresi
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
28.
 Moguće je definisati niz referenci.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
29.
 Ako je parametar funkcije konstantna referenca (const &), ona sme da promeni
 vrednost stvarnog argumenta sa kojim je pozvana.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
30.
 Funkcije u jeziku C++ mogu se rekurzivno pozivati.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Chapter
Klase i objekti
\end_layout

\begin_layout Standard
Dosad smo u knjizi proučavali primere programa koji nisu bili objektno orijentis
ani, već su koristili tehnike proceduralnog programiranja.
 Da bi se pisali objektno orijentisani programi, moraju se koristiti klase,
 i njihovi primerci, odnosno objekti.
 Klase i objekti su toliko važni za C++ da im je ostatak knjige u potpunosti
 posvećen.
\end_layout

\begin_layout Section
Kako i zašto je nastalo objektno orijentisano programiranje?
\end_layout

\begin_layout Standard
Tehnike proceduralnog programiranja
\begin_inset Index idx
status open

\begin_layout Plain Layout
proceduralno programiranje
\end_layout

\end_inset

 usredsređene su na procedure, odnosno operacije koje se obavljaju u programu.
 Podaci se obično čuvaju u promenljivama, a sa njima rade funkcije.
 Podaci i funkcije koje rade sa njima potpuno su odvojeni.
 Program radi tako što se promenljive prosleđuju funkcijama, koje rade nešto
 sa njima i vraćaju rezultat.
 Dakle, proceduralno programiranje je prvenstveno orijentisano na funkcije.
 Međutim, ovakav pristup prouzrokuje dva velika problema:
\end_layout

\begin_layout Itemize
Preterano korišćenje globalnih podataka: programeri često pribegavaju čuvanju
 najvažnijih podataka u globalnim promenljivama, da bi im se lako pristupalo
 iz svih funkcija u programu.
 Međutim, tako se istovremeno otvaraju vrata za nehotično uništavanje ili
 oštećivanje najvažnijih podataka.
\end_layout

\begin_layout Itemize
Projektovanje složenih programa koji se teško održavaju i menjaju: Iako
 je preporučljivo da se program učini veoma modularnim, tj.
 da se izdeli u veliki broj logičkih funkcija, postoji granica koju je programer
 u stanju da sagleda.
 Realni programi imaju na stotine funkcija čiju interakciju je veoma teško
 sagledati, pa menjanje kôda postaje izuzetno teško.
 Pre bilo kakve izmene potrebno je razumeti kako će promena uticati na druge
 delove programa.
\end_layout

\begin_layout Standard
Kako su programi postajali složeniji, programeri su shvatili da im je potreban
 mehanizam koji će olakšati projektovanje i održavanje velikih aplikacija.
 Objektno orijentisan pristup su smislili programeri kao način da sebi olakšaju
 život, tj.
 kao odgovor na softversku krizu koja se ogledala u tome što se softver
 projektovao duže nego što je predviđeno, koštao više nego što je predviđeno
 i nije zadovoljavao sve postavljene zahteve.
 
\end_layout

\begin_layout Standard
Objektno orijentisan
\begin_inset Index idx
status open

\begin_layout Plain Layout
objektno orijentisano programiranje
\end_layout

\end_inset

 pristup, kako mu i ime kaže, usredsređen je na objekte koji objedinjuju
 podatke i funkcije koje rade sa njima.
 Najvažniji princip koji se koristi prilikom definisanja objekata jeste
 
\shape italic
apstrakcija
\shape default
.
 Objekti su apstrakcije pojmova iz stvarnog sveta, što znači da se modeliraju
 tako da sadrže samo one osobine koje su bitne za program.
 Na primer, ako klasa Osoba modelira pojam osobe iz stvarnog sveta, programu
 je možda važno da zna koliko ta osoba ima godina i kako se zove, a nije
 bitno kog je pola.
\end_layout

\begin_layout Section
Pojam klase
\end_layout

\begin_layout Standard
Mehanizam klasa
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!definicija
\end_layout

\end_inset

 omogućuje korisnicima da definišu sopstvene tipove podataka.
 Zbog toga se klase često nazivaju i korisnički definisani tipovi podataka.
 Klase se koriste kao šablon kojim se modeliraju objekti sličnih svojstava,
 a objekti
\begin_inset Index idx
status open

\begin_layout Plain Layout
objekti
\end_layout

\end_inset

 su konkretni primerci (instance) klase.
 Uočavanje zajedničkih osobina (svojstava) objekata i njihovo grupisanje
 u klasu naziva se apstrakcija.
 Klasa sadrži 
\shape italic
podatke članove
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!podaci članovi
\end_layout

\end_inset

 (member data) i 
\shape italic
funkcije članice
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!funkcije članice
\end_layout

\end_inset

 ili metode (member functions).
 Podaci članovi najčešće predstavljaju unutrašnjost klase, tj.
 njenu realizaciju, a funkcije članice njen interfejs, odnosno ono što se
 može raditi sa njenim objektima.
 
\end_layout

\begin_layout Standard
Klasa se deklariše pomoću ključne reči 
\family typewriter
class
\family default
.
 Opšti oblik deklaracije klase je 
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
\size small
class ime { lista članova } lista objekata;
\shape default
 
\end_layout

\begin_layout Standard
Ime klase
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!deklaracija
\end_layout

\end_inset

 postaje novi tip koji se može koristiti za kreiranje objekata klase (odnosno
 promenljivih koje su tipa te klase).
 Iza deklaracije klase mogu se navesti nazivi objekata, ali to nije obavezno.
 Klasa može da sadrži privatne i javne članove; standardno su svi članovi
 klase privatni.
 To znači da im mogu pristupati isključivo drugi članovi iste klase.
 Na taj način postiže se OO princip kapsuliranja ili skrivanja podataka.
 Da bi se delovi klase učinili javnim, tj.
 da bi se omogućio pristup iz drugih delova programa, oni se moraju deklarisati
 kao javni pomoću ključne reči 
\family typewriter
public
\begin_inset Index idx
status open

\begin_layout Plain Layout
public
\end_layout

\end_inset


\family default
.
 Klase se po pravilu projektuju tako da su podaci članovi privatni, a funkcije
 članice javne.
\end_layout

\begin_layout Standard
Iako nema sintaksnog pravila koje to nalaže, dobro projektovana klasa trebalo
 bi da definiše samo jednu logičku celinu.
 Na primer, u klasi koja čuva imena i telefonske brojeve ne bi trebalo da
 se nađu i informacije o berzi, broju sunčanih sati u godini niti bilo šta
 drugo.
 Dobro projektovane klase grupišu logički povezane informacije.
 
\end_layout

\begin_layout Standard
Da ponovimo: u jeziku C++, klasa kreira nov tip podataka koji se može koristiti
 za kreiranje objekata.
 Klasa je logički okvir koji definiše vezu između svojih članova.
 Kada se deklariše promenljiva tipa klase, zapravo se kreira objekat te
 klase i za njega se odvaja prostor u memoriji.
\end_layout

\begin_layout Standard
Kao primer proučićemo klasu koja čuva informacije o vozilima, kao što su
 automobili, kombiji i kamioni.
 Tu klasu nazvaćemo 
\family typewriter
Vozilo
\family default
 i u nju ćemo smestiti tri podatka o vozilu: broj mesta za putnike, kapacitet
 rezervoara za gorivo i prosečnu potrošnju goriva.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class Vozilo { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
public:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int brojMesta; //broj mesta za sedenje
\end_layout

\begin_layout LyX-Code

\size small
int kapacitetRezervoara; //kapacitet rezervoara u litrama
\end_layout

\begin_layout LyX-Code

\size small
int potrosnja; //prosecna potrosnja u litrama na 100 km
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout Standard
Klasa 
\family typewriter
Vozilo
\family default
 ima tri podatka člana: 
\family typewriter
putnici
\family default
, 
\family typewriter
rezervoar
\family default
 i 
\family typewriter
potrosnja
\family default
.
 Klasa 
\family typewriter
Vozilo
\family default
 za sada nema funkcija članica; njih ćemo dodati kasnije.
\end_layout

\begin_layout Standard
Opšti oblik deklarisanja podataka članova u klasi je:
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
\size small
tip promenljiva;
\shape default
\size default
 
\end_layout

\begin_layout Standard
Dakle, podaci članovi deklarišu se na sličan način kao "obične
\begin_inset Quotes srd
\end_inset

 promenljive.
 U klasi 
\family typewriter
Vozilo
\family default
 ispred svih podataka članova nalazi se specifikator javnog pristupa 
\begin_inset Newline linebreak
\end_inset

(
\family typewriter
public
\family default
).
 To omogućuje da im se pristupa iz kôda koji se nalazi izvan klase 
\family typewriter
Vozilo
\family default
.
 Definicija klase kreira nov tip podataka, koji se u ovom slučaju zove 
\family typewriter
Vozilo
\family default
.
 To ime se može koristiti za deklarisanje promenljivih tipa 
\family typewriter
Vozilo
\family default
, što su zapravo objekti klase 
\family typewriter
Vozilo
\family default
.
 Zapamtite da je deklaracija klase samo opis tipa i njome se ne pravi stvarni
 objekat.
 Zbog toga prethodna deklaracija ne kreira nikakve objekte tipa 
\family typewriter
Vozilo
\family default
.
 Da bi se kreirao objekat klase 
\family typewriter
Vozilo
\family default
, treba upotrebiti naredbu za deklaraciju sledećeg oblika:
\end_layout

\begin_layout Standard

\family typewriter
\size small
Vozilo kombi; //kreira objekat klase Vozilo koji se zove kombi
\size default
 
\end_layout

\begin_layout Standard
Kreiranje objekata klase ponekad se zove i instanciranje klase.
 Kada se izvrši ova naredba, 
\family typewriter
kombi
\family default
 će postati primerak (objekat) klase 
\family typewriter
Vozilo
\family default
.
 Kad god se kreira primerak klase, kreira se objekat koji sadrži sopstvenu
 kopiju podataka članova klase.
 To znači da će svaki objekat klase 
\family typewriter
Vozilo
\family default
 imati svoje kopije promenljivih (podataka članova) 
\family typewriter
putnici
\family default
, 
\family typewriter
rezervoar
\family default
 i 
\family typewriter
potrosnja
\family default
.
 
\end_layout

\begin_layout Standard
Operator tačka
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!.
\end_layout

\end_inset

 povezuje ime objekta sa njegovim podacima članovima.
 Opšti oblik operatora tačka je 
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
\size small
objekat.član
\size default
 
\end_layout

\begin_layout Standard
Objekat se zadaje sa leve strane, a podatak član sa desne.
 Na primer, da bi se podatku članu 
\family typewriter
gorivo
\family default
 objekta 
\family typewriter
kombi
\family default
 dodelila vrednost 50, koristi se sledeća naredba:
\end_layout

\begin_layout Standard

\family typewriter
\size small
kombi.gorivo = 50; 
\end_layout

\begin_layout Standard
Operator tačka u opštem slučaju koristi se za pristup podacima članovima
 i funkcijama članicama klase.
 Evo primera programa koji koristi klasu 
\family typewriter
Vozilo
\family default
:
\end_layout

\begin_layout LyX-Code

\size small
class Vozilo { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int brojMesta; 
\end_layout

\begin_layout LyX-Code

\size small
int kapacitetRezervoara; 
\end_layout

\begin_layout LyX-Code

\size small
int potrosnja; 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Vozilo kombi; 
\end_layout

\begin_layout LyX-Code

\size small
Vozilo automobil; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
double kilometrazaKombi, kilometrazaAuto; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//dodela vrednosti podacima clanovima objekta kombi 
\end_layout

\begin_layout LyX-Code

\size small
kombi.brojMesta = 7; 
\end_layout

\begin_layout LyX-Code

\size small
kombi.kapacitetRezervoara = 60; 
\end_layout

\begin_layout LyX-Code

\size small
kombi.potrosnja = 7.;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//dodela vrednosti podacima clanovima objekta automobil 
\end_layout

\begin_layout LyX-Code

\size small
automobil.brojMesta = 5; 
\end_layout

\begin_layout LyX-Code

\size small
automobil.kapacitetRezervoara = 50; 
\end_layout

\begin_layout LyX-Code

\size small
automobil.potrosnja = 5.;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
autonomijaKombi = kombi.kapacitetRezervoara / 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
kombi.potrosnja * 100; 
\end_layout

\begin_layout LyX-Code

\size small
autonomijaAuto = automobil.kapacitetRezervoara / 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
automobil.potrosnja * 100; 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
cout << "U kombi staje " << kombi.brojMesta << 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
" putnika i sa punim rezervoarom prelazi " 
\end_layout

\begin_layout LyX-Code

\size small
<< autonomijaKombi << " kilometara." << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cout << "U auto staje " << automobil.brojMesta << 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
" putnika i sa punim rezervoarom prelazi " 
\end_layout

\begin_layout LyX-Code

\size small
<< autonomijaAuto << " kilometara." << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
U kombi staje 7 putnika i sa punim rezervoarom prelazi 800 kilometara.
\end_layout

\begin_layout Standard

\series bold
\size small
U auto staje 5 putnika i sa punim rezervoarom prelazi 1000 kilometara.
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
main()
\family default
 kreira dva objekta klase 
\family typewriter
Vozilo
\family default
 koji se zovu 
\family typewriter
kombi
\family default
 i 
\family typewriter
automobil
\family default
.
 Zatim pristupa podacima članovima tih objekata dodeljujući im vrednosti.
 Kôd u funkciji 
\family typewriter
main()
\family default
 može da pristupi članovima klase 
\family typewriter
Vozilo
\family default
 zato što su deklarisani kao javni (
\family typewriter
public
\family default
).
 U prethodnom primeru važno je uočiti da svaki objekat ima sopstvene kopije
 svojih podataka članova definisanih u klasi.
 Između objekata 
\family typewriter
kombi
\family default
 i 
\family typewriter
automobil
\family default
 nema nikakve veze osim činjenice da su istog tipa: svaki od njih ima sopstvene
 vrednosti za podatke članove 
\family typewriter
brojMesta
\family default
, 
\family typewriter
kapacitetRezervoara
\family default
 i 
\family typewriter
potrosnja
\family default
.
\end_layout

\begin_layout Standard
Većina klasa osim podataka članova ima i 
\shape italic
funkcije članice
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije članice klase
\end_layout

\end_inset

.
 U opštem slučaju, funkcije članice rade sa podacima članovima i komuniciraju
 sa drugim delovima programa.
 Funkcija 
\family typewriter
main()
\family default
 u prethodnom primeru računala je autonomiju vozila tako što je kapacitet
 rezervoara delila potrošnjom.
 To je zadatak koji tipično treba da obavlja funkcija članica klase, koju
 ćemo sada dodati u klasu 
\family typewriter
Vozilo
\family default
 zadavanjem njenog prototipa u deklaraciji:
\end_layout

\begin_layout LyX-Code

\size small
class Vozilo { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int brojMesta; 
\end_layout

\begin_layout LyX-Code

\size small
int kapacitetRezervoara; 
\end_layout

\begin_layout LyX-Code

\size small
int potrosnja;
\end_layout

\begin_layout LyX-Code

\size small
int autonomija(); //funkcija clanica klase
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Pošto se u deklaraciji klase navodi samo prototip funkcije članice, a ne
 i njena implementacija, na mestu gde se piše implementacija funkcije članice
 mora se navesti kojoj klasi ona pripada.
 Za tu svrhu se koristi operator razrešenja doseg
\begin_inset Index idx
status open

\begin_layout Plain Layout
doseg
\end_layout

\end_inset

a (::):
\end_layout

\begin_layout LyX-Code

\size small
//implementacija funkcije clanice autonomija
\end_layout

\begin_layout LyX-Code

\size small
int Vozilo::autonomija() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return kapacitetRezervoara / potrosnja * 100; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
Operator razrešenja dosega :: povezuje ime klase sa nazivom njene funkcije
 članice da bi kompajler znao na koju klasu se odnosi funkcija članica.
 Pošto više različitih klasa mogu da imaju funkcije članice istog imena,
 operator :: je neophodan prilikom implementacije funkcije članice.
 U ovom slučaju, operator razrešenja dosega
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!::
\end_layout

\end_inset

 povezuje funkciju 
\family typewriter
autonomija() 
\family default
sa klasom 
\family typewriter
Vozilo
\family default
, odnosno deklariše da je funkcija 
\family typewriter
autonomija()
\family default
 u dosegu klase 
\family typewriter
Vozilo
\family default
.
 Telo funkcije autonomija ima samo jednu naredbu; pošto svaki objekat tipa
 
\family typewriter
Vozilo
\family default
 ima sopstvenu vrednost podataka članova 
\family typewriter
kapacitetRezervoara
\family default
 i 
\family typewriter
potrosnja
\family default
, izračunavaće se autonomija za svaki objekat posebno.
 
\end_layout

\begin_layout Standard
Primetite da je sintaksa definicije funkcije članice takva da se prvo navodi
 njen povratni tip.
 
\end_layout

\begin_layout Standard
Unutar funkcije 
\family typewriter
autonomija()
\family default
 podacima članovima 
\family typewriter
kapacitetRezervoara
\family default
 i
\begin_inset Newline linebreak
\end_inset

 
\family typewriter
potrosnja
\family default
 pristupa se direktno, bez navođenja imena objekta ili tačke.
 Kada funkcija članica koristi podatak član svoje klase, ona to radi bez
 eksplicitnog pozivanja objekta.
 To je zato što se funkcija članica nikad ne poziva samostalno, već se uvek
 poziva za neki objekat svoje klase, pa nema potrebe da se objekat ponovo
 navodi.
 
\end_layout

\begin_layout Standard
Postoje dva načina pozivanja funkcije članice.
 Ako se ona poziva iz kôda koji se nalazi izvan klase, mora se pozivati
 preko nekog objekta i operatora tačka:
\end_layout

\begin_layout Standard

\family typewriter
kombi.autonomija(); 
\end_layout

\begin_layout Standard
Kada se pozove na ovaj način, funkcija 
\family typewriter
autonomija()
\family default
 radi sa vrednostima podataka članova objekta 
\family typewriter
kombi
\family default
.
 Drugi način pozivanja funkcije članice je iz druge funkcije članice iste
 klase.
 Kada jedna funkcija članice klase poziva drugu funkciju članicu klase,
 to može da uradi direktno, bez operatora tačka, jer kompajler već zna sa
 kojim objektom radi.
\end_layout

\begin_layout Section
Kontrola pristupa članovima klase
\end_layout

\begin_layout Standard
Članovi (podaci ili metode) klase
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!kontrola pristupa članovima
\end_layout

\end_inset

 koji se nalaze ispred specifikacije 
\family typewriter
private:
\family default
 zaštićeni su od pristupa spolja (oni su sakriveni, odnosno kapsulirani).
 To su privatni članovi klase i njima mogu pristupati samo funkcije članice
 iste klase.
 Da bi se deo klase učinio javnim, tj.
 da bi bio vidljiv u kôdu izvan klase, navodi se specifikacija
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!specifikator 
\family typewriter
public
\end_layout

\end_inset

 
\family typewriter
public:
\family default
 Članovi iza specifikacije 
\family typewriter
public:
\family default
 dostupni su izvan klase i nazivaju se javnim članovima klase.
\end_layout

\begin_layout Standard
Kljućne reči 
\family typewriter
public
\family default
 i 
\family typewriter
private
\family default
 zovu se 
\shape italic
specifikatori pristupa
\shape default
 (access specifiers).
 Iza njih se u deklaraciji klase uvek navodi dvotačka.
\end_layout

\begin_layout Standard
Privatnim članovima klase
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!specifikator 
\family typewriter
private
\end_layout

\end_inset

 obično se pristupa preko javnih funkcija članica.
 Kada funkcija članica koristi privatan podatak član svoje klase, pristupa
 mu direktno, bez korišćenja operatora tačka.
 Funkcija članica se uvek poziva za neki objekat svoje klase.
 
\end_layout

\begin_layout Standard
Ako se ne navede specifikator pristupa, svi članovi klase su podrazumevano
 privatni.
 Ipak, dobar stil programiranja nalaže da se i pored toga specifikator private
 navede za eksplicitno deklarisanje privatnih promenljivih.
 Takođe, po pravilu se u deklaraciji klase prvo navode privatni, a tek onda
 javni članovi, mada ne postoji pravilo koje to zahteva.
 
\end_layout

\begin_layout Standard
Javnom podatku članu klase može se pristupati iz drugih delova programa.
 Sintaksa za pristup javnom podatku članu je ista kao sintaksa za pozivanje
 funkcije članice: ime objekta, tačka, ime podatka člana.
 Sledeći jednostavan program ilustruje korišćenje javne promenljive:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class mojaKlasa { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
public: int i, j, k; //dostupni celom programu 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
mojaKlasa a, b; 
\end_layout

\begin_layout LyX-Code

\size small
a.i = 100; //pristup i, j, k je u redu 
\end_layout

\begin_layout LyX-Code

\size small
a.j = 4; 
\end_layout

\begin_layout LyX-Code

\size small
a.k = a.i * a.j; 
\end_layout

\begin_layout LyX-Code

\size small
b.k = 12; // a.k i b.k su razliciti
\end_layout

\begin_layout LyX-Code

\size small
cout << a.k << " " << b.k; //ispisuje 400 12
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Section
Inline funkcije članice
\end_layout

\begin_layout Standard
Kada je telo funkcije članice ne samo deklarisano, već i definisano unutar
 deklaracije 
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!inline 
\end_layout

\end_inset

klase
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!inline funkcije
\end_layout

\end_inset

, kaže se da je funkcija ugrađena (inline).
 
\end_layout

\begin_layout LyX-Code

\size small
class Brojac {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
private:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int i;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int broj { return ++i; } //inline funkcija clanica
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Inline funkcije od prevodioca zahtevaju da kôd tela funkcije ugradi neposredno
 u kôd programa na mestima poziva te funkcije, umesto uobičajenog postupka
 poziva funkcije.
 Inline je zapravo zahtev za optimizaciju kôda koji kompajler može, ali
 ne mora da ispuni.
 Funkcija članica se može se deklarisati kao 
\family typewriter
inline
\family default
 i van deklaracije klase.
 To se radi navođenjem specifikatora 
\family typewriter
inline
\family default
 ispred deklaracije funkcije, kao u sledećem primeru:
\end_layout

\begin_layout LyX-Code

\size small
inline int f() { 
\end_layout

\begin_layout LyX-Code

\size small
// ...
 
\end_layout

\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
Mehanizam ugrađivanja funkcija treba pažljivo primenjivati, samo za vrlo
 jednostavne funkcije.
 Pri svakom pozivanju funkcije i povratku iz nje mora da se izvrši niz naredbi
 (npr.
 stavljanje argumenata na stek i skidanje vrednosti argumenata sa steka
 prilikom povratka).
 Ako se funkcija ugradi program se ubrzava, ali ako je suviše složena, program
 postaje duži pa ugrađivanje ne poboljšava efikasnost.
 
\end_layout

\begin_layout Section
Konstruktori i destruktori
\end_layout

\begin_layout Standard
U prethodnim primerima podacima članovima objekata klase 
\family typewriter
Vozilo
\family default
 ručno smo dodeljivali vrednosti pomoću niza naredbi:
\end_layout

\begin_layout Standard

\family typewriter
\size small
kombi.brojMesta = 7; 
\end_layout

\begin_layout Standard

\family typewriter
\size small
kombi.potrosnja = 7; 
\end_layout

\begin_layout Standard
Ovakav pristup ručnog dodeljivanja vrednosti očigledno nije pogodan jer
 su mogućnosti grešaka velike.
 C++ nudi bolji način za inicijalizaciju podataka članova, a to je konstruktor.
 
\shape italic
Konstruktor
\shape default
 je funkcija članica klase koja se automatski poziva kada se kreira objekat.
 Ima isto ime kao klasa, ali nema nikakav povratni tip (čak ni 
\family typewriter
void
\family default
).
 Sintaksa konstruktora
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!konstruktori
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
konstruktori!definicija
\end_layout

\end_inset

 izgleda ovako: 
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
ime_klase( ) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
//telo konstruktora
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
} 
\end_layout

\begin_layout Standard
Uobičajeno se konstruktor koristi za dodelu početnih vrednosti podacima
 članovima klase, ili za izvođenje drugih operacija potrebnih za kreiranje
 objekta.
 
\end_layout

\begin_layout Standard
Često se dešava da je i prilikom uništavanja potrebno obaviti određene operacije
, na primer dealocirati memoriju koja je zauzeta ili zatvoriti neku otvorenu
 datoteku.
 U jeziku C++ postoji posebna funkcija članica za tu namenu koja se zove
 
\shape italic
destruktor
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!destruktori
\end_layout

\end_inset

.
 Destruktor ima isto ime kao klasa, ispred koga se dodaje znak ~: 
\end_layout

\begin_layout LyX-Code

\family typewriter
\shape slanted
\size small
~ime_klase( ) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
//telo destruktora
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
} 
\end_layout

\begin_layout Standard
Poput konstruktora, ni destruktor
\begin_inset Index idx
status open

\begin_layout Plain Layout
destruktori!definicija
\end_layout

\end_inset

 nema povratni tip, a ne može imati ni argumente.
 Postoji samo jedan destruktor za klasu; ako se posebno ne napiše, kompajler
 će ga automatski kreirati.
 Evo jednostavnog primera klase sa konstruktorom i destruktorom: 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\size small
class Primer { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
public:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Primer(); //konstruktor 
\end_layout

\begin_layout LyX-Code

\size small
~Primer(); //destruktor
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
Primer::Primer() {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "u konstruktoru"<<endl;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
Primer::~Primer() {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "u destruktoru" << endl;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Primer obj;
\end_layout

\begin_layout LyX-Code

\size small
cout << "program koji demonstrira objekat" << endl;
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
u konstruktoru
\end_layout

\begin_layout Standard

\series bold
\size small
program koji demonstrira objekat
\end_layout

\begin_layout Standard

\series bold
\size small
u destruktoru
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
U ovom slučaju destruktor samo prikazuje poruku, ali u korisnim programima
 on se koristi za oslobađanje resursa (npr.
 memorije ili datoteka) koje koristi objekat klase.
\end_layout

\begin_layout Subsection
Kada se izvršavaju konstruktori i destruktori?
\end_layout

\begin_layout Standard
Konstruktor lokalnog objekta izvršava se kada kompajler naiđe na naredbu
 deklaracije objekta.
 Destruktori lokalnih objekata izvršavaju se u obrnutom redosledu od konstruktor
a.
 Konstruktori globalnih objekata pozivaju se pre nego što počne izvršavanje
 funkcije 
\family typewriter
\size small
main()
\family default
\size default
.
 Globalni konstruktori izvršavaju se u redosledu deklarisanja unutar iste
 datoteke.
 Globalni destruktori izvršavaju se u obrnutom redosledu nakon završetka
 funkcije 
\family typewriter
\size small
main()
\family default
\size default
.
 Sledeći program ilustruje redosled pozivanja konstruktora
\begin_inset Index idx
status open

\begin_layout Plain Layout
konstruktori!redosled pozivanja
\end_layout

\end_inset

 i destruktora
\begin_inset Index idx
status open

\begin_layout Plain Layout
destruktori!redosled pozivanja
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class mojaKlasa { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int ko; 
\end_layout

\begin_layout LyX-Code

\size small
mojaKlasa(int id); 
\end_layout

\begin_layout LyX-Code

\size small
~mojaKlasa(); 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
} glob_ob1(1), glob_ob2(2);
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
mojaKlasa::mojaKlasa(int id) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Inicijalizuje se " << id << endl; 
\end_layout

\begin_layout LyX-Code

\size small
ko = id; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
mojaKlasa::~mojaKlasa() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Unistava se " << ko << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
mojaKlasa lokalni_ob1(3); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Ovo nece biti prvi prikazan red." << endl; 
\end_layout

\begin_layout LyX-Code

\size small
mojaKlasa lokalni_ob2(4); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Inicijalizuje se 1 
\end_layout

\begin_layout Standard

\series bold
\size small
Inicijalizuje se 2 
\end_layout

\begin_layout Standard

\series bold
\size small
Inicijalizuje se 3 
\end_layout

\begin_layout Standard

\series bold
\size small
Ovo nece biti prvi prikazan red.
 
\end_layout

\begin_layout Standard

\series bold
\size small
Inicijalizuje se 4 
\end_layout

\begin_layout Standard

\series bold
\size small
Unistava se 4
\end_layout

\begin_layout Standard

\series bold
\size small
Unistava se 3 
\end_layout

\begin_layout Standard

\series bold
\size small
Unistava se 2 
\end_layout

\begin_layout Standard

\series bold
\size small
Unistava se 1
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsection
Konstruktori sa parametrima
\end_layout

\begin_layout Standard
Konstruktorima je moguće proslediti argumente, koji se obično koriste za
 inicijalizaciju objekta tokom njegovog kreiranja.
 Konstruktor
\begin_inset Index idx
status open

\begin_layout Plain Layout
konstruktori!sa parametrima
\end_layout

\end_inset

 sa parametrima piše se kao i sve druge slične funkcije, a u telu konstruktora
 parametri se koriste za inicijalizaciju objekta.
 Sledeći primer ilustruje jednostavnu klasu koja ima konstruktor sa parametrima:
\end_layout

\begin_layout LyX-Code

\size small
class mojaKlasa { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int a, b; 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_layout LyX-Code
   
\size small
//inline konstruktor sa parametrima
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
mojaKlasa(int i, int j) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
a=i; 
\end_layout

\begin_layout LyX-Code

\size small
b=j;
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
void prikazi() {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << a << " " << b << endl;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
mojaKlasa ob(3, 5); 
\end_layout

\begin_layout LyX-Code

\size small
ob.prikazi(); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Primetite da se u definiciji konstruktora 
\family typewriter
mojaKlasa()
\family default
 parametri 
\family typewriter
i
\family default
 i 
\family typewriter
j
\family default
 koriste za dodeljivanje početnih vrednosti promenljivama 
\family typewriter
a
\family default
 i 
\family typewriter
b
\family default
.
 Ovaj program takođe ilustruje najčešće korišćen način za zadavanje argumenata
 konstruktora prilikom deklaracije objekta:
\end_layout

\begin_layout Standard

\family typewriter
\size small
mojaKlasa ob(3, 4);
\end_layout

\begin_layout Standard
Ova naredba kreira objekat 
\family typewriter
ob
\family default
, a konstruktoru 
\family typewriter
mojaKlasa()
\family default
 prosleđuje argumente 3 i 4.
 Parametri se mogu proslediti i sledećom deklaracijom:
\end_layout

\begin_layout Standard

\family typewriter
\size small
mojaKlasa ob = mojaKlasa(3, 4);
\end_layout

\begin_layout Standard
Prvi metod se češće koristi i mi ćemo ga nadalje koristiti u ovoj knjizi.
 
\end_layout

\begin_layout Standard
Ako konstruktor ima samo jedan parametar, postoji i treći način za prosleđivanje
 vrednosti tom konstruktoru, koji ilustruje sledeći kôd:
\end_layout

\begin_layout LyX-Code

\size small
class X { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int a; 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
X(int j) { a = j; } 
\end_layout

\begin_layout LyX-Code

\size small
int get_a() { return a; } 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
X ob = 99; // prosledjuje 99 u j 
\end_layout

\begin_layout LyX-Code

\size small
cout << ob.get_a(); // prikazuje 99 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Konstruktor klase 
\family typewriter
X
\family default
 prihvata jedan parametar; obratite pažnju na to kako je 
\family typewriter
ob
\family default
 deklarisan u funkciji 
\family typewriter
main()
\family default
.
 Vrednost 99 se automatski prosleđuje parametru 
\family typewriter
j
\family default
 u konstruktoru 
\family typewriter
X()
\family default
, odnosno kompajler tumači naredbu deklaracije objekta 
\family typewriter
ob
\family default
 kao da je napisana ovako:
\end_layout

\begin_layout Standard

\family typewriter
\size small
X ob = X(99);
\end_layout

\begin_layout Standard
Funkcijama članicama klase, pa i konstruktoru, mogu se dodeliti podrazumevane
 vrednosti argumenata.
 One se navode u deklaraciji konstruktora unutar klase, kao u sledećem primeru:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class Osoba { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char *imePrezime; 
\end_layout

\begin_layout LyX-Code

\size small
int godine; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Osoba(char *ime="Nikola Vukovic", int godine=40); 
\end_layout

\begin_layout LyX-Code

\size small
void koSi(); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
Osoba::Osoba(char *i, int g) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
imePrezime = i; godine = g; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void Osoba::koSi() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << imePrezime << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Osoba o; //poziva konstruktor sa default argumentima
\end_layout

\begin_layout LyX-Code

\size small
o.koSi(); //ispisuje Nikola Vukovic
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Subsection
Preklapanje konstruktora
\end_layout

\begin_layout Standard
Konstruktori
\begin_inset Index idx
status open

\begin_layout Plain Layout
konstruktori!preklapanje
\end_layout

\end_inset

 mogu da budu preklopljeni, i to je vrlo čest slučaj u klasama.
 Često su potrebne klase koje omogućuju više načina za kreiranje objekata.
 Ako se za svaki od načina kreiranja objekata obezbedi odgovarajući konstruktor,
 klasa postaje prilagodljivija jer korisnik može da izabere najbolji način
 za kreiranje objekta u skladu sa okolnostima.
 Proučimo primer klase 
\family typewriter
datum
\family default
 sa dva konstruktora:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <cstdio> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class datum { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int dan, mesec, godina; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
datum(char *d); 
\end_layout

\begin_layout LyX-Code

\size small
datum(int d, int m, int g); 
\end_layout

\begin_layout LyX-Code

\size small
void prikazi_datum(); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//inicijalizacija pomocu stringa 
\end_layout

\begin_layout LyX-Code

\size small
datum::datum(char *d) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
sscanf(d, "%d%*c%d%*c%d", &dan, &mesec, &godina); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
//Inicijalizacija pomocu celih brojeva 
\end_layout

\begin_layout LyX-Code

\size small
datum::datum(int d, int m, int g) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
dan = d; 
\end_layout

\begin_layout LyX-Code

\size small
mesec = m; 
\end_layout

\begin_layout LyX-Code

\size small
godina = g; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void datum::prikazi_datum() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << dan << "." << mesec; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "." << godina << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
datum ob1(12, 4, 2001), ob2("22.10.2010"); 
\end_layout

\begin_layout LyX-Code

\size small
ob1.prikazi_datum(); 
\end_layout

\begin_layout LyX-Code

\size small
ob2.prikazi_datum(); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
U ovom programu objekat tipa 
\family typewriter
datum
\family default
 može da se inicijalizuje bilo tako što će se zadati tri cela broja koji
 predstavljaju dan, mesec i godinu, ili tako što će se navesti string sa
 datumom u obliku dd.mm.gggg.
 Pošto se za predstavljanje datuma koriste oba načina, ima smisla da klasa
 
\family typewriter
datum
\family default
 podržava oba načina kreiranja objekata.
 U sledećem programu 
\family typewriter
main()
\family default
 od korisnika se traži da unese datum u obliku stringa, koji se zatim koristi
 direktno za kreiranje objekta klase 
\family typewriter
datum
\family default
.
 Kada klasa 
\family typewriter
datum
\family default
 ne bi imala konstruktor koji prihvata string, uneti string bi morao ručno
 da se konvertuje u tri cela broja.
 Prilagodljivost klasa koja se dobija pisanjem preklopljenih konstruktora
 posebno je bitna ako pišete biblioteke klasa koje će koristiti drugi programeri.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char s[80]; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Unesite datum: "; 
\end_layout

\begin_layout LyX-Code

\size small
cin >> s; 
\end_layout

\begin_layout LyX-Code

\size small
datum d(s); 
\end_layout

\begin_layout LyX-Code

\size small
d.prikazi_datum(); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Subsection
Podrazumevani (default) konstruktori
\end_layout

\begin_layout Standard
Ako nijedan konstruktor
\begin_inset Index idx
status open

\begin_layout Plain Layout
konstruktori!podrazumevani (default)
\end_layout

\end_inset

 nije eksplicitno deklarisan u definiciji klase, C++ kompajler će sam generisati
 tzv.
 podrazumevani (default) konstruktor.
 Podrazumevani konstruktor nema argumente i javan je.
 Ovakav konstruktor samo kreira objekat klase, ali ne inicijalizuje njegove
 podatke članove.
 Ako se za klasu deklariše neki konstruktor sa argumentima, tada podrazumevani
 konstruktor više neće biti dostupan, pa svaki deklarisan objekat klase
 mora da bude i inicijalizovan.
 Kada bi se u prethodnom primeru za klasu 
\family typewriter
datum
\family default
 napisala deklaracija:
\end_layout

\begin_layout Standard

\family typewriter
datum d; 
\end_layout

\begin_layout Standard
ona bi prouzrokovala grešku jer za klasu 
\family typewriter
datum
\family default
 kompajler više ne generiše podrazumevani konstruktor automatski.
 Oba preklopljena konstruktora imaju argumente, pa ako želimo da omogućimo
 samo kreiranje objekata bez inicijalizacije, morali bismo eksplicitno da
 deklarišemo još jedan konstruktor bez argumenata:
\end_layout

\begin_layout LyX-Code

\size small
class datum { 
\end_layout

\begin_layout LyX-Code

\size small
int dan, mesec, godina; 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
datum(char *d); 
\end_layout

\begin_layout LyX-Code

\size small
datum(int d, int m, int g);
\end_layout

\begin_layout LyX-Code

\size small
datum(); //default konstruktor 
\end_layout

\begin_layout LyX-Code

\size small
void prikazi_datum(); 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout Section
Zajednički članovi klasa
\end_layout

\begin_layout Standard
Kada se ispred podatka člana klase navede ključna
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
static
\family default
!u podacima članovima
\end_layout

\end_inset

 reč 
\family typewriter
static
\family default
, to je znak za kompajlera da treba da postoji samo jedna kopija tog podatka
 za sve objekte te klase koji će biti kreirani, odnosno da svi objekti te
 klase treba da dele taj podatak član.
 Sve statičke promenljive klasa inicijalizuju se na 0 pre kreiranja prvog
 objekta.
 Kada se statički podatak član deklariše u klasi, on se istovremeno i ne
 definiše, tj.
 u memoriji se ne odvaja prostor za njega, već se definicija mora napisati
 izvan klase.
 Tek tada se alocira memorija za statički podatak član.
 Korišćenje statičkog podatka člana ilustrovano je u sledećem primeru:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class deljena { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
static int a; 
\end_layout

\begin_layout LyX-Code

\size small
int b; 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
void set(int i, int j) {a=i; b=j;} 
\end_layout

\begin_layout LyX-Code

\size small
void prikazi(); 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
} ; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int deljena::a; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void deljena::prikazi() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "staticko a: " << a << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "nestaticko b: " << b << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
deljena x, y; 
\end_layout

\begin_layout LyX-Code

\size small
x.set(1, 1); //a postaje 1 
\end_layout

\begin_layout LyX-Code

\size small
x.prikazi(); 
\end_layout

\begin_layout LyX-Code

\size small
y.set(2, 2); //a postaje 2
\end_layout

\begin_layout LyX-Code

\size small
//a je promenjeno i za x i za y
\end_layout

\begin_layout LyX-Code

\size small
y.prikazi(); 
\end_layout

\begin_layout LyX-Code

\size small
x.prikazi(); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
staticko a: 1 
\end_layout

\begin_layout Standard

\series bold
\size small
nestaticko b: 1 
\end_layout

\begin_layout Standard

\series bold
\size small
staticko a: 2 
\end_layout

\begin_layout Standard

\series bold
\size small
nestaticko b: 2 
\end_layout

\begin_layout Standard

\series bold
\size small
staticko a: 2 
\end_layout

\begin_layout Standard

\series bold
\size small
nestaticko b: 1
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
U prethodnom programu podatak član 
\family typewriter
\size small
a
\family default
\size default
 je javni i statički, pa mu se može direktno pristupiti u funkciji 
\family typewriter
\size small
main()
\family default
\size default
.
 Takođe, pošto
\family typewriter
 a
\family default
 postoji pre nego što se kreira bilo koji objekat klase 
\family typewriter
deljena
\family default
, promenljivoj 
\family typewriter
a
\family default
 može se dodeliti vrednost bilo kad.
\end_layout

\begin_layout Standard
Sledeći program ilustruje činjenicu da vrednost podatka člana 
\family typewriter
a
\family default
 ostaje neizmenjena kada se kreira objekat 
\family typewriter
x
\family default
.
 Zbog toga obe naredbe 
\family typewriter
cout
\family default
 prikazuju vrednost 99.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class deljena { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
static int a; 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
} ; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int deljena::a; // definise a
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//inicijalizacija pre kreiranja bilo kog objekta 
\end_layout

\begin_layout LyX-Code

\size small
deljena::a = 99; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Pocetna vrednost a: " << deljena::a << endl; 
\end_layout

\begin_layout LyX-Code

\size small
deljena x; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "x.a: " << x.a << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Uočite kako se promenljivoj 
\family typewriter
a
\family default
 pristupa preko imena klase i operatora razrešenja dosega (::).
 U opštem slučaju, da bi se statičkom podatku članu pristupalo nezavisno
 od objekta, ispred njegovog imena mora se navesti ime klase čiji je član.
 
\end_layout

\begin_layout Standard
Statički podaci članovi često se koriste kada je potrebno osigurati pristup
 nekom resursu koji dele svi objekti klase, npr.
 istoj datoteci.
 U slučaju datoteke mora se osigurati da u određenom trenutku samo jedan
 objekat upisuje u nju; tada se deklariše statička promenljiva koja prati
 kada se datoteka koristi, a kada ne.
 Pre upisa u datoteku svaki objekat proverava stanje te statičke promenljive.
 Drugi primer je praćenje ukupnog broja objekata određene klase, što ilustruje
 sledeći primer:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class Brojac { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_layout LyX-Code

\size small
static int broj; 
\end_layout

\begin_layout LyX-Code

\size small
Brojac() { broj++; } //konstruktor
\end_layout

\begin_layout LyX-Code

\size small
~Brojac() { broj--; } //destruktor
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int Brojac::broj;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void f();
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Brojac o1; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Ukupno objekata: "; 
\end_layout

\begin_layout LyX-Code

\size small
cout << Brojac::broj << endl; 
\end_layout

\begin_layout LyX-Code

\size small
Brojac o2; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Ukupno objekata: "; 
\end_layout

\begin_layout LyX-Code

\size small
cout << Brojac::broj << endl;
\end_layout

\begin_layout LyX-Code

\size small
f(); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Ukupno objekata: "; 
\end_layout

\begin_layout LyX-Code

\size small
cout << Brojac::broj << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void f() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Brojac temp; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Ukupno objekata: "; 
\end_layout

\begin_layout LyX-Code

\size small
cout << Brojac::broj << endl; 
\end_layout

\begin_layout LyX-Code

\size small
//temp se unistava nakon izlaska iz f() 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
Ukupno objekata: 1 
\end_layout

\begin_layout Standard

\series bold
\size small
Ukupno objekata: 2 
\end_layout

\begin_layout Standard

\series bold
\size small
Ukupno objekata: 3 
\end_layout

\begin_layout Standard

\series bold
\size small
Ukupno objekata: 2
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Statički podatak član 
\family typewriter
broj
\family default
 u prethodnom primeru se inkrementira kad god se objekat kreira, a dekrementira
 se kada se objekat uništava.
 Na taj način prati se koliko objekata klase 
\family typewriter
Brojac
\family default
 trenutno postoji.
 Statički podaci članovi praktično uklanjaju potrebu za globalnim promenljivama,
 koje narušavaju objektno orijentisan pristup skrivanja (kapsuliranja) podataka.
\end_layout

\begin_layout Standard
I funkcije članice klase mogu da budu deklarisane kao statičke.
 Statičke
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
static
\family default
!funkcije članice
\end_layout

\end_inset

 funkcije članice mogu direktno da pristupaju samo statičkim podacima članovima
 klase.
 U istoj klasi ne mogu da postoje dve verzije iste funkcije od kojih je
 jedna statička, a druga nestatička.
 
\end_layout

\begin_layout Standard
Statičke funkcije članice često se koriste za inicijalizaciju privatnih
 statičkih podataka članova pre kreiranja objekata klase, kao što ilustruje
 sledeći primer:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class staticka { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
static int i; 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
static void init(int x) {i = x;} 
\end_layout

\begin_layout LyX-Code

\size small
void prikazi() {cout << i << endl;} 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int staticka::i; //definise i 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//inicijalizacija statickih podataka
\end_layout

\begin_layout LyX-Code

\size small
//pre kreiranja objekata 
\end_layout

\begin_layout LyX-Code

\size small
staticka::init(100); 
\end_layout

\begin_layout LyX-Code

\size small
staticka x; 
\end_layout

\begin_layout LyX-Code

\size small
x.prikazi(); //prikazuje 100 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Section
Prosleđivanje objekata funkciji
\end_layout

\begin_layout Standard
Objekti
\begin_inset Index idx
status open

\begin_layout Plain Layout
objekti!prosleđivanje funkciji
\end_layout

\end_inset

 se mogu prosleđivati funkcijama na isti način kao što im se prosleđuju
 i druge promenljive, standardnim mehanizmom prenosa po vrednosti.
 To znači da se prilikom prosleđivanja argumenta funkciji pravi kopija objekta,
 odnosno kreira se drugi objekat.
 Postavlja se pitanje da li se prilikom kreiranja kopije objekta poziva
 konstruktor, odnosno da li se poziva destruktor kada se kopija objekta
 uništava.
 Da bismo odgovorili na to pitanje, proučićemo sledeći primer:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class mojaKlasa { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int i; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
mojaKlasa(int n); 
\end_layout

\begin_layout LyX-Code

\size small
~mojaKlasa(); 
\end_layout

\begin_layout LyX-Code

\size small
void set_i(int n) { i=n; } 
\end_layout

\begin_layout LyX-Code

\size small
int get_i() { return i; } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
mojaKlasa::mojaKlasa(int n) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
i = n; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "kreira se " << i << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
mojaKlasa::~mojaKlasa() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "unistava se " << i << endl;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void f(mojaKlasa ob);
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
mojaKlasa o(1); 
\end_layout

\begin_layout LyX-Code

\size small
f(o); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "i u mainu: "; 
\end_layout

\begin_layout LyX-Code

\size small
cout << o.get_i() << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void f(mojaKlasa ob) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
ob.set_i(2); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "i u funkciji: " << ob.get_i() << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
kreira se 1 
\end_layout

\begin_layout Standard

\series bold
\size small
i u funkciji: 2 
\end_layout

\begin_layout Standard

\series bold
\size small
unistava se 2 
\end_layout

\begin_layout Standard

\series bold
\size small
i u mainu: 1 
\end_layout

\begin_layout Standard

\series bold
\size small
unistava se 1
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Primetite da se destruktor izvršava dva puta, iako se konstruktor poziva
 samo jednom.
 Kao što se vidi iz rezultata izvršavanja, konstruktor se ne poziva kada
 se kopija objekta 
\family typewriter
o
\family default
 u funkciji 
\family typewriter
main()
\family default
 prosleđuje u 
\family typewriter
ob
\family default
 (u funkciji 
\family typewriter
f()
\family default
).
 Kada se objekat prosleđuje funkciji, ona treba da zna trenutno stanje tog
 objekta; kada bi se pozivao konstruktor, desila bi se inicijalizacija,
 tj.
 ne bi se prosledilo tekuće stanje objekta.
 Zbog toga se konstruktor ne poziva kada se u pozivu funkcije kreira kopija
 objekta, ali se zato poziva destruktor kada se ta kopija uništava.
 U opštem slučaju, kada se pravi kopija objekta
\begin_inset Index idx
status open

\begin_layout Plain Layout
objekti!kopiranje
\end_layout

\end_inset

, on se kopira bit po bit, da bi dobijeni objekat bio precizna kopija originalno
g.
 To ponekad može da prouzrokuje probleme, na primer u slučaju kada objekat
 koji se koristi kao argument funkcije alocira i dealocira memoriju.
 Tada se dešava da tu istu memoriju oslobađa i kopija objekta prilikom poziva
 destruktora, što oštećuje originalni objekat i čini ga neupotrebljivim.
 Da bi sprečio taj problem, za klasu se definiše specijalan konstruktor
 koji se zove konstruktor kopije; njime ćemo se pozabaviti u odeljku 6.11.
\end_layout

\begin_layout Section
Dodela objekata jedan drugome
\end_layout

\begin_layout Standard
Pod pretpostavkom da su oba objekta
\begin_inset Index idx
status open

\begin_layout Plain Layout
objekti!dodela
\end_layout

\end_inset

 istog tipa, oni se mogu dodeljivati jedan drugome.
 Time se podaci članovi objekta sa desne strane kopiraju u podatke članove
 objekta sa leve strane.
 Na primer, sledeći program prikazuje 99:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class mojaKlasa { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int i; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
void set_i(int n) { i=n; } 
\end_layout

\begin_layout LyX-Code

\size small
int get_i() { return i; } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
mojaKlasa ob1, ob2; 
\end_layout

\begin_layout LyX-Code

\size small
ob1.set_i(99); 
\end_layout

\begin_layout LyX-Code

\size small
ob2 = ob1; //dodela ob1 objektu ob2 
\end_layout

\begin_layout LyX-Code

\size small
cout << "ob2.i: " << ob2.get_i() << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Section
Pokazivači na objekte
\end_layout

\begin_layout Standard
Kao što mogu da postoje pokazivači
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači!na objekte
\end_layout

\end_inset

 na promenljive osnovnih tipova, postoje i pokazivači na objekte.
 Ako se koriste pokazivači na objekte, za pristup pojedinačnim članovima
 koristi se operator ->
\begin_inset Index idx
status open

\begin_layout Plain Layout
operatori!->
\end_layout

\end_inset

.
 Tako je sintaksa 
\family typewriter
p -> funkcija()
\family default
 ekvivalentna sa 
\family typewriter
(*p).funkcija()
\family default
.
 Zagrade oko 
\family typewriter
*p
\family default
 su neophodne zato što operator .
 ima veći prioritet od operatora dereferenciranja *.
 Adresa objekta se dobija primenom operatora &, kao da se radi o običnoj
 promenljivoj prostog tipa.
 Takođe, reference na objekte deklarišu se na isti način kao reference na
 obične promenljive.
 
\end_layout

\begin_layout Standard
Sledeći primer ilustruje kako se objektu pristupa preko pokazivača:
\end_layout

\begin_layout LyX-Code

\size small
class cl { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int i; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cl(int j) { i=j; } 
\end_layout

\begin_layout LyX-Code

\size small
int get_i() { return i; } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cl ob(88), *p; 
\end_layout

\begin_layout LyX-Code

\size small
p = &ob; //p pokazuje na ob 
\end_layout

\begin_layout LyX-Code

\size small
cout << p->get_i()<< endl; //prikazuje 88 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Section
Pokazivač this
\end_layout

\begin_layout Standard
Već smo naučili da se funkcija članica uvek poziva za neki objekat svoje
 klase (osim ako nije statička).
 Kada se funkcija članica pozove, prosleđuje joj se jedan implicitni argument:
 pokazivač na objekat za koji je pozvana.
 Pokazivač na objekat za koji je pozvana funkcija članica zove se 
\family typewriter
this
\family default
.
 Da bismo razumeli pokazivač
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači!this
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
this, pokazivač
\end_layout

\end_inset

 
\family typewriter
this
\family default
, proučimo program sa klasom 
\family typewriter
pwr
\family default
 za stepenovanje brojeva:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class pwr { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
double b; 
\end_layout

\begin_layout LyX-Code

\size small
int e; 
\end_layout

\begin_layout LyX-Code

\size small
double val; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
pwr(double base, int exp); 
\end_layout

\begin_layout LyX-Code

\size small
double get_pwr() { return val; } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
pwr::pwr(double base, int exp) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
b = base; 
\end_layout

\begin_layout LyX-Code

\size small
e = exp; 
\end_layout

\begin_layout LyX-Code

\size small
val = 1; 
\end_layout

\begin_layout LyX-Code

\size small
if(exp==0) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
for( ; exp>0; exp--) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
val = val * b; 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
pwr x(4.0, 2), y(2.5, 1), z(5.7, 0); 
\end_layout

\begin_layout LyX-Code

\size small
cout << x.get_pwr() << " "; 
\end_layout

\begin_layout LyX-Code

\size small
cout << y.get_pwr() << " "; 
\end_layout

\begin_layout LyX-Code

\size small
cout << z.get_pwr() << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Kada u funkciji članici koristimo direktno neki podatak član pristupom preko
 imena, koristimo sintaksu:
\end_layout

\begin_layout Standard

\family typewriter
\size small
b = base;
\end_layout

\begin_layout Standard
kompajler automatski razume da koristimo 
\family typewriter
(*this).ime_člana
\family default
, što se u ovom primeru kraće piše kao
\end_layout

\begin_layout Standard

\family typewriter
\size small
this->b = base;
\end_layout

\begin_layout Standard
Pokazivač 
\family typewriter
this
\family default
 pokazuje na objekat koji je pozvao funkciju članicu 
\family typewriter
pwr()
\family default
.
 Funkcija 
\family typewriter
pwr()
\family default
 bi mogla da se napiše i ovako:
\end_layout

\begin_layout LyX-Code

\size small
pwr::pwr(double base, int exp) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
this->b = base; 
\end_layout

\begin_layout LyX-Code

\size small
this->e = exp; 
\end_layout

\begin_layout LyX-Code

\size small
this->val = 1; 
\end_layout

\begin_layout LyX-Code

\size small
if(exp==0) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
for( ; exp>0; exp--) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
this->val = this->val * this->b; 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Nijedan C++ programer ne bi funkciju 
\family typewriter
pwr()
\family default
 napisao ovako, jer je standardni oblik bez pokazivača 
\family typewriter
this
\family default
 čitljiviji.
 Međutim, ovaj pokazivač postaje veoma važan kad god funkcije članice moraju
 da koriste pokazivač na objekat koji ih je pozvao.
 Treba primetiti takođe da statičke funkcije članice nemaju pokazivač 
\family typewriter
this
\family default
 jer se ne pozivaju za objekte klase.
\end_layout

\begin_layout Section
Konstruktor kopije
\end_layout

\begin_layout Standard
Jedan od najvažnijih konstruktora
\begin_inset Index idx
status open

\begin_layout Plain Layout
konstruktor kopije
\end_layout

\end_inset

 je tzv.
 
\shape italic
konstruktor kopije
\shape default
 (copy constructor).
 Da bismo razumeli njegovu namenu, treba razumeti problem koji on rešava.
 Već smo pominjali da u situacijama kada se jedan objekat koristi za inicijaliza
ciju drugog C++ obavlja kopiranje bit po bit.
 To je u nekim slučajevima sasvim prihvatljivo, i upravo ono što i želimo
 da se desi.
 Međutim, postoje situacije kada to nije prikladno, npr.
 kada objeakt dinamički alocira memoriju ili ima podatke članove koji su
 pokazivači.
 
\end_layout

\begin_layout Standard
Na primer, zamislimo klasu 
\family typewriter
mojaKlasa
\family default
 koja alocira memoriju za objekat kada se on kreira, i neki objekat A te
 klase.
 Ako je objekat kreiran, to znači da je već alocirao memoriju.
 Sada zamislimo situaciju u kojoj se objekat A koristi za inicijalizaciju
 objekta B iste klase, kao u sledećoj naredbi:
\end_layout

\begin_layout Standard

\family typewriter
\size small
mojaKlasa B = A; //objekat B se kreira kao identična kopija objekta A
\end_layout

\begin_layout Standard
Ako se obavlja kopija bit po bit, onda je objekat B identična kopija objekta
 A, što znači da će i objekat B koristiti istu memoriju koju je alocirao
 objekat A, umesto da alocira memoriju za sebe.
 Očigledno je da to nije ono što želimo, jer ako 
\family typewriter
mojaKlasa
\family default
 ima destruktor koji oslobađa memoriju, onda će ista memorija biti oslobođena
 dva puta: jednom kada se uništava A, i drugi put kada se uništava B!
\end_layout

\begin_layout Standard
Isti problem se javlja i ako klasa ima podatak član koji je pokazivačkog
 tipa.
 Pošto se pravi kopija bit po bit, onda će i kopija objekta pokazivati na
 istu promenljivu u memoriji, umesto da pokazuje na 
\begin_inset Quotes sld
\end_inset

svoju
\begin_inset Quotes srd
\end_inset

 kopiju promenljive.
 
\end_layout

\begin_layout Standard
Da bi se rešio opisani problem, C++ omogućuje pisanje konstruktora kopije,
 koji kompajler poziva kad god se jedan objekat inicijalizuje drugim.
 Konstruktor kopije se deklariše na sledeći način: 
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
ime_klase (const ime_klase &o) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
// telo konstruktora 
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
} 
\end_layout

\begin_layout Standard
Argument konstruktora kopije je konstantna referenca
\begin_inset Index idx
status open

\begin_layout Plain Layout
reference!i konstruktor kopije
\end_layout

\end_inset

 na objekat klase.
 Modifikator 
\family typewriter
const
\family default
 se navodi zato što nema razloga da konstruktor kopije menja objekat koji
 mu se prosleđuje kao argument, tj.
 objekat koji se koristi za inicijalizaciju.
 Konstruktor kopije može da ima i druge parametre pod uslovom da su za njih
 definisane podrazumevane vrednosti (ali u svakom slučaju prvi argument
 mora da bude referenca na objekat koji se koristi za inicijalizaciju).
\end_layout

\begin_layout Standard
Važno je razumeti da C++ razlikuje dve situacije u kojima se vrednost jednog
 objekta dodeljuje drugom.
 Prvi je dodela, a drugi je inicijalizacija, koja se dešava u tri slučaja:
\end_layout

\begin_layout Itemize
kada jedan objekat eksplicitno inicijalizuje drugi 
\end_layout

\begin_layout Itemize
kada se pravi privremeni objekat 
\end_layout

\begin_layout Itemize
kada se pravi kopija objekta koja se prosleđuje funkciji 
\end_layout

\begin_layout Standard
Konstruktor kopije poziva se samo u inicijalizacijama, ne i u dodelama.
 Na primer, konstruktor kopije bi se pozivao u sledećim naredbama:
\end_layout

\begin_layout Standard

\family typewriter
\size small
mojaKlasa x = y; // y eksplicitno inicijalizuje x 
\end_layout

\begin_layout Standard

\family typewriter
\size small
funkc(y); // y se prosleđuje kao parametar 
\end_layout

\begin_layout Standard
a ne bi se pozvao u sledećoj naredbi dodele:
\end_layout

\begin_layout Standard

\family typewriter
\size small
mojaKlasa x, y;
\end_layout

\begin_layout Standard

\family typewriter
\size small
x = y;
\end_layout

\begin_layout Standard
Argument konstruktora kopije
\begin_inset Index idx
status open

\begin_layout Plain Layout
konstruktor kopije!argumenti
\end_layout

\end_inset

 ne može da bude sam objekat, već uvek referenca na objekat.
 Kada bi se objekat prosleđivao funkciji po vrednosti, pozivao bi se konstruktor
 kopije za njega jer se pravi kopija objekta.
 Zbog toga se u konstruktoru kopije ne može koristiti prenos po vrednosti,
 več po adresi (tj.
 preko reference) u suprotnom bi se pojavila rekurzija jer bi se konstruktor
 kopije pozivao unedogled.
 
\end_layout

\begin_layout Standard
U nastavku je dat primer kada je potrebno eksplicitno napisati konstruktor
 kopije jer klasa ima podatak član koji je pokazivač.
 Unutar konstruktora dinamički se alocira memorija za podatak član 
\family typewriter
ime
\family default
 korišćenjem operatora 
\family typewriter
new
\family default
.
 Memorija se oslobađa pozivom operatora 
\family typewriter
delete
\family default
 unutar destruktora.
\end_layout

\begin_layout LyX-Code

\size small
class Osoba { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char *ime; 
\end_layout

\begin_layout LyX-Code

\size small
int godine; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Osoba(char *i, int g) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
ime = new char[strlen(i)+1]; 
\end_layout

\begin_layout LyX-Code

\size small
strcpy(ime, i); 
\end_layout

\begin_layout LyX-Code

\size small
godine = g; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
~Osoba() { delete[] ime; }
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Konstruktor kopije za klasu 
\family typewriter
Osoba
\family default
 dinamički alocira prostor u memoriji za niz znakove dužine podatka člana
 
\family typewriter
ime
\family default
 koji se prosleđuje kao argument:
\end_layout

\begin_layout LyX-Code

\size small
Osoba(const Osoba &osoba) { 		
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
ime = new char[strlen(osoba.ime)+1]; 		
\end_layout

\begin_layout LyX-Code

\size small
strcpy(ime, osoba.ime); 		
\end_layout

\begin_layout LyX-Code

\size small
godine = osoba.godine; 	
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Section
Klasa string
\end_layout

\begin_layout Standard
U zaključku poglavlja o klasama
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!string
\end_layout

\end_inset

, proučićemo veoma korisnu klasu
\begin_inset Index idx
status open

\begin_layout Plain Layout
string!klasa
\end_layout

\end_inset

 
\family typewriter
string
\family default
 koja je ugrađena u jezik C++.
 Klasa 
\family typewriter
string
\family default
 nudi brojne korisne funkcije, a poziva se navođenjem zaglavlja 
\family typewriter
<string>
\family default
.
 Da bi se koristili string objekti, nije potrebno poznavati način kako je
 ta klasa implementirana, već samo njene metode.
 
\end_layout

\begin_layout Standard
Rad sa string objektima sličan je radu sa drugim promenljivama osnovnih
 tipova.
 String objekat se deklariše na uobičajeni način:
\end_layout

\begin_layout LyX-Code

\size small
string primer;
\end_layout

\begin_layout Standard
Postoji nekoliko načina za inicijalizovanje string objekata, prikazanih
 u sledećoj tabeli:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="40text%">
<column alignment="left" valignment="top" width="50text%">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 6.1
\series default
: Inicijalizacija objekata klase 
\family typewriter
string
\family default
.
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
string adresa;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deklariše prazan string 
\family typewriter
adresa
\family default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
string ime("Nikola Vukovic
\begin_inset Quotes srd
\end_inset

);
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deklariše string objekat 
\family typewriter
ime
\family default
 i inicijalizuje ga sa 
\family typewriter

\begin_inset Quotes sld
\end_inset

Nikola Vukovic
\begin_inset Quotes srd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
string osoba2(osoba1)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deklariše string objekat 
\family typewriter
osoba1
\family default
, koji je kopija string objekta 
\family typewriter
osoba2
\family default
, 
\end_layout

\begin_layout Plain Layout
pri čemu 
\family typewriter
osoba2
\family default
 može da bude drugi string ili niz znakova
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
string set1(set2, 5);
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deklariše string objekat 
\family typewriter
set1
\family default
 koji se inicijalizuje sa prvih pet znakova 
\end_layout

\begin_layout Plain Layout
niza znakova 
\family typewriter
set2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
string punRed ('z', 10);
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deklariše string objekat 
\family typewriter
punRed
\family default
 koji se inicijalizuje sa 10 znakova 
\family typewriter
'z'
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
string ime(punoIme, 0, 7);
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deklariše string objekat 
\family typewriter
ime
\family default
 koji se inicijalizuje podstringom 
\end_layout

\begin_layout Plain Layout
stringa 
\family typewriter
punoIme
\family default
.
 Podstring ima 7 znakova i počinje od pozicije 0.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Objekti tokova 
\family typewriter
cin
\family default
 i 
\family typewriter
cout
\family default
 automatski podržavaju string objekte:
\end_layout

\begin_layout Standard

\family typewriter
\size small
string ime;
\end_layout

\begin_layout Standard

\family typewriter
\size small
cout << 
\begin_inset Quotes sld
\end_inset

Kako se zovete?
\begin_inset Quotes srd
\end_inset

;
\end_layout

\begin_layout Standard

\family typewriter
\size small
cin >> ime;
\end_layout

\begin_layout Standard

\family typewriter
\size small
cout << 
\begin_inset Quotes sld
\end_inset

Dobar dan, 
\begin_inset Quotes sld
\end_inset

 << ime << endl;
\end_layout

\begin_layout Standard
Za učitavanje celog reda sa konzole (zajedno sa razmacima) koristi se funkcije
 
\family typewriter
getline()
\family default
.
 Prvi argument funkcije 
\family typewriter
getline
\family default
 je objekat ulaznog toka, a drugi je objekat klase 
\family typewriter
string
\family default
 u koji se smešta ulaz sa konzole:
\end_layout

\begin_layout Standard

\family typewriter
\size small
string ime;
\end_layout

\begin_layout Standard

\family typewriter
\size small
cout << 
\begin_inset Quotes sld
\end_inset

Kako se zovete?
\begin_inset Quotes srd
\end_inset

;
\end_layout

\begin_layout Standard

\family typewriter
\size small
getline (cin, ime);
\end_layout

\begin_layout Standard
Za poređenje stringova mogu se koristiti operatori <, <=, >, >= i ==.
 Relacioni operatori porede objekte klase 
\family typewriter
string
\family default
 na sličan način kao što funkcija 
\family typewriter
strcmp
\family default
 poredi C-stringove (znakovne nizove koji se završavaju nulom).
 
\end_layout

\begin_layout Standard
Takođe, operatori + i += mogu se koristiti za nadovezivanje (konkatenaciju)
 stringova, kao u sledećem primeru:
\end_layout

\begin_layout LyX-Code

\size small
string str1, str2, str3;
\end_layout

\begin_layout LyX-Code

\size small
str1='ABC';
\end_layout

\begin_layout LyX-Code

\size small
str2='DEF';
\end_layout

\begin_layout LyX-Code

\size small
str3 = str1 + str2;
\end_layout

\begin_layout LyX-Code

\size small
cout << str3; //ispisuje ABCDEF
\end_layout

\begin_layout LyX-Code

\size small
str3+='GHI'
\end_layout

\begin_layout LyX-Code

\size small
cout<<str3; //ispisuje ABCDEFGHI
\end_layout

\begin_layout Standard
Klasa 
\family typewriter
string
\family default
 takođe nudi brojne korisne funkcije članice, delimično navedene u sledećoj
 tabeli:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="27" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="50text%">
<row endhead="true">
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 6.2
\series default
: Funkcije članice klase 
\family typewriter
string
\family default
.
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.append(str2)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dodaje 
\family typewriter
str2
\family default
 na 
\family typewriter
str1
\family default
.

\family typewriter
 str2
\family default
 može biti string objekat ili niz znakova.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.append(str2, x, n)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
n
\family default
 znakova objekta 
\family typewriter
str2
\family default
 počev od pozicije 
\family typewriter
x
\family default
 dodaju se objektu 
\family typewriter
str1
\family default
.
 
\end_layout

\begin_layout Plain Layout
Ako 
\family typewriter
str1
\family default
 nema dovoljnu dužinu, kopiraće se onoliko znakova 
\end_layout

\begin_layout Plain Layout
koliko može da stane.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.append(str2, n);
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prvih 
\family typewriter
n
\family default
 znakova niza
\family typewriter
 str2
\family default
 dodeljuju se 
\family typewriter
str1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.append(n, 'z')
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
n
\family default
 kopija znaka 
\family typewriter
'z'
\family default
 dodeljuje se objektu 
\family typewriter
str
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.assign(str2)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dodeljuje 
\family typewriter
str2
\family default
 objektu 
\family typewriter
str1
\family default
.
 
\family typewriter
str2
\family default
 može da bude 
\end_layout

\begin_layout Plain Layout
string objekat ili niz znakova.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.assign(str2, x, n)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
n
\family default
 znakova objekta 
\family typewriter
str2
\family default
 počev od pozicije 
\family typewriter
x
\family default
 dodeljuje se 
\family typewriter
str1
\family default
.
 
\end_layout

\begin_layout Plain Layout
Ako 
\family typewriter
str1
\family default
 nema dovoljnu dužinu, kopiraće se onoliko znakova 
\end_layout

\begin_layout Plain Layout
koliko može da stane.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.assign(str2, n)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prvih 
\family typewriter
n
\family default
 znakova 
\family typewriter
str2
\family default
 dodeljuje se objektu 
\family typewriter
str1
\family default
.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.assign(n, 'z')
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dodeljuje 
\family typewriter
n
\family default
 kopija znaka 
\family typewriter
'z' 
\family default
objektu 
\family typewriter
str
\family default
.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.at(x)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća znak na poziciji 
\family typewriter
x
\family default
 u objektu 
\family typewriter
str
\family default
.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.capacity()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća veličinu memorije koja je alocirana za string.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.clear()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Briše sve znakove u stringu 
\family typewriter
str
\family default
.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.compare(str2)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Poredi stringove kao funkcija 
\family typewriter
strcmp
\family default
 za C stringove, 
\end_layout

\begin_layout Plain Layout
sa istim povratnim vrednostima.
 
\end_layout

\begin_layout Plain Layout

\family typewriter
str2
\family default
 može da bude niz znakova ili string objekat.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.compare(x, n, str2)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Poredi stringove 
\family typewriter
str1
\family default
 i 
\family typewriter
str2
\family default
 počev od pozicije
\family typewriter
 x
\family default
 narednih
\family typewriter
 n
\family default
 znakova.
 Povratna vrednost je ista kao u funkciji 
\family typewriter
strcmp
\family default
.
 
\end_layout

\begin_layout Plain Layout

\family typewriter
str2
\family default
 može da bude string objekat ili niz znakova.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.copy(str2, x, n)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kopira n znakova niza znakova 
\family typewriter
str2
\family default
 u 
\family typewriter
str1
\family default
 počev od pozicije 
\family typewriter
x
\family default
.
 
\end_layout

\begin_layout Plain Layout
Ako 
\family typewriter
str2
\family default
 nije dovoljno dugačak, 
\end_layout

\begin_layout Plain Layout
funkcija kopira onoliko znakova koliko može da stane.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.data()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća niz znakova sa nulom na kraju, kao u 
\family typewriter
str
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.empty()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća 
\family typewriter
true
\family default
 ako je 
\family typewriter
str
\family default
 prazan.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.erase(x, n)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Briše 
\family typewriter
n
\family default
 znakova iz objekta 
\family typewriter
str
\family default
 počev od pozicije 
\family typewriter
x
\family default
.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.find(str2, x)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća prvu poziciju iza pozicije 
\family typewriter
x
\family default
 gde se string 
\family typewriter
str2
\family default
 nalazi u 
\family typewriter
str1
\family default
.
 
\end_layout

\begin_layout Plain Layout

\family typewriter
str2
\family default
 može da bude string objekat ili niz znakova.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.find('z', x)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća prvu poziciju iza pozicije 
\family typewriter
x
\family default
 na kojoj se znak 
\family typewriter
'z'
\family default
 nalazi u 
\family typewriter
str1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.insert(x, str2)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Umeće kopiju 
\family typewriter
str2
\family default
 u 
\family typewriter
str1
\family default
 počev pod pozicije 
\family typewriter
x
\family default
.
 
\end_layout

\begin_layout Plain Layout

\family typewriter
str2
\family default
 može da bude string objekat ili niz znakova.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.insert(x, n, 'z')
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Umeće 
\family typewriter
'z' n
\family default
 puta u 
\family typewriter
str
\family default
 počev od pozicije 
\family typewriter
x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.length()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća dužinu stringa 
\family typewriter
str
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.replace(x, n, str2)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zamenjuje 
\family typewriter
n
\family default
 znakova u 
\family typewriter
str1
\family default
 počev od pozicije 
\family typewriter
x
\family default
 
\end_layout

\begin_layout Plain Layout
znakovima iz string objekta 
\family typewriter
str2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.size()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća dužinu stringa
\family typewriter
 str
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str.substr(x, n)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vraća kopiju podstringa dugačkog
\family typewriter
 n
\family default
 znakova 
\end_layout

\begin_layout Plain Layout
koji počinje na poziciji 
\family typewriter
x
\family default
 objekta 
\family typewriter
str
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str1.swap(str2)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zamenjuje sadržaj 
\family typewriter
str1
\family default
 sa 
\family typewriter
str2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Sledi primer koji ilustruje korišćenje funkcija članica klase string:
\end_layout

\begin_layout LyX-Code

\size small
string str1 = "ovo je probni string"; 
\end_layout

\begin_layout LyX-Code

\size small
int pozicija = str1.find("probni"); //daje 7 
\end_layout

\begin_layout LyX-Code

\size small
pozicija = str1.find("bla"); //vraca -1 
\end_layout

\begin_layout LyX-Code

\size small
string str2 = str1.substr(7, 2); //pr 
\end_layout

\begin_layout LyX-Code

\size small
str1.replace(4, 2, "vise nije"); //ovo vise nije probni string 
\end_layout

\begin_layout LyX-Code

\size small
str1.erase(4, 7); //ovo je probni string
\end_layout

\begin_layout Section*
Pitanja
\end_layout

\begin_layout Standard
1.
 Kapsuliranje je ______________ podataka.
\end_layout

\begin_layout Standard
a) skrivanje
\end_layout

\begin_layout Standard
b) apstrakcija
\end_layout

\begin_layout Standard
c) nasleđivanje
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
2.
 Uočavanje zajedničkih svojstava objekata i njihovo grupisanje u klasu naziva
 se:
\end_layout

\begin_layout Standard
a) apstrakcija
\end_layout

\begin_layout Standard
b) kapsuliranje
\end_layout

\begin_layout Standard
c) polimorfizam 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
3.
 Objekat je primerak (instanca) neke: 
\end_layout

\begin_layout Standard
a) klase
\end_layout

\begin_layout Standard
b) promenljive
\end_layout

\begin_layout Standard
c) metode 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
4.
 Za definisanje klase koristi se ključna reč: 
\end_layout

\begin_layout Standard
a) method
\end_layout

\begin_layout Standard
b) class
\end_layout

\begin_layout Standard
c) main
\end_layout

\begin_layout Standard
d) object 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
5.
 Privatni članovi klase moraju se deklarisati pre javnih.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
6.
 Javnim podacima članovima objekta izvan objekta pristupa se pomoću:
\end_layout

\begin_layout Standard
a) bilo koje funkcije članice
\end_layout

\begin_layout Standard
b) operatora .
\end_layout

\begin_layout Standard
c) operatora razrešenja dosega (::)
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
7.
 Sakrivanje detalja realizacije klase zove se: 
\end_layout

\begin_layout Standard
a) apstrakcija
\end_layout

\begin_layout Standard
b) kapsuliranje
\end_layout

\begin_layout Standard
c) polimorfizam 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
8.
 Javni članovi klase deklarišu se kao:
\end_layout

\begin_layout Standard
a) 
\family typewriter
public
\end_layout

\begin_layout Standard
b) 
\family typewriter
protected
\end_layout

\begin_layout Standard
c) 
\family typewriter
private
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
9.
 Objekti klase: 
\end_layout

\begin_layout Standard
a) imaju sopstvene kopije vrednosti podataka članova
\end_layout

\begin_layout Standard
b) dele zajedničke vrednosti podataka članova 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
10.
 Unutar deklaracije klase navode se:
\end_layout

\begin_layout Standard
a) definicije funkcija članica 
\end_layout

\begin_layout Standard
b) prototipovi (deklaracije) funkcija članica
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
11.
 Specijalna funkcija članica koja se poziva prilikom kreiranja objekta klase
 zove se: 
\end_layout

\begin_layout Standard
a) glavni metod
\end_layout

\begin_layout Standard
b) metod bez argumenata
\end_layout

\begin_layout Standard
c) konstruktor
\end_layout

\begin_layout Standard
d) rekurzivni metod 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
12.
 U jeziku C++ postoji funkcija bez povratnog tipa i argumenata.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
13.
 Podaci članovi ili funkcije članice deklarisani nakon ključne reči 
\family typewriter
private
\family default
 dostupni su funkcijama članicama klase u kojoj su deklarisani.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
14.
 Promenljive deklarisane u telu neke funkcije članice zovu se podaci članovi
 i mogu se koristiti u svim funkcijama članicama klase.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
15.
 Članovi klase deklarisani kao _________ dostupni su svuda gde je objekat
 klase dostupan.
 
\end_layout

\begin_layout Standard
a) 
\family typewriter
public
\end_layout

\begin_layout Standard
b) 
\family typewriter
protected
\end_layout

\begin_layout Standard
c) 
\family typewriter
private
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
16.
 Operator __________ može se koristiti za dodelu objekta neke klase drugom
 objektu iste klase.
\end_layout

\begin_layout Standard
a) =
\end_layout

\begin_layout Standard
b) == 
\end_layout

\begin_layout Standard
c) konstruktor
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
17.
 Ključna reč __________ označava da se objekat ili promenljiva ne mogu menjati
 nakon inicijalizacije.
 
\end_layout

\begin_layout Standard
a) 
\family typewriter
const
\end_layout

\begin_layout Standard
b) 
\family typewriter
static
\end_layout

\begin_layout Standard
c) 
\family typewriter
volatile
\family default
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
18.
 Pod pretpostavkom da je 
\family typewriter
sapun
\family default
 objekat klase 
\family typewriter
Kozmetika
\family default
, koji od sledećih je važeći poziv funkcije članice 
\family typewriter
operi()
\family default
?
\end_layout

\begin_layout Standard
a) 
\family typewriter
operi();
\end_layout

\begin_layout Standard
b) 
\family typewriter
sapun::operi();
\end_layout

\begin_layout Standard
c) 
\family typewriter
sapun.operi();
\end_layout

\begin_layout Standard
d) 
\family typewriter
sapun:operi();
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
19.
 Ključna reč 
\family typewriter
inline
\family default
: 
\end_layout

\begin_layout Standard
a) ugrađuje telo funkcije neposredno u kôd na mestu pozivanja 
\end_layout

\begin_layout Standard
b) umeće ceo objekat u jedan red 
\end_layout

\begin_layout Standard
c) izvršava kod jednog reda 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
20.
 Operator :: služi za: 
\end_layout

\begin_layout Standard
a) pristup objektu
\end_layout

\begin_layout Standard
b) razrešenje dosega 
\end_layout

\begin_layout Standard
c) poziv metode 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
21.
 Operator strelica -> :
\end_layout

\begin_layout Standard
a) pokazuje na objekat
\end_layout

\begin_layout Standard
b) pokazuje na operator množenja
\end_layout

\begin_layout Standard
c) pristupa članu objekta preko pokazivača 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
22.
 Podrazumevani (default) konstruktor: 
\end_layout

\begin_layout Standard
a) mora da ima argumente
\end_layout

\begin_layout Standard
b) ne sme da ima argumente
\end_layout

\begin_layout Standard
c) može, ali ne mora da ima argumente 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
23.
 Klasa može da ima samo jedan konstruktor.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
24.
 Destruktor klase može da ima argumente.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
25.
 Klasa može da ima više preklopljenih destruktora.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
26.
 Svaka klasa ima konstruktor i destruktor.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
27.
 Klasa može imati više preklopljenih konstruktora.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
28.
 Ako je funkcija i definisana, a ne samo deklarisana unutar definicije klase,
 ona je: 
\end_layout

\begin_layout Standard
a) preklopljena
\end_layout

\begin_layout Standard
b) inline
\end_layout

\begin_layout Standard
c) statička 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
29.
 Skriveni pokazivač na objekat za koji je pozvana funkcija članica zove
 se 
\family typewriter
that
\family default
.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
30.
 Moguće je dodeljivati objekte iste klase jedan drugome.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
31.
 Destruktor klase 
\family typewriter
Primer
\family default
 je: 
\end_layout

\begin_layout Standard
a) 
\family typewriter
Primer::Primer();
\family default
 
\end_layout

\begin_layout Standard
b) 
\family typewriter
Primer::~Primer(); 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
32.
 Potrebno je eksplicitno pozivati destruktor za lokalnu promenljivu.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
33.
 Za svaku klasu mora se napisati konstruktor kopije.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
34.
 Ako se za klasu napiše konstruktor sa argumentima, podrazumevani (default)
 konstruktor više nije dostupan.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
35.
 Konstruktor kopije se poziva u slučaju kada se objekat klase inicijalizuje
 drugim objektom.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
37.
 Za klasu 
\family typewriter
string
\family default
 mora se uključiti zaglavlje:
\end_layout

\begin_layout Standard
a) 
\family typewriter
cstring
\end_layout

\begin_layout Standard
b) 
\family typewriter
string
\end_layout

\begin_layout Standard
c) 
\family typewriter
iostream
\family default
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
38.
 Funkcija ___________ briše znakove iz stringa.
 
\end_layout

\begin_layout Standard
a) 
\family typewriter
erase
\end_layout

\begin_layout Standard
b) 
\family typewriter
delete
\end_layout

\begin_layout Standard
c) 
\family typewriter
at
\family default
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
39.
 Funkcija ___________ pronalazi prvo pojavljivanje bilo kog znaka u stringu.
 
\end_layout

\begin_layout Standard
a) 
\family typewriter
at
\end_layout

\begin_layout Standard
b) 
\family typewriter
find
\end_layout

\begin_layout Standard
c) 
\family typewriter
open
\family default
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
40.
 Konkatenacija (nadovezivanje) string objekata može se postići i pomoću
 operatora +=.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Chapter
Nasleđivanje, virtuelne funkcije i polimorfizam
\end_layout

\begin_layout Standard
U ovom poglavlju bavićemo se osobinama jezika C++ koje ga čine objektno
 orijentisanim: nasleđivanjem, virtuelnim funkcijama i polimorfizmom.
 Nasleđivanje omogućuje izvođenje klasa, odnosno omogućuje jednoj klasi
 da nasledi osobine druge.
 Uz pomoć nasleđivanja možemo da uvedemo hijerarhiju u projektovanje: definišemo
 opštu klasu koja ima zajedničke osobine nekog pojma, iz koje izvodimo specifičn
e klase sa posebnim svojstvima.
 Na nasleđivanje se oslanjaju virtuelne funkcije pomoću kojih je implementiran
 polimorfizam, odnosno objektno orijentisana filozofija 
\begin_inset Quotes sld
\end_inset

jedan interfejs, više metoda
\begin_inset Quotes srd
\end_inset

.
\end_layout

\begin_layout Section
Nasleđivanje
\end_layout

\begin_layout Standard
Klasa iz koje se izvode druge klase u jeziku C++ zove se 
\shape italic
osnovna klasa
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!osnovna
\end_layout

\end_inset

 (base class).
 Klase koje nasleđuju osnovnu klasu zovu se 
\shape italic
izvedene klase
\shape default
 (derived class).
 Izvedena klasa je specijalan slučaj osnovne klase.
 Izvedena klasa
\begin_inset Index idx
status open

\begin_layout Plain Layout
izvedena klasa
\end_layout

\end_inset

 nasleđuje sve podatke članove osnovne klase, ali joj dodaje i neke svoje,
 posebne.
 U jeziku C++ nasleđivanje je implementirano tako što se u deklaraciju izvedene
 klase ugrađuje osnovna klasa.
 Počećemo sa jednostavnim primerom koji ilustruje najvažnije osobine nasleđivanj
a
\begin_inset Index idx
status open

\begin_layout Plain Layout
nasleđivanje
\end_layout

\end_inset

.
 Sledeći primer kreira osnovnu klasu 
\family typewriter
DvaDOblik
\family default
 u kojoj se čuvaju visina i širina dvodimenzionalnog objekta, i iz nje izvodi
 klasu 
\family typewriter
Trougao
\family default
: 
\end_layout

\begin_layout LyX-Code

\size small
class DvaDOblik { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
double visina; 
\end_layout

\begin_layout LyX-Code

\size small
double sirina; 
\end_layout

\begin_layout LyX-Code

\size small
void prikaziDimenzije() { cout << "sirina: " << sirina << ", " 
\end_layout

\begin_layout LyX-Code

\size small
<< "visina: " << visina << endl; } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class Trougao: public DvaDOblik { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
string vrsta; 
\end_layout

\begin_layout LyX-Code

\size small
double povrsina() { return sirina * visina / 2; } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Klasa 
\family typewriter
DvaDOblik
\family default
 definiše svojstva opšteg dvodimenzionalnog oblika, a to može biti kvadrat,
 pravougaonik, trougao, romb itd.
 Klasa 
\family typewriter
Trougao
\family default
 je specifična vrsta dvodimenzionalnog oblika koja ima sve njegove osobine
 (širinu i visinu), ali i još nešto što je specifično za trougao.
 To su podatak član vrsta (koji opisuje da li je trougao jednakostranični,
 pravougli, jednakokraki) i funkcija članica 
\family typewriter
povrsina()
\family default
 koja racuna povrsinu trougla.
 Kao što ovaj primer pokazuje, sintaksa izvođenja klase
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!izvođenje
\end_layout

\end_inset

 je prilično jednostavna:
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
class izvedena_klasa : specifikator_izvodjenja osnovna_klasa { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
// telo izvedene klase 
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
} 
\end_layout

\begin_layout Standard
Specifikator izvođenja
\begin_inset Index idx
status open

\begin_layout Plain Layout
specifikator izvođenja
\end_layout

\end_inset

 nije obavezan, ali ako se navede, mora biti jedna od vrednosti 
\family typewriter
public
\family default
, 
\family typewriter
private
\family default
 ili 
\family typewriter
protected
\family default
.
 Detalje o tome saznaćemo u nastavku poglavlja, a za sada treba znati da
 kada se koristi specifikator 
\family typewriter
public
\family default
 (što je najčešće slučaj), svi javni članovi osnovne klase biti javni i
 u izvedenim klasama.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/Nasledjivanje.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
Slika 7.1: Hijerarhija izvođenja klasa.
\end_layout

\begin_layout Standard
Pošto klasa 
\family typewriter
Trougao
\family default
 sadrži sve članove svoje osnovne klase 
\family typewriter
DvaDOblik
\family default
, može da im pristupi unutar funkcije članice 
\family typewriter
površina()
\family default
.
 Takođe, iako je 
\family typewriter
DvaDOblik
\family default
 osnovna klasa za 
\family typewriter
Trougao
\family default
, to je potpuno nezavisna klasa koja može samostalno da se koristi.
\end_layout

\begin_layout Standard
Na sličan način kao klasa 
\family typewriter
Trougao
\family default
, iz klase 
\family typewriter
DvaDOblik
\family default
 mogla bi se izvesti klasa 
\family typewriter
Pravougaonik 
\family default
sa metodama 
\family typewriter
kvadrat()
\family default
, koji određuje da li je pravougaonik kvadrat i 
\family typewriter
povrsina()
\family default
, koji računa površinu pravougaonika:
\end_layout

\begin_layout LyX-Code

\size small
class Pravougaonik: public DvaDOblik { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
bool kvadrat() {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
if(duzina == sirina)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return true;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
else
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return false;
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\end_deeper
\begin_layout LyX-Code

\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
double povrsina() { return sirina * visina; } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Najveća prednost nasleđivanja je u tome što kada se jednom kreira osnovna
 klasa koja definiše svojstva zajednička za skup objekata, ona se dalje
 može koristiti da bi se iz nje izveo proizvoljan broj specifičnih klasa.
 Svaka izvedena klasa može precizno da prilagodi svoja svojstva, kao što
 smo videli u slučaju metode 
\family typewriter
povrsina()
\family default
 koja je različita za klase 
\family typewriter
Trougao
\family default
 i 
\family typewriter
Pravougaonik
\family default
.
 Time se pojednostavljuje održavanje programa, a istovremeno omogućuje ponovno
 korišćenje kôda.
 Ako je potrebno promeniti neku osobinu klase, neće se menjati osnovna klasa,
 već će iz nje biti izvedena klasa koja opisuje ta specijalna svostva.
 Time će postojeći kôd ostati nepromenjen.
\end_layout

\begin_layout Section
Kontrola pristupa članovima klase
\end_layout

\begin_layout Standard
Već smo naučili da se podaci članovi klase
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!kontrola pristupa članovima
\end_layout

\end_inset

 po pravilu deklarišu kao privatni da bi se sprečilo njihovo neovlašćeno
 korišćenje ili menjanje.
 Nasleđivanjem ne mogu da se naruše ograničenja pristupa članovima osnovne
 klase koja su već definisana.
 Tako, iako izvedena klasa nasleđuje sve članove iz osnovne, ona ne može
 da pristupi članovima osnovne klase koji su deklarisani kao privatni.
 U prethodnom primeru, da su podaci članovi 
\family typewriter
visina
\family default
 i 
\family typewriter
sirina
\family default
 u klasi 
\family typewriter
DvaDOblik
\family default
 bili deklarisani kao privatni, metod 
\family typewriter
povrsina()
\family default
 klasa 
\family typewriter
Trougao
\family default
 i 
\family typewriter
Pravougaonik
\family default
 ne bi mogao da im pristupi.
\end_layout

\begin_layout Standard
Rešenje ovog ograničenja nije u tome da se podaci članovi učine javnim kao
 u prethodnom primeru, jer tako osim izvedenoj klasi postaju dostupni i
 drugom kôdu.
 Postoje dva rešenja za ovaj problem: prvo je da se koristi specifikator
 pristupa 
\family typewriter

\begin_inset Newline linebreak
\end_inset

protected
\family default
, a drugo da se koriste javne funkcije koje će omogućiti pristup privatnim
 podacima članovima.
 Proučićemo oba pristupa.
\end_layout

\begin_layout Subsection
Specifikator pristupa protected
\end_layout

\begin_layout Standard
Zaštićeni član osnovne klase je isti kao privatan, uz jedan važan izuzetak:
 mogu da mu pristupe izvedene klase.
 Zaštićeni član se deklariše pomoću ključne reči 
\family typewriter
protected
\family default
.
 Tako pomoću modifikatora
\family typewriter
 protected
\family default
 mogu
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
protected
\family default
!specifikator pristupa
\end_layout

\end_inset

 da se kreiraju podaci članovi klase koji su privatni, ali im mogu pristupiti
 izvedene klase.
 Proučimo sledeći primer:
\end_layout

\begin_layout LyX-Code

\size small
class osnovna { 
\end_layout

\begin_layout LyX-Code

\size small
private: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int privatan; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
protected: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int zasticen; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
int javan; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class izvedena: public osnovna { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
void prikazi() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << zasticen << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << javan << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << privatan; //greska! 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Da su u prethodnom primeru podaci članovi 
\family typewriter
privatan
\family default
 i 
\family typewriter
zasticen
\family default
 bili deklarisani kao 
\family typewriter
private
\family default
, izvedena klasa ne bi mogla da im pristupi i kôd se ne bi kompajlirao.
 Specifikator pristupa protected može da se navede bilo gde u deklaraciji
 klase, a najčešće se navodi posle (podrazumevanih) privatnih članova, a
 pre javnih.
 Zbog toga je najčešći oblik deklaracije klase sledeći: 
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
class ime_klase{ 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
//privatni clanovi 
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
protected: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
//zasticeni clanovi
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
//javni clanovi 
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
}; 
\end_layout

\begin_layout Subsection
Javno i privatno izvođenje
\end_layout

\begin_layout Standard
Kada se klasa izvodi iz osnovne klase sa specifikatorom pristupa 
\family typewriter
public
\family default
, sledećom sintaksom:
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
class izvedena: public osnovna { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
//telo izvedene klase
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
};
\size default
 
\end_layout

\begin_layout Standard
zaštićeni članovi osnovne klase ostaju zaštićeni i u izvedenoj klasi.
 Kada se klasa izvodi sa specifikatorom pristupa 
\family typewriter
private
\family default
, zaštićeni članovi osnovne klase postaju privatni u izvedenoj klasi.
 U opštem slučaju, nasleđivanjem dostupnost podataka članova može eventualno
 ostati na istom nivou, a nikako se ne može povećati.
\end_layout

\begin_layout Standard
Javno izvođenje
\begin_inset Index idx
status open

\begin_layout Plain Layout
nasleđivanje!javno izvođenje
\end_layout

\end_inset

 realizuje pojam nasleđivanja u opštem smislu: javni članovi osnovne klase
 jesu javni članovi i izvedene klase, pa korisnici izvedene klase mogu da
 “vide” sve osobine osnovne klase i u izvedenoj klasi.
 U tom slučaju, izvedena klasa je vrsta (a kind of) osnovne klase.
\end_layout

\begin_layout Standard
Privatno izvođenje
\begin_inset Index idx
status open

\begin_layout Plain Layout
nasleđivanje!privatno izvođenje
\end_layout

\end_inset

 realizuje pojam sadržavanja (kompozicije): javni članovi osnovne klase
 su sakriveni u izvedenoj klasi, tj.
 objekti izvedene klase sadrže objekat osnovne klase u sebi.
 Osnovna klasa je deo (a part of) izvedene klase.
 Ovakva vrsta izvođenja može se realizovati i članstvom objekata, tj.
 kompozicijom.
 Tako je deklaracija:
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
class izvedena: private osnovna { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
//telo izvedene klase
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
};
\end_layout

\begin_layout Standard
funkcionalno identična sa
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
class izvedena { 
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
private:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
osnovna o;
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
//telo klase
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
};
\end_layout

\begin_layout Standard
Specifikator izvođenja nije obavezno navesti u deklaraciji klase, a ako
 se ne navede, podrazumeva se privatno izvođenje.
 
\end_layout

\begin_layout Standard
Postoji i zaštićeno izvođenje, kada se kao specifikator izvođenja navodi
 ključna reč 
\family typewriter
protected
\family default
.
 Kada se klasa izvede kao zaštićena, svi javni i zaštićeni članovi osnovne
 klase postaju zaštićeni članovi u izvedenoj klasi.
 Zaštićeno izvođenje se skoro nikad ne koristi u praksi jer nema uporišta
 u stvarnim problemima objektno orijentisanog projektovanja.
\end_layout

\begin_layout Subsection
Inspektori i mutatori
\end_layout

\begin_layout Standard
C++ programeri obično pristupaju privatnim podacima članovima klase preko
 javnih funkcija članica.
 Funkcije koje samo čitaju vrednosti podataka članova, a ne menjaju ih,
 zovu se 
\shape italic
inspektorske funkcije članice
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
inspektorske funkcije članice
\end_layout

\end_inset

 (accessor functions).
 Slično, funkcije članice koje menjaju vrednost svojih podataka članova
 zovu se 
\shape italic
mutatorske funkcije
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
mutatorske funkcije članice
\end_layout

\end_inset

 (mutator functions).
 Ovako bi izgledala klasa 
\family typewriter
DvaDOblik
\family default
 sa dodatim inspektorima i mutatorima funkcijama za širinu i visinu:
\end_layout

\begin_layout LyX-Code

\size small
class DvaDOblik { 
\end_layout

\begin_layout LyX-Code

\size small
private: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
double visina; 
\end_layout

\begin_layout LyX-Code

\size small
double sirina; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
void prikaziDimenzije() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "sirina: " << sirina << ", " 
\end_layout

\begin_layout LyX-Code

\size small
<< "visina: " << visina << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
//inspektori
\end_layout

\begin_layout LyX-Code

\size small
double getVisina() const { return visina;} 
\end_layout

\begin_layout LyX-Code

\size small
double getSirina() const { return sirina;}
\end_layout

\begin_layout LyX-Code

\size small
//mutatori
\end_layout

\begin_layout LyX-Code

\size small
void setSirina(double s) { sirina = s;}
\end_layout

\begin_layout LyX-Code

\size small
void setVisina(double v) { visina = v;}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Pošto su 
\family typewriter
setVisina()
\family default
, 
\family typewriter
setSirina()
\family default
 i 
\family typewriter
prikaziDimenzije()
\family default
 javne funkcije članice klase 
\family typewriter
DvaDOblik
\family default
, mogu se pozvati za objekat tog tipa iz funkcije 
\family typewriter
main()
\family default
.
 U isto vreme, pošto su podaci članovi 
\family typewriter
sirina
\family default
 i 
\family typewriter
visina
\family default
 privatni, oni ostaju privatni i u izvedenoj klasi i ona ne može da im pristupa.
 
\end_layout

\begin_layout Standard
Da bismo rekli kompajleru da je metod inspektorski i da treba da mu bude
 dozvoljeno samo da radi sa objektima, ali da ih ne menja, taj metod treba
 da bude deklarisan kao konstantan.
 Konstantan metod (inspektor) deklariše se dodavanjem ključne reči
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
const
\family default
!u funkcijama članicama
\end_layout

\end_inset

 
\family typewriter
const
\family default
 iza zagrada i u deklaraciji i u definiciji funkcije članice, kao u prethodnom
 primeru funkcija 
\family typewriter
getVisina()
\family default
 i 
\family typewriter
getSirina()
\family default
.
 Deklarisanje funkcija članica kao konstantnih nije obavezno, ali je dobra
 programerska praksa, jer kompajler proverava da li je konstantnost ispunjena.
 To je zapravo “obećanje” projektanta klase korisnicima te klase da neka
 funkcija neće menjati stanje objekta.
 
\end_layout

\begin_layout Section
Konstruktori i destruktori izvedenih klasa
\end_layout

\begin_layout Standard
U hijerarhiji klasa, moguće je (i najčešće potrebno) da i osnovna klasa
 i izvedene klase imaju svoje konstruktore
\begin_inset Index idx
status open

\begin_layout Plain Layout
konstruktori!u izvedenim klasama
\end_layout

\end_inset

.
 Postavlja se pitanje koji konstruktor je odgovoran za kreiranje objeta
 izvedene klase.
 Odgovor je da konstruktor osnovne klase kreira deo objekta koji pripada
 osnovnoj klasi, a konstruktor izvedene klase kreira samo deo objekta iz
 izvedene klase.
 To ima smisla zato što osnovna klasa ne zna ništa o svojstvima objekta
 u izvedenoj klasi.
 U ovom odeljku objasnićemo kako C++ upravlja situacijama u kojima postoje
 konstruktori osnovne i izvedene klase.
\end_layout

\begin_layout Standard
Kada samo izvedena klasa ima konstruktor, rešenje je jednostavno: poziva
 se konstruktor za izvedenu klasu, a deo objekta osnovne klase kreira se
 automatski, pozivom podrazumevanog (default) konstruktora osnovne klase.
 Na primer, evo prepravljene verzije klase 
\family typewriter
Trougao
\family default
 u kojoj je definisan konstruktor:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <string>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class DvaDOblik { 
\end_layout

\begin_layout LyX-Code

\size small
private: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
double visina; 
\end_layout

\begin_layout LyX-Code

\size small
double sirina; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
void prikaziDimenzije() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "sirina: " << sirina << ", " << 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
"visina: " << visina << endl; 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
double getVisina() const { return visina;} 
\end_layout

\begin_layout LyX-Code

\size small
double getSirina() const { return sirina;} 
\end_layout

\begin_layout LyX-Code

\size small
void setSirina(double s) { sirina = s;} 
\end_layout

\begin_layout LyX-Code

\size small
void setVisina(double v) { visina = v;}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class Trougao: public DvaDOblik { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
string vrsta; 
\end_layout

\begin_layout LyX-Code

\size small
double povrsina() { return getSirina() * getVisina() / 2; } 
\end_layout

\begin_layout LyX-Code

\size small
Trougao(string tip, double v, double s) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//inicijalizacija osnovnog objekta 
\end_layout

\begin_layout LyX-Code

\size small
setSirina(s); 
\end_layout

\begin_layout LyX-Code

\size small
setVisina(v); 
\end_layout

\begin_layout LyX-Code

\size small
//inicijalizacija izvedenog dela 
\end_layout

\begin_layout LyX-Code

\size small
vrsta = tip; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
void prikaziVrstu() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Trougao je: " << vrsta << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Kada su i u osnovnoj i u izvedenoj klasi definisani konstruktori, postupak
 je složeniji.
 Kada osnovna klasa ima konstruktor, izvedena klasa mora eksplicitno da
 ga pozove da bi inicijalizovao deo objekta iz osnovne klase.
 Izvedena klasa poziva konstruktor svoje osnovne klase specijalnim oblikom
 deklaracije u konstruktoru izvedene klase:
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
ime_izvedene_klase(lista_argumenata) : 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
konstruktor_osnovne_klase(lista_argumenata); { 
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
//telo konstruktora izvedene klase
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
} 
\end_layout

\begin_layout Standard
Primetite dvotačku koja razdvaja deklaraciju konstruktora izvedene klase
 od poziva konstruktora osnovne klase.
 Sledeći program ilustruje kako se prosleđuju argumenti konstruktoru osnovne
 klase:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <string>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class DvaDOblik { 
\end_layout

\begin_layout LyX-Code

\size small
private: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
double visina; 
\end_layout

\begin_layout LyX-Code

\size small
double sirina; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
void prikaziDimenzije() { 
\end_layout

\begin_layout LyX-Code

\size small
cout << "sirina: " << sirina << ", " << 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
"visina: " << visina << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
double getVisina() const { return visina;} 
\end_layout

\begin_layout LyX-Code

\size small
double getSirina() const { return sirina;} 
\end_layout

\begin_layout LyX-Code

\size small
void setSirina(double s) { sirina = s;} 
\end_layout

\begin_layout LyX-Code

\size small
void setVisina(double v) { visina = v;} 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//konstruktor osnovne klase 
\end_layout

\begin_layout LyX-Code

\size small
DvaDOblik(double s, double v) { sirina = s; visina = v; }
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class Trougao: public DvaDOblik { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
string vrsta; 
\end_layout

\begin_layout LyX-Code

\size small
double povrsina() { return getSirina() * getVisina() / 2; } 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
Trougao(string tip, double s, double v) : DvaDOblik(s, v) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//inicijalizacija izvedenog dela 
\end_layout

\begin_layout LyX-Code

\size small
vrsta = tip; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
void prikaziVrstu() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Trougao je: " << vrsta << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Trougao t("jednakostranicni", 4.0, 4.0); 
\end_layout

\begin_layout LyX-Code

\size small
t.prikaziDimenzije(); 
\end_layout

\begin_layout LyX-Code

\size small
t.prikaziVrstu(); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Povrsina trougla je: " << t.povrsina() << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
sirina: 4, visina: 4
\end_layout

\begin_layout Standard

\series bold
\size small
Trougao je: jednakostranicni
\end_layout

\begin_layout Standard

\series bold
\size small
Povrsina trougla je: 8
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Ovde konstruktor 
\family typewriter
Trougao() 
\family default
poziva konstruktor osnovne klase 
\family typewriter
DvaDOblik
\family default
 sa paramerima 
\family typewriter
v
\family default
 i 
\family typewriter
s
\family default
, kojima se inicijalizuju podaci članovi 
\family typewriter
visina
\family default
 i 
\family typewriter
sirina
\family default
 iz osnovne klase.
 Konstruktor klase 
\family typewriter
Trougao
\family default
 treba da inicijalizuje samo član koji je jedinstven za trougao, a to je
 
\family typewriter
vrsta
\family default
.
 Na taj način se klasi 
\family typewriter
DvaDOblik
\family default
 ostavlja potpuna sloboda da konstruiše podobjekat osnovne klase.
 Takođe, u klasu 
\family typewriter
DvaDOblik
\family default
 mogu se dodati svojstva za koja izvedene klase ne moraju ni da znaju, bez
 narušavanja postojećeg kôda.
 Izvedena klasa može da pozove sve oblike konstruktora osnovne klase; izvršava
 se onaj konstruktor koji odgovara navedenim argumentima.
 Na primer, u klasama 
\family typewriter
DvaDOblik
\family default
 i 
\family typewriter
Trougao
\family default
 može da bude definisano nekoliko konstruktora
\begin_inset Index idx
status open

\begin_layout Plain Layout
konstruktori!preklopljeni
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code

\size small
DvaDOblik::DvaDOblik(double s, double v) { sirina = s; visina = v; } 
\end_layout

\begin_layout LyX-Code

\size small
DvaDOblik::DvaDOblik(double x) { sirina = visina = x; } 
\end_layout

\begin_layout LyX-Code

\size small
//default konstruktor
\end_layout

\begin_layout LyX-Code

\size small
DvaDOblik::DvaDOblik() { sirina = visina = 0.0; }
\end_layout

\begin_layout LyX-Code

\size small
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
//default konstruktor
\end_layout

\begin_layout LyX-Code

\size small
Trougao::Trougao() { vrsta = "nepoznat"; }
\end_layout

\begin_layout LyX-Code

\size small
Trougao::Trougao(string tip, double v, double s): 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
DvaDOblik(s, v) { vrsta = tip; }
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
//konstruktor jednakostranicnog trougla
\end_layout

\begin_layout LyX-Code

\size small
Trougao::Trougao(string tip, double x): 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
DvaDOblik(x) { vrsta = 
\begin_inset Quotes sld
\end_inset

jednakostranicni; }
\end_layout

\end_deeper
\begin_layout Standard

\end_layout

\begin_layout Standard
U hijerarhiji klasa, ako konstruktor osnovne klase zahteva parametre, onda
 sve izvedene klase moraju da prosleđuju taj parametar 
\begin_inset Quotes sld
\end_inset

naviše
\begin_inset Quotes srd
\end_inset

.
 To pravilo važi bez obzira da li konstruktor izvedene klase ima parametre
 ili ne.
 
\end_layout

\begin_layout Standard
Postavlja se pitanje kojim redom se pozivaju konstruktori kada se kreira
 objekat izvedene klase.
 Odgovor na to pitanje daće nam sledeći primer:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class X {  
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
X() { cout << "konstruktor klase X" << endl; } 
\end_layout

\begin_layout LyX-Code

\size small
~X() { cout << "destruktor klase X" << endl; } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class osnovna {  
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
osnovna() { cout << "konstruktor osnovne klase" << endl; } 
\end_layout

\begin_layout LyX-Code

\size small
~osnovna() { cout << "destruktor osnovne klase" << endl; } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class izvedena {  	
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
X x; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
izvedena() { cout << "konstruktor izvedene klase" << endl; } 
\end_layout

\begin_layout LyX-Code

\size small
~izvedena() { cout << "destruktor izvedene klase" << endl; } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 	
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
izvedena i;
\end_layout

\begin_layout LyX-Code

\size small
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
konstruktor osnovne klase 
\end_layout

\begin_layout Standard

\series bold
\size small
konstruktor klase X
\end_layout

\begin_layout Standard

\series bold
\size small
konstruktor izvedene klase 
\end_layout

\begin_layout Standard

\series bold
\size small
destruktor izvedene klase
\end_layout

\begin_layout Standard

\series bold
\size small
destruktor klase X
\end_layout

\begin_layout Standard

\series bold
\size small
destruktor osnovne klase
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Ovaj program samo kreira i uništava objekat 
\family typewriter
ob
\family default
 klase izvedene iz osnovne klase, koji u sebi sadrži i jedan podatak član
 tipa klase 
\family typewriter
X
\family default
.
 Kao što rezultat izvršavanja ilustruje, prvo se izvršava konstruktor osnovne
 klase, zatim konstruktori svih eventualnih klasa podataka članova, i na
 kraju konstruktor izvedene klase.
 Pošto se objekat 
\family typewriter
ob
\family default
 uništava čim se završi 
\family typewriter
main()
\family default
, redosled pozivanja destruktora je obrnut: prvo se poziva destruktor izvedene
 klase, zatim destruktori svih klasa podatak članova, i na kraju destruktor
 izvedene klase.
 Drugim rečima, konstruktori
\begin_inset Index idx
status open

\begin_layout Plain Layout
konstruktori!redosled pozivanja
\end_layout

\end_inset

 se pozivaju u redosledu izvođenja, a destruktori u obrnutom smeru.
 To pravilo je intuitivno jasno, jer kada bi se destruktori
\begin_inset Index idx
status open

\begin_layout Plain Layout
destruktori!redosled pozivanja
\end_layout

\end_inset

 pozivali u redosledu izvođenja, prvo bi bio uništen deo objekta koji pripada
 osnovnoj klasi, pa bi u memoriji ostao nepotpun objekat sa delom koji pripada
 samo izvedenoj klasi kome ne bi moglo da se pristupi.
\end_layout

\begin_layout Section
Višestruko nasleđivanje
\end_layout

\begin_layout Standard
Klasa može da nasledi nekoliko osnovnih klasa; tada svaki objekat izvedene
\begin_inset Index idx
status open

\begin_layout Plain Layout
nasleđivanje!višestruko
\end_layout

\end_inset

 klase nasleđuje sve članove svih svojih osnovnih klasa.
 Na primer, motocikl sa prikolicom je jedna vrsta motocikla, ali i jedna
 vrsta vozila sa tri točka.
 Pri tom, motocikl nije vrsta vozila sa tri točka, niti je vozilo sa tri
 točka vrsta motocikla, već su to dve različite klase.
 Klasa se višestruko izvodi tako što se u zaglavlju njene deklaracije navode
 imena osnovnih klasa razdvojena zarezima, kao u sledećem primeru: 
\end_layout

\begin_layout LyX-Code

\size small
class Motocikl { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code

\size small
class VoziloSaTriTocka { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code

\size small
 
\end_layout

\begin_layout LyX-Code

\size small
class MotociklSaPrikolicom: public VoziloSaTriTocka, public Motocikl { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
//
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Section
Pokazivači na objekte izvedenih klasa
\end_layout

\begin_layout Standard
Da bismo razumeli virtuelne funkcije i polimorfizam, potrebno je da savladamo
 još jednu važnu osobinu pokazivača u jeziku C++.
 Već smo naučili da se pokazivači mogu dodeljivati jedan drugome samo ako
 su istog osnovnog tipa (odnosno, pokazivač na 
\family typewriter
int
\family default
 ne može se dodeliti pokazivaču na 
\family typewriter
double
\family default
, osim uz eksplicitnu konverziju koja gotovo nikad nije dobra ideja).
 Međutim, postoji jedan važan izuzetak od tog pravila: u jeziku C++, pokazivač
\begin_inset Index idx
status open

\begin_layout Plain Layout
pokazivači!na objekte izvedenih klasa
\end_layout

\end_inset

 na objekat osnovne klase može da pokazuje i na objekat bilo koje klase
 koja je izvedena iz te osnovne klase.
 To ćemo ilustrovati sledećim primerom: 
\end_layout

\begin_layout LyX-Code

\size small
osnovna osnovni_ob; 
\end_layout

\begin_layout LyX-Code

\size small
izvedena izvedeni_ob; 
\end_layout

\begin_layout LyX-Code

\size small
osnovna *po; 
\end_layout

\begin_layout LyX-Code

\size small
//obe sledece naredbe su u redu 
\end_layout

\begin_layout LyX-Code

\size small
po = &osnovni_ob; 
\end_layout

\begin_layout LyX-Code

\size small
po = &izvedeni_ob;
\end_layout

\begin_layout Standard
Pokazivač na objekat osnovne klase može se koristiti za pristup samo onim
 delovima objekta izvedene klase koji su nasleđeni iz osnovne klase.
 Tako se u prethodnom primeru pokazivač 
\family typewriter
po
\family default
 može koristiti za pristup svim elementima objekta 
\family typewriter
izvedeni_ob
\family default
 koji su nasleđeni iz klase osnovna.
 Treba razumeti i da iako se pokazivač na osnovnu klasu može koristiti za
 pokazivanje na izvedeni objekat, obrnuto ne važi, odnosno pokazivač na
 objekat izvedene klase ne može se koristiti kao pokazivač na objekat osnovne
 klase.
 Takođe, prisetimo se da se pokazivač inkrementira i dekrementira u skladu
 sa svojim osnovnim tipom, odnosno sa tipom objekta na koji pokazuje.
 Kada pokazivač na osnovnu klasu pokazuje na objekat izvedene klase, inkrementir
anje ga neće pomeriti na sledeći objekat osnovne klase, već na ono što on
 
\begin_inset Quotes sld
\end_inset

misli
\begin_inset Quotes srd
\end_inset

 da je sledeći objekat osnovne klase.
 Zbog toga treba biti pažljiv.
 Činjenica da se pokazivač na osnovni tip može koristiti i kao pokazivač
 na izvedene tipove je izuzetno važna osobina jezika C++ i način na koji
 se u njemu implementira polimorfizam
\begin_inset Index idx
status open

\begin_layout Plain Layout
polimorfizam
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Nadjačavanje funkcija u izvedenim klasama
\end_layout

\begin_layout Standard
Ponekad je korisno da izvedena klasa promeni 
\begin_inset Quotes sld
\end_inset

ponašanje
\begin_inset Quotes srd
\end_inset

 osnovne klase, odnosno da definiše sopstvenu verziju nekog metoda iz osnovne
 klase.
 To se zove 
\shape italic
nadjačavanje
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!nadjačavanje
\end_layout

\end_inset

 
\shape italic
funkcija
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
nadjačavanje funkcija
\end_layout

\end_inset

 
\shape italic
članica
\shape default
 (overriding), a znači da svaka izvedena klasa može da ima svoju verziju
 funkcije iz osnovne klase.
 Primer nadjačavanja smo već videli u klasama 
\family typewriter
DvaDOblik
\family default
 i 
\family typewriter
Trougao
\family default
 na primeru funkcije 
\family typewriter
povrsina()
\family default
, koja je različito definisana za ove dve klase:
\end_layout

\begin_layout LyX-Code

\size small
double DvaDOblik::povrsina() { return getSirina() * getVisina(); }
\end_layout

\begin_layout LyX-Code

\size small
double Trougao::povrsina() { return getSirina() * getVisina() / 2; }
\end_layout

\begin_layout Standard
Treba razlikovati preklapanje
\begin_inset Index idx
status open

\begin_layout Plain Layout
preklapanje funkcija
\end_layout

\end_inset

 i nadjačavanje funkcija.
 Preklopljene funkcije imaju isto ime, ali različit broj i(li) tipove argumenata.
 Kompajler na osnovu tipa i broja stvarnih argumenata preklopljene funkcije
 određuje koju će verziju funkcije pozvati.
 Preklapanje se može koristiti i za 
\begin_inset Quotes sld
\end_inset

obične
\begin_inset Quotes srd
\end_inset

 funkcije, tj.
 i za funkcije koje nisu članice neke klase, a kada se koristi u klasama,
 tada imamo nekoliko funkcija članica istog imena u istoj klasi.
 
\end_layout

\begin_layout Standard
Nadjačane funkcije postoje samo u različitim klasama.
 One imaju isto ime, povratni tip, broj i tip parametara.
 Razlikuju im se samo tela u osnovnoj i izvedenim klasama.
 Važno je primetiti da iako izvedene klase imaju svoju verziju nadjačane
 funkcije, objekti tipa osnovne klase pozivaće svoju, 
\begin_inset Quotes sld
\end_inset

osnovnu
\begin_inset Quotes srd
\end_inset

 verziju nadjačane funkcije, kao što ilustruje sledeći primer:
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class osnovna { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
void prikaziPoruku() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "ovo je osnovna klasa" << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class izvedena: public osnovna { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
void prikaziPoruku() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "ovo je izvedena klasa" << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
osnovna o; 
\end_layout

\begin_layout LyX-Code

\size small
izvedena i; 
\end_layout

\begin_layout LyX-Code

\size small
o.prikaziPoruku(); 
\end_layout

\begin_layout LyX-Code

\size small
i.prikaziPoruku(); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
ovo je osnovna klasa
\end_layout

\begin_layout Standard

\series bold
\size small
ovo je izvedena klasa
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Section
Virtuelne funkcije i polimorfizam
\end_layout

\begin_layout Standard

\shape italic
Polimorfizam
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
polimorfizam
\end_layout

\end_inset

 je veoma važna osobina objektno orijentisanog jezika jer omogućuje da osnovna
 klasa definiše funkcije koje će biti zajedničke za sve izvedene klase,
 ali da izvedenim klasama ostavi slobodu da same implementiraju sve te funkcije
 (ili samo neke od njih).
 Ponekad se ideja polimorfizma objašnjava i ovako: osnovna klasa diktira
 opšti interfejs koji će imati sve klase izvedene iz nje, ali ostavlja izvedenim
 klasama da definišu kako će zaista implementirati taj interfejs.
 Zbog toga se polimorfizam često opisuje frazom “jedan interfejs, više metoda”.
 Da bi se razumeo polimorfizam, treba imati na umu da osnovna klasa i izvedene
 klase formiraju hijerarhiju koja se kreće od uže generalizacije ka široj
 (tj.
 od osnovne ka izvedenim klasama).
 Kada je pravilno projektovana, osnovna klasa ima sve elemente koje izvedene
 klase mogu direktno da koriste, kao i funkcije koje bi izvedene klase trebalo
 samostalno da implementiraju.
 Pošto interfejs diktira osnovna klasa, deliće ga sve izvedene klase, ali
 će implementacija interfejsa biti specifična za svaku od njih.
 Postavlja se pitanje zašto je toliko važno imati dosledan interfejs sa
 različitim implementacijama.
 Da bismo odgovorili na to pitanje, podsetimo se ideje vodilje objektno
 orijentisanog pristupa, a to je da treba da olakša održavanje veoma složenih
 programa.
 Ako je program pravilno projektovan, zna se da se svim objektima izvedenim
 iz osnovne klase pristupa na isti način, iako će se njihovo ponašanje pomalo
 razlikovati u zavisnosti od toga kojoj izvedenoj klasi pripadaju.
 To znači da programer treba da zapamti samo jedan interfejs, umesto nekoliko
 njih.
 Takođe, izvedena klasa može da koristi sve funkcije osnovne klase, ako
 joj tako odgovara; nema potrebe da 
\begin_inset Quotes sld
\end_inset

izmišlja toplu vodu
\begin_inset Quotes srd
\end_inset

.
 Razdvajanje interfejsa i implementacije omogućuje projektovanje biblioteka
 klasa, koje se zatim mogu koristiti za izvođenje sopstvenih klasa koje
 zadovoljavaju postavljene zahteve.
 To je veliko olakšanje u programiranju složenih sistema.
\end_layout

\begin_layout Standard
Da bi se u jeziku C++ ostvario polimorfizam, koriste se virtuelne funkcije
\begin_inset Index idx
status open

\begin_layout Plain Layout
virtuelne funkcije
\end_layout

\end_inset

.
 
\shape italic
Virtuelna funkcija
\shape default
 je deklarisana ključnom reči 
\family typewriter
virtual
\family default
 u osnovnoj klasi i za nju se pretpostavlja da će biti nadjačana u izvedenim
 klasama.
 Ključna reč
\family typewriter
 virtual
\begin_inset Index idx
status open

\begin_layout Plain Layout
virtual
\end_layout

\end_inset


\family default
 na početku deklaracije virtuelne funkcije u osnovnoj klasi ne ponavlja
 se u izvedenim klasama (mada nije greška ako se to uradi); takođe, kada
 je funkcija jednom deklarisana kao virtuelna u osnovnoj klasi, ona ostaje
 takva bez obzira na dubinu hijerarhije izvođenja.
 Klasa koja sadrži virtuelnu funkciju zove se 
\shape italic
polimorfna klasa
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
polimorfna klasa
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Kada se virtuelna funkcija pozove preko pokazivača na osnovnu klasu, C++
 određuje koja će se nadjačana verzija te funkcije pozvati na osnovu tipa
 objekta na koji pokazuje pokazivač, a ne na osnovu njegovog osnovnog tipa.
 Određivanje koja će verzija funkcije biti pozvana dešava se tokom izvršavanja
 programa.
 Dakle, polimorfizam je svojstvo da svaki objekat izvedene klase izvršava
 metod tačno onako kako je to definisano u njegovoj izvedenoj klasi, čak
 i kada mu se pristupa preko pokazivača na objekat osnovne klase.
 
\end_layout

\begin_layout Standard
Da bismo bolje razumeli virtuelne funkcije, vratićemo se na primer klase
 
\family typewriter
DvaDOblik
\family default
 u kojoj ćemo definisati funkciju 
\family typewriter
povrsina()
\family default
 kao virtuelnu.
 Ova funkcija biće nadjačana u klasama 
\family typewriter
Trougao
\family default
 i 
\family typewriter
Pravougaonik
\family default
.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class DvaDOblik { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
double sirina;
\end_layout

\begin_layout LyX-Code

\size small
double visina;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
DvaDOblik(double s, double v) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
visina = v;
\end_layout

\begin_layout LyX-Code

\size small
sirina = s;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
double getVisina() const { return visina;} 
\end_layout

\begin_layout LyX-Code

\size small
double getSirina() const { return sirina;} 
\end_layout

\begin_layout LyX-Code

\size small
virtual double povrsina() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << 
\begin_inset Quotes sld
\end_inset

greska! funkcija povrsina mora biti nadjacana!  
\begin_inset Quotes srd
\end_inset

;
\end_layout

\begin_layout LyX-Code

\size small
return 0.0 ;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class Pravougaonik: public DvaDOblik { 
\end_layout

\begin_layout LyX-Code

\size small
public:
\end_layout

\begin_layout LyX-Code
    
\size small
Pravougaonik(double s, double v): DvaDOblik(s, v) { }
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
double povrsina() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return getVisina() * getSirina();
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
 } 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class Trougao: public DvaDOblik { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Trougao(double s, double v): DvaDOblik(s, v) { }
\end_layout

\begin_layout LyX-Code

\size small
double povrsina() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
return getVisina() * getSirina() / 2; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
DvaDOblik dvaDOblik(3, 4);
\end_layout

\begin_layout LyX-Code

\size small
Trougao trougao(3, 4);
\end_layout

\begin_layout LyX-Code

\size small
Pravougaonik pravougaonik(3,4);
\end_layout

\begin_layout LyX-Code

\size small
DvaDOblik *poblik;
\end_layout

\begin_layout LyX-Code

\size small
poblik = &dvaDOblik;
\end_layout

\begin_layout LyX-Code

\size small
cout << poblik->povrsina() << endl;
\end_layout

\begin_layout LyX-Code

\size small
poblik = &trougao;
\end_layout

\begin_layout LyX-Code

\size small
cout << poblik->povrsina() << endl;
\end_layout

\begin_layout LyX-Code

\size small
poblik = &pravougaonik;
\end_layout

\begin_layout LyX-Code

\size small
cout << poblik->povrsina() << endl;
\end_layout

\begin_layout LyX-Code

\size small
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
greska! funkcija povrsina mora biti nadjacana.
 0
\end_layout

\begin_layout Standard

\series bold
\size small
6
\end_layout

\begin_layout Standard

\series bold
\size small
12
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Iako je jednostavan, ovaj primer ilustruje snagu virtuelnih funkcija i polimorfi
zma.
 U funkciji 
\family typewriter
main()
\family default
 deklarisan je pokazivač 
\family typewriter
poblik
\family default
 tipa 
\family typewriter
DvaDOblik
\family default
.
 Ovom pokazivaču su dodeljene adrese objekata tipa 
\family typewriter
Trougao
\family default
 i 
\family typewriter
Pravougaonik
\family default
; to je moguće jer pokazivač na osnovni tip može da pokazuje i na objekte
 izvedenih tipova.
 Međutim, stvarni tip objekta na koji pokazuje pokazivač na osnovnu klasu
 određuje se tokom izvršavanja i u skladu sa tim poziva se odgovarajuća
 verzija funkcije 
\family typewriter
povrsina()
\family default
.
 Interfejs za računanje povrsine za sve 2D objekte tako postaje isti bez
 obzira o kom tipu oblika se radi.
\end_layout

\begin_layout Standard
Drugim rečima, verziju virtuelne funkcije koja će biti pozvana određuje
 stvarni tip objekta na koji pokazuje pokazivač tokom izvršavanja programa,
 a ne osnovni tip tog pokazivača sa kojim je deklarisan.
 Zbog toga se u prethodnom primeru pozivaju tri različite verzije funkcije
 
\family typewriter
povrsina()
\family default
.
\end_layout

\begin_layout Standard
Virtuelna funkcija se može pozvati i bez pokazivača ili reference na objekat
 osnovne klase, standardnom sintaksom tačke.
 To znači da bi u prethodnom primeru bilo sintaksno ispravno napisati: 
\end_layout

\begin_layout Standard

\family typewriter
trougao.povrsina();
\end_layout

\begin_layout Standard
Međutim, polimorfizam se ostvaruje samo kada se virtuelne funkcije pozivaju
 preko pokazivača na osnovnu klasu.
 Efekat poziva virtuelne funkcije direktno, bez pokazivača, isti je kao
 kada se izostavi reč 
\family typewriter
virtual
\family default
 u njenoj deklaraciji i svodi se na prosto nadjačavanje funkcija.
 
\end_layout

\begin_layout Subsection
Statičko i dinamičko povezivanje
\end_layout

\begin_layout Standard
Često se u diskusijama o objektno orijentisanom programiranju mogu čuti
 dva termina koji su u direktnoj vezi sa polimorfizmom: statičko ili rano
 povezivanje, i dinamičko ili kasno povezivanje, pa ćemo se na njih ukratko
 osvrnuti.
\end_layout

\begin_layout Standard

\shape italic
Statičko
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
povezivanje!statičko
\end_layout

\end_inset

 
\shape italic
ili rano povezivanje
\shape default
 (early binding) odnosi se na događaje koji se dešavaju tokom kompajliranja.
 U suštini, rano povezivanje dešava se kada su sve informacije potrebne
 za pozivanje funkcije poznate tokom kompajliranja (odnosno objekat se može
 povezati sa funkcijom tokom kompajliranja).
 Primeri ranog povezivanja su standardni pozivi bibliotečkih funkcija i
 pozivi preklopljenih funkcija.
 Velika prednost ranog povezivanja je efikasnost: pošto su sve informacije
 potrebne za poziv funkcije poznate tokom kompajliranja, pozivi funkcija
 su veoma brzi.
 
\end_layout

\begin_layout Standard

\shape italic
Kasno ili dinamičko
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
povezivanje!dinamičko
\end_layout

\end_inset

 
\shape italic
povezivanje
\shape default
 u jeziku C++ odnosi se na pozive funkcija koji se rešavaju tek tokom izvršavanj
a programa.
 Za kasno povezivanje u jeziku C++ koriste se virtuelne funkcije.
 Kao što znamo, kada se virtuelnim funkcijama pristupa preko pokazivača
 ili reference na osnovnu klasu, verziju virtuelne funkcije koja će biti
 pozvana određuje stvarni tip objekta na koji pokazuje pokazivač.
 Pošto u većini slučajeva stvarni tip objekta na koji pokazuje pokazivač
 na osnovnu klasu nije poznat tokom kompajliranja, objekat se povezuje sa
 funkcijom tek tokom izvršavanja.
 Najvažnija prednost kasnog povezivanja je prilagodljivost; za razliku od
 ranog povezivanja, dinamičko povezivanje omogućuje pisanje programa koji
 reaguju na događaje koji se dešavaju tokom izvršavanja programa bez pisanja
 kôda koji bi se posebno bavio svim mogućim varijantama.
 Ipak, pošto se poziv funkcije razrešava tek tokom izvršavanja, dinamičko
 povezivanje je sporije od statičkog.
\end_layout

\begin_layout Subsection
Čiste virtuelne funkcije i apstraktne klase
\end_layout

\begin_layout Standard
Ponekad je potrebno napraviti osnovnu klasu koja definiše samo opšti oblik
 koji će imati sve izvedene klase, tako da one same definišu detalje.
 Takva klasa određuje prirodu funkcija koje izvedene klase moraju da implementir
aju, ali ne nudi i implementaciju tih funkcija.
 Jedan tipičan slučaj za to je kada osnovna klasa ne može da obezbedi smislenu
 implementaciju neke funkcije, kao u slučaju funkcije 
\family typewriter
povrsina()
\family default
 u klasi 
\family typewriter
DvaDOblik
\family default
.
 Definicija funkcije 
\family typewriter
povrsina()
\family default
 u osnovnoj klasi samo 
\begin_inset Quotes sld
\end_inset

čuva mesto
\begin_inset Quotes srd
\end_inset

 za njene stvarne implementacije u izvedenim klasama.
 Takva situacija se može rešiti tako što verzija funkcije u osnovnoj klasi
 samo prikaže upozoravajuću poruku, što smo i iskoristili u prethodnom primeru.
 Iako je ovakav pristup koristan u nekim situacijama kao što je debagovanje,
 obično nije preporučljiv.
 
\end_layout

\begin_layout Standard
U jeziku C++ moguće je deklarisati funkcije koje moraju da budu nadjačane
 u izvedenim klasama da bi imale smisla.
 Takve funkcije zovu se 
\shape italic
čiste virtuelne
\shape default
 
\shape italic
funkcije
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
virtuelne funkcije!čiste
\end_layout

\end_inset

 (pure virtual functions).
 Funkcija koja je u osnovnoj klasi definisana kao čista virtuelna funkcija
 nema implementaciju u osnovnoj klasi; zbog toga svaka izvedena klasa mora
 da je definiše.
 Čista virtuelna funcija deklariše se sledećom sintaksom: 
\end_layout

\begin_layout Standard

\family typewriter
\shape slanted
\size small
virtual tip ime_funkcije(lista_parametara) = 0;
\shape default
 
\end_layout

\begin_layout Standard
Uz pomoć čiste virtuelne funkcije možemo da poboljšamo klasu 
\family typewriter
DvaDOblik
\family default
 tako što ćemo funkciju 
\family typewriter
povrsina()
\family default
 prepraviti u čistu virtuelnu funkciju.
 Time smo istovremeno primorali sve izvedene klase da nadjačaju ovu funkciju.
\end_layout

\begin_layout LyX-Code

\size small
class DvaDOblik { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
double sirina;
\end_layout

\begin_layout LyX-Code

\size small
double visina;
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
DvaDOblik(double s, double v) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
visina = v;
\end_layout

\begin_layout LyX-Code

\size small
sirina = s;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
double getVisina() const { return visina;} 
\end_layout

\begin_layout LyX-Code

\size small
double getSirina() const { return sirina;} 
\end_layout

\begin_layout LyX-Code

\size small
virtual double povrsina() {} = 0; //cista virtuelna funkcija
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Ako klasa ima barem jednu čistu virtuelnu funkciju, ona se zove 
\shape italic
apstraktna
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!apstraktne
\end_layout

\end_inset

 
\shape italic
klasa
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
apstraktna klasa
\end_layout

\end_inset

.
 Objekti apstraktnih klasa ne mogu da postoje, jer se ne bi znalo šta treba
 da se desi kada se za objekat apstraktne klase pozove čista virtuelna funkcija:
\end_layout

\begin_layout Standard

\family typewriter
\size small
DvaDOblik oblik(3,4); //greska!
\end_layout

\begin_layout Standard

\family typewriter
\size small
oblik.povrsina();//greska!
\end_layout

\begin_layout Standard
Međutim, mogu da postoje pokazivači na objekte apstraktnih klasa, koji se
 koriste za ostvarivanje polimorfizma, odnosno koriste se kao pokazivači
 na objekte izvedenih klasa.
\end_layout

\begin_layout Subsection
Virtuelni destruktori
\end_layout

\begin_layout Standard
Postavlja se pitanje da li konstruktori i destruktori
\begin_inset Index idx
status open

\begin_layout Plain Layout
destruktori!virtuelni
\end_layout

\end_inset

 klase mogu da budu virtuelni.
 Konstruktor je funkcija koja od “obične gomile u memoriji” pravi “živi”
 objekat.
 Poziva se pre nego što je objekat kreiran, pa nema smisla da bude virtuelan,
 što C++ ni ne dozvoljava.
 Kada se objekat kreira, njegov tip je uvek poznat, pa je određen i konstruktor
 koji se poziva.
\end_layout

\begin_layout Standard
Destruktor sa druge strane pretvara postojeći objekat u “hrpu bitova” u
 memoriji.
 Destruktori, za razliku od konstruktora, mogu da budu virtuelni.
 Virtuelni mehanizam, tj.
 dinamičko vezivanje tačno određuje koji destruktor (osnovne ili izvedene
 klase) će biti prvo pozvan kada se objektu pristupa posredno, preko pokazivača.
\end_layout

\begin_layout Standard
Odatle i praktično pravilo: ako osnovna klasa ima neku virtuelnu funkciju,
 onda i njen destruktor treba da bude virtuelan.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class osnovna { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
virtual ~osnovna() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout<< "virtuelni destruktor osnovne" << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
class izvedena: public osnovna { 
\end_layout

\begin_layout LyX-Code

\size small
public: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
virtual ~izvedena() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout <<"virtuelni destruktor izvedene" << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
void oslobodi(osnovna *po) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
delete po; //poziv virtuelnog destruktora 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
osnovna *po = new osnovna; 
\end_layout

\begin_layout LyX-Code

\size small
izvedena *pi = new izvedena; 
\end_layout

\begin_layout LyX-Code

\size small
//pozivi virtuelnih destruktora 
\end_layout

\begin_layout LyX-Code

\size small
oslobodi(po); 
\end_layout

\begin_layout LyX-Code

\size small
oslobodi(pi);
\end_layout

\begin_layout LyX-Code

\size small
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
virtuelni destruktor osnovne
\end_layout

\begin_layout Standard

\series bold
\size small
virtuelni destruktor izvedene
\end_layout

\begin_layout Standard

\series bold
\size small
virtuelni destruktor osnovne
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Section*
Pitanja
\end_layout

\begin_layout Standard
1.
 Članovi klase deklarisani kao _________ dostupni su samo funkcijama članicama
 klase.
\end_layout

\begin_layout Standard
a) 
\family typewriter
public
\end_layout

\begin_layout Standard
b) 
\family typewriter
protected
\end_layout

\begin_layout Standard
c) 
\family typewriter
private
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
2.
 Nasleđivanje je vrsta ponovnog korišćenja softvera u kome nove klase obuhvataju
 svojstva i ponašanje postojećih klasa i obogaćuju ih novim mogućnostima.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
3.
 Nasleđivanjem se olakšava ponovno korišćenje softvera koji se dokazao kao
 kvalitetan.
 
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
4.
 Članovi deklarisani kao __________ u osnovnoj klasi dostupni su u osnovnoj
 i izvedenim klasama.
 
\end_layout

\begin_layout Standard
a) 
\family typewriter
public
\end_layout

\begin_layout Standard
b) 
\family typewriter
protected
\end_layout

\begin_layout Standard
c) 
\family typewriter
private
\family default
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
5.
 Klasa Pticica u deklaraciji 
\family typewriter
class Ljubimac : Pticica
\family default
 je izvedena:
\end_layout

\begin_layout Standard
a) javno
\end_layout

\begin_layout Standard
b) privatno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
6.
 Kada se kreira objekat izvedene klase, poziva se __________ osnovne klase
 koji obavlja sve neophodne inicijalizacije podataka članova osnovne klase
 u objektu izvedene klase.
\end_layout

\begin_layout Standard
a) konstruktor
\end_layout

\begin_layout Standard
b) konstruktor kopije
\end_layout

\begin_layout Standard
c) destruktor 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
7.
 Izvedena klasa ne nasleđuje konstruktore osnovne klase.
 
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
8.
 Konstruktor izvedene klase je dužan da prosledi sve potrebne parametre
 konstruktoru osnovne klase.
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
9.
 Kada se uništava objekat izvedene klase, destruktori se pozivaju u obrnutom
 redosledu od konstruktora.
 
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
10.
 Ako klasa sadrži barem jednu čistu virtuelnu metodu, onda je takva klasa
 apstraktna.
 
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
11.
 Ne mogu da se kreiraju objekti apstraktnih klasa.
 
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
12.
 Sve virtuelne funkcije u apstraktnoj osnovnoj klasi moraju se deklarisati
 kao čiste virtuelne funkcije.
 
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
13.
 Ako je u osnovnoj klasi deklarisana čista virtuelna funkcija, onda izvedena
 klasa mora da implementira tu funkciju da bi bila konkretna klasa.
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
14.
 Pokazivačima na objekat osnovne klase može se dodeljivati adresa objekta
 izvedene klase.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
15.
 Ako osnovna klasa ima neku virtuelnu funkciju, onda i njen destruktor treba
 da bude virtuelan.
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Chapter
Ulazno izlazni (U/I) sistem
\end_layout

\begin_layout Standard
Od početka knjige koristili smo U/I sistem
\begin_inset Index idx
status open

\begin_layout Plain Layout
U/I sistem
\end_layout

\end_inset

 jezika C++, bez mnogo formalnih objašnjenja.
 Pošto je U/I sistem zasnovan na hijerarhiji klasa, nije bilo moguće da
 se objasne njegovi detalji bez prethodnog savladavanja klasa i nasleđivanja.
 Sada je trenutak da se detaljno pozabavimo ulazno-izlaznim sistemom.
 Pošto je on ogroman, nećemo moći da pomenemo sve klase i funkcije, ali
 ćemo se upoznati sa najvažnijim i najčešće korišćenim delovima.
 
\end_layout

\begin_layout Standard
Trenutno postoje dve verzije objektno orijentisane C++ bibliotele za ulaz/izlaz:
 starija se zasniva na originalnim specifikacijama za C++, a noviju definiše
 ANSI/ISO standard jezika.
 Stariju U/I biblioteku podržava zaglavlje 
\family typewriter
<iostream.h>
\family default
, a novu zaglavlje
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja!
\family typewriter
iostream
\end_layout

\end_inset

 
\family typewriter
<iostream>
\family default
.
 U najvećem broju slučajeva ove dve datoteke programeru izgledaju isto,
 zato što je nova U/I biblioteka zapravo ažurirana i poboljšana verzija
 stare.
 U stvari, većina izmena je 
\begin_inset Quotes sld
\end_inset

ispod haube
\begin_inset Quotes srd
\end_inset

, u načinu na koji su biblioteke implementirane, a ne kako se koriste.
 Sa tačke gledišta programera, dve su najvažnije razlike između starih i
 novih U/I biblioteka: prvo, nova sadrži dodatne funkcije i nove tipove
 podataka, što znači da je ona proširenje stare.
 Skoro svi programi pisani za stari U/I kompajliraće se bez izmena i kada
 se koristi nova biblioteka.
 Drugo, stara U/I biblioteka nalazila se u globalnom imeniku, dok je nova
 u imeniku 
\family typewriter
std
\family default
.
 Pošto se stara biblioteka više ne koristi, opisaćemo samo novu U/I biblioteku
 (ali treba znati da većina informacija važi i za staru).
\end_layout

\begin_layout Section
Pojam toka
\end_layout

\begin_layout Standard
Kada je reč o U/I sistemu jezika C++, najvažnije je znati da on radi sa
 tokovima.
 
\shape italic
Tok
\shape default
 (stream) 
\begin_inset Index idx
status open

\begin_layout Plain Layout
tokovi
\end_layout

\end_inset

 je apstrakcija koja proizvodi ili prihvata podatke.
 Tok se sa fizičkim uređajima povezuje preko U/I sistema.
 Svi tokovi se ponašaju na isti način, čak i kada su povezani sa različitim
 fizičkim uređajima.
 Na primer, isti metod koji se koristi za ispis na ekranu može da se koristi
 za ispis datoteke na štampaču.
 U svom najopštijem obliku, tok je logički interfejs za datoteku.
 Pojam datoteke
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke
\end_layout

\end_inset

 u jeziku C++ je veoma širok, pa to može biti datoteka na disku, ekran,
 tastatura, priključak na računaru itd.
 Iako se datoteke razlikuju po mnogim svojstvima, svi tokovi su isti.
 Prednost takvog pristupa je u tome što programeru svi hardverski uređaji
 izgledaju isto.
 
\end_layout

\begin_layout Subsection
Binarni i tekstualni tokovi
\end_layout

\begin_layout Standard
Kada se govori o ulazu i izlazu programa, treba razlikovati dve široke kategorij
e podataka: binarne i tekstualne.
 Binarni podaci se predstavljaju u binarnom obliku na isti način na koji
 se zapisuju unutar računara.
 Binarni podaci su dakle obični nizovi nula i jedinica čija interpretacija
 nije odmah prepoznatljiva.
 Tekstualni podaci se predstavljaju nizovima znakova koji se mogu pročitati,
 odnosno razumljivi su za programera.
 Ali pojedinačni znakovi u tekstualnom podatku se i sami zapisuju u binarnom
 obliku prema raznim šemama kodiranja (npr.
 ASCII ili Unicode).
 Prema tome, svi podaci u računarima su binarni, ali su tekstualni podaci
 samo viši stepen apstrakcije u odnosu na bezličan niz nula i jedinica.
 Za ove dve vrste podataka se primenjuju različiti postupci prilikom pisanja
 i čitanja podataka.
 
\end_layout

\begin_layout Standard
Da bismo bolje razumeli razliku između binarnih i tekstualnih tokova, razmotrimo
 jedan konkretan primer izlaza programa: pretpostavimo da se u programu
 ceo broj 167 tipa 
\family typewriter
int
\family default
 upisuje u datoteku na disku.
 Broj 167 je u programu zapisan unutar jednog bajta u binarnom obliku 10100111
 (ili ekvivalentno 0xA7 u heksadecimalnom zapisu).
 Ukoliko se za pisanje broja 167 koristi binarni tok
\begin_inset Index idx
status open

\begin_layout Plain Layout
tokovi!binarni
\end_layout

\end_inset

, jedan bajt odgovarajuće binarne vrednosti 10100111 (0xA7 heksadecimalno)
 biće upisan neizmenjen u datoteku.
 Međutim, ako se za njegovo pisanje koristi tekstualni tok, onda se broj
 167 upisuje kao niz znakova ’1’, ’6’ i ’7’.
 Pri tom se svaki znak u nizu konvertuje specifičnom kodnom šemom u odgovarajući
 bajt koji se zapravo upisuje u datoteku na disku.
 Ako se, recimo, koristi ASCII šema, onda znaku ’1’ odgovara jedan bajt
 čija ASCII vrednost iznosi 0x31 u heksadecimalnom zapisu (ili 00110001
 u binarnom obliku), znaku ’6’ odgovara bajt 0x36 i znaku ’7’ odgovara bajt
 0x37.
 Prema tome, za broj 167 tipa int u datoteku se redom upisuju tri bajta
 0x31, 0x36 i 0x37.
\end_layout

\begin_layout Standard
Ukoliko se koristi binarni tok, bajtovi se neizmenjeni prenose iz programa
 ili u njega.
 Binarni tokovi su mnogo efikasniji za ulaz ili izlaz programa, jer se kod
 njih ne gubi dodatno vreme potrebno za konverziju bajtova u znakove prilikom
 prenosa.
 To znači i da su podaci upisani korišćenjem binarnog toka prenosivi, jer
 se mogu čitati neizmenjeni na računaru koji je različit od onog na kome
 su upisani.
 Ipak, binarni tokovi se mnogo ređe koriste, praktično samo kada se radi
 o velikim količinama prenosa podataka u specijalnim primenama (na primer,
 kod baza podataka).
 Osnovni nedostatak binarnih tokova je to što su dobijeni binarni podaci
 nečitljivi za ljude, pa je potreban dodatni napor da bi se oni mogli interpreti
rati.
 Zbog toga ćemo se u ovoj knjizi ograničiti na tehnike upisa i čitanja iz
 tekstualnih
\begin_inset Index idx
status open

\begin_layout Plain Layout
tokovi!tekstualni
\end_layout

\end_inset

 tokova.
\end_layout

\begin_layout Subsection
Predefinisani tokovi
\end_layout

\begin_layout Standard
C++ sadrži nekoliko predefinisanih objekata tokova
\begin_inset Index idx
status open

\begin_layout Plain Layout
tokovi!predefinisani objekti
\end_layout

\end_inset

 koji su automatski dostupni kada C++ program počne da se izvršava.
 To su 
\family typewriter
cin
\family default
, 
\family typewriter
cout
\family default
, 
\family typewriter
cerr
\family default
 i 
\family typewriter
clog
\family default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 8.1
\series default
: Predefinisani objekti tokova.
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tok
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Značenje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Standardni uređaj
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
cin
\begin_inset Index idx
status open

\begin_layout Plain Layout
cin
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
standardni ulaz 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tastatura
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\begin_inset Index idx
status open

\begin_layout Plain Layout
cout
\end_layout

\end_inset

cout
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
standardni izlaz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ekran
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\begin_inset Index idx
status open

\begin_layout Plain Layout
cerr
\end_layout

\end_inset

cerr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
standardna greška
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ekran
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\begin_inset Index idx
status open

\begin_layout Plain Layout
clog
\end_layout

\end_inset

clog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
baferovani cerr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ekran
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
cin
\family default
 je objekat toka povezan sa standardnim ulazom, a objekat 
\family typewriter
cout
\family default
 je pridružen standardnom ulazu.
 Tok 
\family typewriter
cerr
\family default
 je povezan sa standardnim izlazom, kao i 
\family typewriter
clog
\family default
.
 Razlika između ova dva objekta je u tome što je 
\family typewriter
clog
\family default
 baferisan, a 
\family typewriter
cerr
\family default
 nije.
 To znači da se sve što se šalje na 
\family typewriter
cerr
\family default
 odmah prikazuje, dok se ono što je poslato u 
\family typewriter
clog
\family default
 prikazuje tek kada je bafer pun.
 Obično su 
\family typewriter
cerr
\family default
 i 
\family typewriter
clog
\family default
 tokovi u koje se prikazuju rezultati debagovanja ili informacije o greškama.
 C++ tokovi su standardno vezani za konzolu, ali ih program ili operativni
 sistem mogu preusmeriti u druge uređaje ili u datoteke.
 
\end_layout

\begin_layout Subsection
Klase tokova
\end_layout

\begin_layout Standard
Već smo pominjali da C++ podržava U/I tokove
\begin_inset Index idx
status open

\begin_layout Plain Layout
tokovi!klase
\end_layout

\end_inset

 u zaglavlju 
\family typewriter
<iostream>
\family default
 u kome se nalazi prilično složena  hijerarhija klasa za U/I operacije.
 U/I sistem zasniva se na dve povezane, ali ipak različite, hijerarhije
 klasa.
 Prva se zasniva na U/I klasi niskog nivoa 
\family typewriter
basic_streambuf
\family default
.
 Ona obezbeđuje osnovne operacije za ulaz i izlaz niskog nivoa, kao i podršku
 za ceo C++ U/I sistem.
 Osim ako se ne budete bavili naprednijim U/I programiranjem, klasu 
\family typewriter
basic_streambuf
\family default
 nećete morati da koristite direktno.
 Hijerarhija klasa sa kojom se najčešće radi izvedena je iz klase 
\family typewriter
basic_ios
\family default
.
 To je U/I klasa visokog nivoa koja obezbeđuje formatiranje, proveru grešaka
 i statusne informacije vezane za U/I tokove.
 Klasa 
\family typewriter
basic_ios
\family default
 se koristi kao osnovna klasa za nekoliko izvedenih klasa, uključujući 
\family typewriter
basic_istream
\family default
, 
\family typewriter
basic_ostream
\family default
 i 
\family typewriter
basic_iostream
\family default
.
 Te klase se koriste za pravljenje ulaznih, izlaznih i ulazno/izlaznih tokova.
\end_layout

\begin_layout Standard
U nastavku je dat spisak U/I klasa:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="60text%">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 8.2
\series default
: U/I klase tokova
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Klasa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
streambuf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Klasa niskog nivoa koja se retko koristi direktno 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ios
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Klasa sa korisnim metodama koje upravljaju ili nadgledaju operacije toka
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
istream
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ulazni tok 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ostream
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Izlazni tok 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
iostream
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ulazno-izlazni tok 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fstream
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tok za datoteke
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ifstream
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ulazni tok za datoteke
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ofstream
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Izlazni tok za datoteke
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Klase u prethodnoj tabeli najčešće ćete koristiti u programima, a njihovi
 nazivi su isti kao u staroj U/I biblioteci.
 Klasa ios sadrži brojne funkcije članice i promenljive koje kontrolišu
 osnovne operacije sa tokovima.
 Prilikom korišćenja pomenutih klasa obavezno je uključiti zaglavlje 
\family typewriter
<iostream>
\family default
 u program.
\end_layout

\begin_layout Section
Formatiranje ulaza i izlaza
\end_layout

\begin_layout Standard
Sve dosad formatiranje ulaznih i izlaznih podataka prepuštali smo standardnim
 podešavanjima jezika C++.
 Međutim, moguće je precizno kontrolisati format podataka i to na dva načina.
 Prvi način koristi funkcije članice klase 
\family typewriter
ios
\family default
, a drugi specijalne manipulatorske funkcije.
 U nastavku ćemo proučiti oba metoda.
\end_layout

\begin_layout Subsection
Formatiranje pomoću funkcija članica klase ios 
\end_layout

\begin_layout Standard
Sa svakim tokom povezan je skup flegova za formatiranje koji upravljaju
 načinom na koji tok formatira
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ios
\end_layout

\end_inset

 podatke.
 Klasa
\begin_inset Index idx
status open

\begin_layout Plain Layout
klase!
\family typewriter
ios
\end_layout

\end_inset

 
\family typewriter
ios
\family default
 ima tzv.
 bit-masku 
\family typewriter
fmtflags
\family default
 koja sadrži flegove za formatiranje.
 Kada je postavljen fleg 
\family typewriter
skipws
\family default
, beline na početku (razmaci, tabulatori i znakovi za nov red) odbacuju
 se kada se unose podaci u tok.
 Kada je 
\family typewriter
skipws
\family default
 resetovan (tj.
 kada mu je vrednost 0), beline se ne preskaču.
 Kada je postavljen fleg 
\family typewriter
left
\family default
, izlaz se poravnava ulevo, a kada je postavljen fleg 
\family typewriter
right
\family default
, izlaz se poravnava udesno.
 Kada je postavljen fleg 
\family typewriter
internal
\family default
, numerička vrednost se odseca tako da popuni polje umetanjem razmaka između
 bilo kog znaka ili osnove.
 Ako nijedan od pomenutih flegova nije postavljen, izlaz se poravnava udesno.
 Numeričke vrednosti se standardno prikazuju u decimalnoj notaciji, ali
 je i to moguće promeniti.
 Postavljanje flega 
\family typewriter
oct
\family default
 prouzrokuje prikaz vrednosti u oktalnom režimu, a postavljanje flega 
\family typewriter
hex
\family default
 ih prikazuje u heksadecimalnoj notaciji.
 Da bi se prikaz vratio u decimalan format, treba postaviti fleg 
\family typewriter
dec
\family default
.
 Postavljanje flega 
\family typewriter
showbase
\family default
 prouzrokuje prikaz osnove brojnih vrednosti.
 Na primer, ako je osnova za konverziju heksadecimalna, vrednost 1F biće
 prikazana kao 0x1F.
 Standardno, kada se koristi eksponencijalna notacija za brojeve, slovo
 
\family typewriter
e
\family default
 je prikazano kao malo, isto kao i slovo 
\family typewriter
x
\family default
 u heksadecimalnoj vrednosti.
 Ako je postavljen fleg 
\family typewriter
uppercase
\family default
, te vrednosti prikazuju se velikim slovima.
 Postavljanje flega 
\family typewriter
showpos
\family default
 prouzrokuje prikaz znaka + ispred pozitivnih vrednosti.
 Postavljanjem flega 
\family typewriter
showpoint
\family default
 prikazuju se decimalna tačka i vodeće nule za sve vrednosti u pokretnom
 zarezu, bez obzira da li su neophodne ili ne.
 Postavljanjem flega 
\family typewriter
scientific
\family default
, brojne vrednosti u pokretnom zarezu prikazuju se u eksponencijalnoj notaciji.
 Kada je postavljen fleg 
\family typewriter
fixed
\family default
, vrednosti u pokretnom zarezu prikazuju se u standardnoj notaciji.
 Kada nije postavljen nijedan fleg, kompajler bira odgovarajući metod.
 Kada je postavljen fleg 
\family typewriter
unitbuf
\family default
, bafer se ne prazni nakon svake operacije umetanja.
 Kada je postavljen fleg 
\family typewriter
boolalpha
\family default
, logičke vrednosti mogu da se unose i ispisuju pomoću ključnih reči 
\family typewriter
true
\family default
 i 
\family typewriter
false
\family default
.
 
\end_layout

\begin_layout Subsubsection
Postavljanje i brisanje flegova za formatiranje
\end_layout

\begin_layout Standard
Da bi se fleg postavio, koristi se funkcija 
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
setf()
\family default
 
\end_layout

\end_inset


\family typewriter
setf()
\family default
 koja je članica klase 
\family typewriter
ios
\family default
.
 Na primer, da bi se postavio fleg
\begin_inset Index idx
status open

\begin_layout Plain Layout
flegovi za formatiranje
\end_layout

\end_inset

 
\family typewriter
showbase
\family default
, koristi se naredba:
\end_layout

\begin_layout Standard

\family typewriter
tok.setf(ios::showbase); 
\end_layout

\begin_layout Standard
Primetite korišćenje kvalifikatora dosega 
\family typewriter
ios::
\family default
 za 
\family typewriter
showbase
\family default
.
 Pošto je 
\family typewriter
showbase
\family default
 nabrojana konstanta u klasi 
\family typewriter
ios
\family default
, ona se mora navesti na taj način, a to važi i za sve ostale flegove za
 formatiranje.
 Sledeći program koristi funkciju 
\family typewriter
setf()
\family default
 za postavljanje flegova 
\family typewriter
showpos
\family default
 i 
\family typewriter
scientific
\family default
:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout.setf(ios::showpoint); 
\end_layout

\begin_layout LyX-Code

\size small
cout.setf(ios::showpos); 
\end_layout

\begin_layout LyX-Code

\size small
cout << 100.0; //prikazuje +100.0 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Proizvoljan broj flegova se može kombinovati u jednoj naredbi.
 Na primer, u prethodnom programu umesto dve naredbe u kojoj se postavljaju
 flegovi, mogla se koristiti samo jedna:
\end_layout

\begin_layout Standard

\family typewriter
cout.setf(ios::scientific | ios::showpos); 
\end_layout

\begin_layout Standard
Za isključivanje flega koristi se funkcija 
\family typewriter
unsetf()
\family default
, čiji je prototip: 
\end_layout

\begin_layout Standard

\family typewriter
void unsetf(fmtflags flags); 
\end_layout

\begin_layout Standard
Ova funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
unsetf()
\end_layout

\end_inset

 briše flegove zadate u argumentu 
\family typewriter
flags
\family default
, a ostale ne menja.
 Ponekad je korisno znati trenutne vrednosti flegova.
 To se može postići pomoću funkcije 
\family typewriter
flags()
\family default
:
\end_layout

\begin_layout Standard

\family typewriter
fmtflags flags();
\family default
 
\end_layout

\begin_layout Standard
Ova funkcija vraća trenutnu vrednost flegova u toku za koji je pozvana.
 Sledeći program ilustruje korišćenje funkcija 
\family typewriter
flags()
\family default
 i 
\family typewriter
unsetf()
\family default
:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream>
\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout.setf(ios::uppercase | ios::scientific); 
\end_layout

\begin_layout LyX-Code

\size small
cout << 100.12; //prikazuje 1.0012E+02 
\end_layout

\begin_layout LyX-Code

\size small
cout.unsetf(ios::uppercase); //brise uppercase 
\end_layout

\begin_layout LyX-Code

\size small
cout << endl << 100.12; //prikazuje 1.0012e+02 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Osim flegova za formatiranje, klasa 
\family typewriter
ios
\family default
 definiše tri funkcije članice kojima se mogu dodatno podesiti širina polja
 za prikaz, preciznost i znak za popunu.
 Funkcije kojima se te vrednosti podešavaju su 
\family typewriter
width()
\begin_inset Index idx
status open

\begin_layout Plain Layout
width()
\end_layout

\end_inset


\family default
, 
\family typewriter
precision()
\begin_inset Index idx
status open

\begin_layout Plain Layout
precision()
\end_layout

\end_inset


\family default
 i 
\family typewriter
fill()
\begin_inset Index idx
status open

\begin_layout Plain Layout
fill()
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Standard
Kada se prikazuje neka vrednost, ona zauzima samo onoliko mesta koliko je
 potrebno za broj znakova potrebnih za prikaz.
 Međutim, može se zadati i minimalna širina polja pomoću funkcije 
\family typewriter
width()
\family default
.
 Prototip te funkcije je: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
streamsize width(streamsize w); 
\end_layout

\begin_layout Standard
Ovde je 
\family typewriter
w
\family default
 širina polja; funkcija kao rezultat vraća prethodnu širinu polja.
 U nekim implementacijama, širina polja mora da bude postavljena pre bilo
 kakvog ispisa, a ako nije postavljena, koristi se standardna širina.
 Tip 
\family typewriter
streamsize
\family default
 definisan je kao vrsta celog broja.
 Kada se postavi minimalna vrednost za širinu polja, a vrednost koja treba
 da se prikaže koristi manju širinu, ona se dopunjava tekućim znakom za
 popunu (što je standardno razmak) do zadate širine polja.
 Ako širina vrednosti za prikaz prevazilazi minimalnu širinu polja, onda
 će vrednost biti prikazana u potrebnoj širini, bez odsecanja.
 Kada se prikazuju vrednosti u pokretnom zarezu u eksponencijalnoj notaciji,
 moguće je zadati broj cifara koje će biti prikazane iza decimalne tačke
 pomoću funkcije 
\family typewriter
precision()
\family default
 čiji je prototip:
\end_layout

\begin_layout Standard

\family typewriter
\size small
streamsize precision(streamsize p);
\end_layout

\begin_layout Standard
Preciznost se postavlja na 
\family typewriter
p
\family default
, a funkcija vraća staru vrednost.
 Podrazumevana vrednost za preciznost je 6.
 U nekim implementacijama preciznost mora da bude postavljena pre bilo kakvog
 ispisa vrednosti u pokretnom zarezu; u suprotnom se koristi podrazumevana
 vrednost za preciznost.
 Ako treba da se dopuni, polje se standardno dopunjava razmacima.
 Postoji i specijalna funkcija 
\family typewriter
fill()
\begin_inset Index idx
status open

\begin_layout Plain Layout
fill()
\end_layout

\end_inset


\family default
 za dopunu znakovima čiji je prototip:
\end_layout

\begin_layout Standard

\family typewriter
\size small
char fill(char ch); 
\end_layout

\begin_layout Standard
Nakon poziva funkcije 
\family typewriter
fill()
\family default
, 
\family typewriter
ch
\family default
 postaje nov znak za popunu, a funkcija vraća stari znak.
 Evo programa koji demonstrira te tri funkcije:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout.precision(4) ; 
\end_layout

\begin_layout LyX-Code

\size small
cout.width(10); 
\end_layout

\begin_layout LyX-Code

\size small
cout << 10.12345 << endl //prikazuje 10.12 
\end_layout

\begin_layout LyX-Code

\size small
cout.fill('*'); 
\end_layout

\begin_layout LyX-Code

\size small
cout.width(10); 
\end_layout

\begin_layout LyX-Code

\size small
cout << 10.12345 << endl; //prikazuje *****10.12 
\end_layout

\begin_layout LyX-Code

\size small
//polje width primenjuje se i na stringove 
\end_layout

\begin_layout LyX-Code

\size small
cout.width(10); 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Hi!" << endl; //prikazuje *******Hi! 
\end_layout

\begin_layout LyX-Code

\size small
cout.width(10); 
\end_layout

\begin_layout LyX-Code

\size small
cout.setf(ios::left); //levo poravnavanje 
\end_layout

\begin_layout LyX-Code

\size small
cout << 10.12345; //prikazuje 10.12***** 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Kao što je pomenuto, u nekim implementacijama neophodno je resetovati polje
 za širinu pre bilo koje operacije izlaza.
 Zbog toga se 
\family typewriter
width()
\family default
 u prethodnom programu više puta poziva (postoje i preklopljene verzije
 funkcija 
\family typewriter
width()
\family default
, 
\family typewriter
precision()
\family default
 i 
\family typewriter
fill()
\family default
 koje čitaju trenutna podešavanja, ali ih ne menjaju.)
\end_layout

\begin_layout Section
Korišćenje U/I manipulatora
\end_layout

\begin_layout Standard
I/O sistem jezika C++ omogućuje formatiranje parametara toka i pomoću specijalni
h funkcija koje se zovu 
\shape italic
manipulatori
\shape default

\begin_inset Index idx
status open

\begin_layout Plain Layout
U/I manipulatori
\end_layout

\end_inset

.
 Da bi se manipulatori sa argumentima koristili u programu, potrebno je
 uključiti zaglavlje
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja!
\family typewriter
iomanip
\end_layout

\end_inset

 
\family typewriter
<iomanip>
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="34" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="30text%">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<row endhead="true">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 8.3
\series default
: U/I manipulatori
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row endhead="true">
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manipulator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Namena
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U/I
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
boolalpha
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg boolalpha
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ulazno/izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
dec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg dec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ulazno/izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
endl
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prelazi u novi red i prazni tok 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ends
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prikazuje null
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fixed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Uključuje fleg fixed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
flush
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prazni tok
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
hex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg za heksadecimalni prikaz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
internal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg internal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
left
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg left
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
noboolalpha
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Isključuje fleg noboolalpha
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ulazno/izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
noshowbase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Isključuje flef noshowbase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
noshowpoint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Isključuje fleg noshowpoint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
noshowpos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Isključuje fleg noshowpos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
noskipws
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Isključuje fleg noskipws
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ulazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
nounitbuf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Isključuje fleg nounitbuf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
nouppercase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Isključuje fleg nouppercase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
oct
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg za oktalni prikaz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ulazno/izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
resetiosflags (fmtflags f)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resetuje flegove navedene u f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ulazno/izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
right
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg right
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
scientific
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Uključuje eksponencijalni prikaz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
set base(int base)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja brojnu osnovu na base 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ulazno/izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
setfill(int ch)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja znak za popunu na ch 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
setiosflags(fmtflags f) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja flegove navedene u f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ulazno/izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
setprecision(int p)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja broj znakova za preciznost 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
setw(int w)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja širinu polja na w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
showbase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg showbase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
showpoint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg showpoint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
showpos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg showpos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
skipws
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg skipws
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ulazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
unitbuf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Postavlja fleg unitbuf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
uppercase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Uključuje fleg uppercase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
izlazni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ws
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Preskače vodeće razmake
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ulazni
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Evo primera koji koristi manipulatore: 
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <iomanip> 
\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << hex << 100 << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << setfill('?') << setw(10) << 2343.0; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
64 ??????2343
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Primetite kako se manipulatori pojavljuju unutar većih U/I izraza.
 Takođe uočite da kada manipulator nema argumenata, kao što je 
\family typewriter
endl()
\family default
 u primeru, iza njega se ne navode zagrade.
 Radi poređenja, evo funkcionalno ekvivalentne verzije prethodnog programa
 koji koristi funkcije članice klase 
\family typewriter
ios
\family default
 za postizanje istih rezultata:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <iomanip> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout.setf(ios::hex, ios::basefield); 
\end_layout

\begin_layout LyX-Code

\size small
cout << 100 << endl; //100 hex 
\end_layout

\begin_layout LyX-Code

\size small
cout.fill('?'); 
\end_layout

\begin_layout LyX-Code

\size small
cout.width(10); 
\end_layout

\begin_layout LyX-Code

\size small
cout << 2343.0; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Kao što se vidi iz primera, najvažnija prednost korišćenja manipulatora
 nad korišćenjem funkcija članica klase 
\family typewriter
ios
\family default
 jeste to što po pravilu generišu kompaktniji kôd.
\end_layout

\begin_layout Standard
Jedan od zanimljivijih manipulatora je 
\family typewriter
boolalpha
\family default
 koji omogućuje ulaz i izlaz logičkih podataka pomoću reči "true" i "false"
 umesto brojeva.
 Na primer,
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
using namespace std; 
\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
bool b; 
\end_layout

\begin_layout LyX-Code

\size small
b = true; 
\end_layout

\begin_layout LyX-Code

\size small
cout << b << " " << boolalpha << b << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Unesite logičku vrednost: "; 
\end_layout

\begin_layout LyX-Code

\size small
cin >> boolalpha >> b; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "Uneli ste: " << b; 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Za razliku od manipulatorskih funkcija koje imaju argumente, manipulatorske
 funkcije bez argumenata se prilično lako programiraju i vrlo su korisne.
 Prototip manipulatorske funkcije je:
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
ostream &ime_manipulatora(ostream &stream) {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\shape slanted
\size small
//telo manipulatora;
\end_layout

\begin_layout LyX-Code

\shape slanted
\size small
return stream;
\end_layout

\end_deeper
\begin_layout LyX-Code

\shape slanted
\size small
}
\end_layout

\begin_layout Standard
Iako je argument manipulatora referenca na tok sa kojim radi, argument se
 ne navodi kada se manipulator poziva za tok (u ovom slučaju, za 
\family typewriter
ostream
\family default
, tj.
 za objekat 
\family typewriter
cout
\family default
).
 U nastavku je dat primer manipulatorske
\begin_inset Index idx
status open

\begin_layout Plain Layout
manipulatori!programiranje
\end_layout

\end_inset

 funkcije nazvane 
\family typewriter
setup
\family default
 koja uključuje poravnavanje ulevo, podešava širinu prikaza na deset mesta
 i zadaje $ kao znak za popunu:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <iomanip>
\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code

\size small
ostream &setup(ostream &stream) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
stream.setf(ios::left); 
\end_layout

\begin_layout LyX-Code

\size small
stream << setw(10) << setfill('$'); 
\end_layout

\begin_layout LyX-Code

\size small
return stream; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << setup << 10 << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\size small
Rezultat izvršavanja:
\end_layout

\begin_layout Standard

\series bold
\size small
10$$$$$$$$$$
\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Section
Rad sa datotekama
\end_layout

\begin_layout Standard
U/I sistem jezika C++ može se koristiti i za rad sa datotekama
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke
\end_layout

\end_inset

.
 Da bi se uključio datotečki U/I, u program se mora uključiti zaglavlje
\begin_inset Index idx
status open

\begin_layout Plain Layout
zaglavlja!
\family typewriter
fstream
\end_layout

\end_inset

 
\family typewriter
<fstream>
\family default
 u kome se nalazi nekoliko važnih klasa i konstanti.
\end_layout

\begin_layout Standard
U jeziku C++ datoteka se otvara tako što se povezuje sa tokom.
 Već znamo da postoje tri vrste tokova: ulazni, izlazni i ulazno/izlazni.
 Da bi se otvorio ulazni tok, on se mora deklarisati tako da bude tipa 
\family typewriter
ifstream
\begin_inset Index idx
status open

\begin_layout Plain Layout
ifstream
\end_layout

\end_inset


\family default
.
 Da bi se otvorio izlazni tok, on se mora deklarisati tako da pripada klasi
 
\family typewriter
ofstream
\begin_inset Index idx
status open

\begin_layout Plain Layout
ofstream
\end_layout

\end_inset


\family default
.
 Slično, tok koji će obavljati i ulazne i izlazne operacije mora se deklarisati
 tako da bude tipa 
\family typewriter
fstream
\begin_inset Index idx
status open

\begin_layout Plain Layout
fstream
\end_layout

\end_inset


\family default
.
 Na primer, sledeće naredbe kreiraju jedan ulazni tok, jedan izlazni tok
 i jedan ulazno-izlazni tok:
\end_layout

\begin_layout Standard

\family typewriter
\size small
ifstream in; //ulazni tok 
\end_layout

\begin_layout Standard

\family typewriter
\size small
ofstream out; //izlazni tok 
\end_layout

\begin_layout Standard

\family typewriter
\size small
fstream io; //ulazno izlazni tok
\end_layout

\begin_layout Standard
Kada se kreira tok, on se sa datotekom može povezati pomoću funkcije 
\family typewriter
open()
\family default
 koja postoji u sve tri klase tokova.
 Prototipovi funkcija 
\family typewriter
open()
\family default
 su:
\end_layout

\begin_layout Standard

\family typewriter
\size small
void ifstream::open(const char *filename, ios::openmode mode = ios::in);
 
\end_layout

\begin_layout Standard

\family typewriter
\size small
void ofstream::open(const char *filename, ios::openmode mode = ios::out
 | ios::trunc); 
\end_layout

\begin_layout Standard

\family typewriter
\size small
void fstream::open(const char *filename, ios::openmode mode = ios::in |
 ios::out);
\end_layout

\begin_layout Standard
Ovde je 
\family typewriter
filename
\family default
 ime datoteke.
 Ono može sadržati i relativni ili apsolutnu putanju do datoteke, ali to
 nije obavezno.
 Korišćenje relativne putanje se preporučuje jer se program može koristiti
 pod različitim platformama:
\end_layout

\begin_layout Standard

\family typewriter
\size small
ofstream outfile;
\end_layout

\begin_layout Standard

\family typewriter
\size small
//otvara datoteku u istom direktorijumu gde i program
\end_layout

\begin_layout Standard

\family typewriter
\size small
outfile.open("studenti.dat
\begin_inset Quotes srd
\end_inset

);
\end_layout

\begin_layout Standard

\family typewriter
\size small
//apsolutna putanja
\end_layout

\begin_layout Standard

\family typewriter
\size small
outfile.open("C:
\backslash

\backslash
fakultet
\backslash

\backslash
casovi
\backslash

\backslash
studenti.dat
\begin_inset Quotes srd
\end_inset

);
\end_layout

\begin_layout Standard
Vrednost parametra 
\family typewriter
mode
\family default
 određuje način na koji će datoteka biti otvorena.
 Parametar režima (
\family typewriter
mode
\family default
) može imati jednu od sledećih vrednosti, definisanih u klasi 
\family typewriter
ios
\family default
:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="25text%">
<column alignment="left" valignment="top" width="60text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tabela 8.4
\series default
: Režimi rada sa datotekama
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!režimi rada
\end_layout

\end_inset

.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parametar mode
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Značenje
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ios::app
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sadržaj se dodaje na kraj postojeće datoteke.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ios::ate
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ako datoteka već postoji, program se pomera direktno na njen kraj.
 
\end_layout

\begin_layout Plain Layout
Može se upisivati bilo gde u datoteku (ovaj režim se obično koristi sa binarnim
 datotekama)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ios::binary
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sadržaj se upisuje u datoteku u binarnom obliku, 
\end_layout

\begin_layout Plain Layout
a ne u tekstualnom (koji je podrazumevani)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ios::in
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sadržaj se čita iz datoteke.
 Ako datoteka ne postoji, neće biti napravljena.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ios::out
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sadržaj se upisuje u datoteku, a ako ona već ima sadržaj, prepisuje se.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ios::trunc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ako datoteka već postoji, njen sadržaj će biti prepisan (podrazumevani režim
 za ios::out)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Nekoliko vrednosti za parametar 
\family typewriter
mode
\family default
 mogu se kombinovati korišćenjem operatora |.
 Parametar 
\family typewriter
ios::app
\family default
 prozrokuje dodavanje sadržaja na kraj datoteke i može se koristiti samo
 za izlazne datoteke (tj.
 tokove tipa 
\family typewriter
ofstream
\family default
).
 Parametar 
\family typewriter
ios::ate
\family default
 prouzrokuje traženje kraja datoteke prilikom njenog otvaranja (iako se
 U/I operacije mogu dešavati bilo gde u datoteci).
 Vrednost 
\family typewriter
ios::in
\family default
 zadaje da se u datoteku može upisivati, a 
\family typewriter
ios::out
\family default
 da se iz nje može čitati.
 Vrednost 
\family typewriter
ios::binary
\family default
 prouzrokuje otvaranje datoteke u binarnom režimu.
 Standardno se sve datoteke otvaraju u tekstualnom režimu.
 Svaka datoteka, bez obzira da li sadrži formatiran tekst ili binarne podatke,
 može da se otvori u binarnom ili u tekstualnom režimu; jedina razlika je
 da li će se dešavati konverzija znakova.
\end_layout

\begin_layout Standard
Vrednost 
\family typewriter
ios::trunc
\family default
 prouzrokuje uništavanje sadržaja postojeće datoteke istog imena, tj.
 svođenje datoteke na nultu dužinu.
 Kada se izlazni tok kreira kao objekat klase 
\family typewriter
ofstream
\family default
, sve postojeće datoteke istog imena automatski se odsecaju.
 Sledeći deo kôda otvara tekstualnu datoteku za čitanje:
\end_layout

\begin_layout Standard

\family typewriter
\size small
ofstream tok; 
\end_layout

\begin_layout Standard

\family typewriter
\size small
tok.open("test"); 
\end_layout

\begin_layout Standard
Pošto je standardna vrednost parametra mode funkcije
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
open()
\end_layout

\end_inset

 
\family typewriter
open()
\family default
 ona koja je odgovarajuća za tip toka koji se otvara, često nije ni potrebno
 zadavati njegovu vrednost, kao u prethodnom primeru.
 (Neki kompajleri ne dodeljuju standardne vrednosti parametra mode za funkciju
 
\family typewriter
fstream::open()
\family default
, tj.
 in | out, pa one moraju eksplicitno da se navedu.) Ako otvaranje datoteke
 ne uspe, vrednost toka biće 
\family typewriter
false
\family default
 kada se koristi u logičkim izrazima, što se može iskoristiti za proveru
 da li je datoteka uspešno otvorena u naredbi kao što je ova:
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
if(!tok) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Datoteka ne moze da se otvori" << endl; //obrada greske 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout Standard
Rezultat funkcije 
\family typewriter
open()
\family default
 trebalo bi proveriti pre bilo kog pokušaja menjanja datoteke.
 Za proveru da li je datoteka uspešno otvorena može se upotrebiti i funkcija
 
\family typewriter
is_open()
\family default
, koja je članica klasa 
\family typewriter
fstream
\family default
, 
\family typewriter
ifstream
\family default
 i 
\family typewriter
ofstream
\family default
.
 Prototip te funkcije je: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
bool is_open();
\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
is_open()
\family default
 vraća true ako je tok povezan sa otvorenom datotekom, a false u suprotnom.
 Na primer, sledeće naredbe proveravaju da li je datoteka 
\family typewriter
tok
\family default
 trenutno otvorena: 
\end_layout

\begin_layout LyX-Code

\size small
if(!tok.is_open()) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Datoteka je otvorena" << endl; 
\end_layout

\end_deeper
\begin_layout Standard
Iako je sasvim u redu da se funkcija 
\family typewriter
open()
\family default
 koristi za otvaranje datoteke, to se uglavnom ne radi zato što klase 
\family typewriter
ifstream
\family default
, 
\family typewriter
ofstream
\family default
 i 
\family typewriter
fstream
\family default
 imaju konstruktore koji automatski otvaraju datoteke.
 Konstruktori imaju iste parametre i standardne vrednosti kao funkcija 
\family typewriter
open()
\family default
.
 Zbog toga se datoteka najčešće otvara kao u sledećem primeru: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
ifstream tok("mojaDatoteka"); //otvaranje datoteke za upis
\size default
 
\end_layout

\begin_layout Standard
Ako iz nekog razloga datoteka ne može da se otvori, promenljiva toka imaće
 vrednost false.
 
\end_layout

\begin_layout Standard
Za zatvaranje datoteke koristi se funkcija članica 
\family typewriter
close()
\family default
.
 Na primer, da bi se zatvorila datoteka povezana sa tokom 
\family typewriter
mojTok
\family default
, koristi se sledeća naredba:
\end_layout

\begin_layout Standard

\family typewriter
\size small
tok.close(); 
\end_layout

\begin_layout Standard
Funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
close()
\end_layout

\end_inset

 
\family typewriter
close()
\family default
 nema parametara i ne vraća nikakvu vrednost.
\end_layout

\begin_layout Subsection
Čitanje i upis u tekstualne datoteke
\end_layout

\begin_layout Standard
Čitanje i upis u tekstualne datoteke
\begin_inset Index idx
status open

\begin_layout Plain Layout
datoteke!čitanje i upis
\end_layout

\end_inset

 je vrlo jednostavno: treba samo upotrebiti operatore << i >> na isti način
 kao što smo ih dosada koristili za ispis i učitavanje podataka sa konzole.
 Jedina razlika je u tome što umesto objekata 
\family typewriter
cin
\family default
 i 
\family typewriter
cout
\family default
 treba upotrebiti tok koji je povezan sa datotekom.
 Na primer, sledeća datoteka pravi kratak inventar sa nazivom i cenom svake
 stavke: 
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <fstream> 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
ofstream out("INVENTAR"); //izlazna datoteka
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
if(!out) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cout << "Datoteka za inventar ne moza da se otvori" << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 1; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
out << "Plejeri " << 39.95 << endl; 
\end_layout

\begin_layout LyX-Code

\size small
out << "Tosteri " << 19.95 << endl; 
\end_layout

\begin_layout LyX-Code

\size small
out << "Mikseri " << 24.80 << endl;
\end_layout

\begin_layout LyX-Code

\size small
out << "Pegle   " << 44.90 << endl;
\end_layout

\begin_layout LyX-Code

\size small
out.close(); 
\end_layout

\begin_layout LyX-Code

\size small
return 0; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Kada čitamo podatke iz datoteke, ona mora već da postoji.
 Prilikom čitanja treba proveravati da li se stiglo do kraja datoteke (EOF,
 end of file).
 Funkcija članica 
\family typewriter
eof()
\family default
 klase 
\family typewriter
ifstream
\family default
 vraća 
\family typewriter
true
\family default
 kada se stigne do kraja datoteke.
 Za čitanje podataka možemo koristiti operator >> (nasleđen iz klase 
\family typewriter
istream
\family default
) koji prekida čitanje kada naiđe na belinu (razmak, tabulator i sl.), ili
 funkciju 
\family typewriter
getline()
\family default
 koja učitava sadržaj iz datoteke red po red.
 
\end_layout

\begin_layout Standard
Funkcija 
\family typewriter
getline()
\family default
 je članica svih klasa ulaznih tokova, a njeni prototipovi su: 
\end_layout

\begin_layout Standard

\family typewriter
\size small
istream &getline(char *buf, streamsize num); 
\end_layout

\begin_layout Standard

\family typewriter
\size small
istream &getline(char *buf, streamsize num, char delim);
\size default
 
\end_layout

\begin_layout Standard
Prva verzija učitava znake u niz na koji pokazuje buf sve dok se ne učita
 num–1 znakova, dok ne naiđe znak za novi red ili kraj datotreke (EOF, end
 of file).
 Funkcija 
\family typewriter
getline()
\family default
 će automatski dodati nulu na kraj učitanog niza koji se smešta u buf.
 Ako se u ulaznom toku naiđe na znak za nov red, on se ne stavlja u buf.
 Druga verzija funkcije 
\family typewriter
getline()
\family default
 učitava znakove u niz 
\family typewriter
buf
\family default
 dok ne učita num–1 znakova, ne pronađe znak koji je zadat kao delim ili
 naiđe na kraj datoteke.
 Funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
getline()
\end_layout

\end_inset

 
\family typewriter
getline()
\family default
 će automatski dodati nulu na kraj učitanog niza koji se smešta u buf.
 Ako se znak za razdvajanje (
\family typewriter
delim
\family default
) pronađe u ulaznom toku, on se ne stavlja u 
\family typewriter
buf
\family default
.
 
\end_layout

\begin_layout Standard
Kada se upisuje u datoteku, podaci se ne upisuju odmah u fizički uređaj
 povezan sa tokom, već se informacije čuvaju u internom baferu dok se on
 ne napuni.
 Tek tada se sadržaj bafera upisuje na disk.
 Međutim, fizičko upisivanje podataka na disk se može aktivirati i pre nego
 što je bafer pun pozivanjem funkcije 
\family typewriter
flush()
\family default
 čiji je prototip:
\end_layout

\begin_layout Standard

\family typewriter
\size small
ostream &flush(); 
\end_layout

\begin_layout Standard
Funkcija
\begin_inset Index idx
status open

\begin_layout Plain Layout
funkcije!
\family typewriter
flush()
\end_layout

\end_inset

 
\family typewriter
flush()
\family default
 posebno je korisna kada se program koristi u "nesigurnim
\begin_inset Quotes srd
\end_inset

 oruženjima (npr.
 u sistemima gde često nestaje struje i sl.)
\end_layout

\begin_layout Standard
U nastavku je dat primer programa koji otvara istu datoteku za upis i čitanje:
\end_layout

\begin_layout LyX-Code

\size small
#include <iostream> 
\end_layout

\begin_layout LyX-Code

\size small
#include <fstream>
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
using namespace std;
\end_layout

\begin_layout LyX-Code
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code

\size small
int main() { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
char bafer[200]; 
\end_layout

\begin_layout LyX-Code

\size small
cout << "unesite ime i adresu: "; 
\end_layout

\begin_layout LyX-Code

\size small
cin.getline(bafer, 200); 
\end_layout

\begin_layout LyX-Code

\size small
cout << endl; 
\end_layout

\begin_layout LyX-Code

\size small
ofstream outfile("ime.txt", ios::app); 
\end_layout

\begin_layout LyX-Code

\size small
if(!outfile) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
cerr << endl; 
\end_layout

\begin_layout LyX-Code

\size small
cerr << "greska! datoteka ne moze da se otvori " <<
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
"u rezimu dodavanja!"; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
cerr << endl; 
\end_layout

\begin_layout LyX-Code

\size small
return 1; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}; 
\end_layout

\begin_layout LyX-Code

\size small
outfile << bafer << endl; 
\end_layout

\begin_layout LyX-Code

\size small
outfile.close(); 
\end_layout

\begin_layout LyX-Code

\size small
ifstream infile("ime.txt"); 
\end_layout

\begin_layout LyX-Code

\size small
while(!infile.eof()) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
infile.getline(bafer, 200); 
\end_layout

\begin_layout LyX-Code

\size small
cout << bafer << endl; 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
} 
\end_layout

\begin_layout LyX-Code

\size small
infile.close(); 
\end_layout

\begin_layout LyX-Code

\size small
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section*
Pitanja
\end_layout

\begin_layout Standard
1.
 Većini C++ datoteka koji obavljaju U/I operacije potrebno je zaglavlje
 _______ koje sadrži deklaracije potrebne za sve operacije sa U/I tokovima.
 
\end_layout

\begin_layout Standard
a) 
\family typewriter
iostream
\end_layout

\begin_layout Standard
b) 
\family typewriter
fstream
\family default
 
\end_layout

\begin_layout Standard
c) 
\family typewriter
string
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
2.
 Zaglavlje __________ sadrži deklaracije potrebne za rad sa datotekama.
 
\end_layout

\begin_layout Standard
a) 
\family typewriter
fstream
\end_layout

\begin_layout Standard
b) 
\family typewriter
iostream
\family default
 
\end_layout

\begin_layout Standard
c) 
\family typewriter
string
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
3.
 Simbol za umetanje u tok je 
\end_layout

\begin_layout Standard
a) << 
\end_layout

\begin_layout Standard
b) >>
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
4.
 Funkcija članica tokova 
\family typewriter
fstream
\family default
, 
\family typewriter
ifstream
\family default
 i 
\family typewriter
ofstream
\family default
 koja zatvara datoteku je: 
\end_layout

\begin_layout Standard
a) 
\family typewriter
fclose
\end_layout

\begin_layout Standard
b) 
\family typewriter
close
\family default
 
\end_layout

\begin_layout Standard
c) 
\family typewriter
ioclose
\family default
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
5.
 Programer mora eksplicitno da kreira objekte 
\family typewriter
cin
\family default
, 
\family typewriter
cout
\family default
, 
\family typewriter
cerr
\family default
 i 
\family typewriter
clog
\family default
.
 
\end_layout

\begin_layout Standard
a) tačno
\end_layout

\begin_layout Standard
b) pogrešno
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
6.
 Program mora eksplicitno da pozove funkciju 
\family typewriter
close
\family default
 da bi zatvorio datoteku povezanu sa objektima toka 
\family typewriter
ifstream
\family default
, 
\family typewriter
ofstream
\family default
 ili 
\family typewriter
fstream
\family default
.
 
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
7.
 Objekti toka 
\family typewriter
ifstream
\family default
 podrazumevano prave datoteku ako ona prilikom otvaranja ne postoji.
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
8.
 Iste tehnike formatiranja izlaza koje se koriste sa objektom 
\family typewriter
cout
\family default
 mogu se koristiti i sa objektima tokova za datoteke.
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
9.
 Operator >> se može koristiti za upis u datoteku.
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
10.
 Kada se stigne do kraja datoteke, funkcija članica 
\family typewriter
eof()
\family default
 vraća:
\end_layout

\begin_layout Standard
a) true
\end_layout

\begin_layout Standard
b) false
\end_layout

\begin_layout Standard
c) 0
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
11.
 Moguće je otvoriti datoteku i za upis i za čitanje.
\end_layout

\begin_layout Standard
a) tačno 
\end_layout

\begin_layout Standard
b) pogrešno 
\end_layout

\begin_layout Chapter*
Dodatak A: ASCII kôdovi znakova
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="17">
<features rotate="true" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
hex
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
9
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
A
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
B
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
C
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
E
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
F
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
NUL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
SOH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
STX
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
ETX
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
EOT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
ENQ
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
ACK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
BEL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
BS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
HT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
LF
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
VT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
FF
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
CR
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
SO
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
SI
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
DLE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
DC1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
DC2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
DC3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
DC4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
NAK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
SYN
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
ETB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
CAN
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
EM
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
SUB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
ESC
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
FS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
GS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
RS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
US
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
!
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
#
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
$
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
%
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
&
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
'
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
(
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
+
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
,
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
-
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
/
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
9
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
<
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
=
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
>
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
@
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
A
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
B
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
C
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
E
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
F
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
G
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
H
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
I
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
J
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
K
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
L
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
M
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
N
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
O
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
P
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
Q
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
R
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
S
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
T
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
U
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
V
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
W
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
X
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
Y
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
Z
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
[
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
^
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
_
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
'
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
a
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
b
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
c
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
d
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
e
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
f
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
g
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
h
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
i
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
j
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
k
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
l
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
m
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
n
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
o
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
p
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
q
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
r
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
s
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
t
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
u
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
v
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
w
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
y
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
z
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
{
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
}
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size footnotesize
~
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
DEL
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Chapter*
Dodatak B: Preprocesorske direktive
\end_layout

\begin_layout Standard
Preprocesor je deo prevodioca (kompajlera) koji radi sa izvornim kôdom (tekstom)
 pre nego što se on prevede u objektni kôd.
 Preprocesoru se navode komande za rad sa tekstom koje se zovu 
\shape italic
preprocesorske direktive
\shape default
.
 Iako one tehnički nisu deo jezika C++, proširuju njegovu sintaksu.
 Preprocesor je nasleđen iz jezika C i u jeziku C++ nije toliko važan kao
 u jeziku C; takođe, neke funkcije preprocesora u jeziku C++ zamenjene su
 boljim elementima jezika.
 Ipak, pošto se često sreću u C++ kôdu, najvažnije direktive biće ukratko
 opisane u nastavku.
 
\end_layout

\begin_layout Standard
Sve preprocesorske direktive počinju znakom #.
 C++ preprocesor sadrži sledeće direktive:
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#define
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#error
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#include
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#if
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#else
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#elif
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#endif
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#ifdef
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#ifndef
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#undef
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#line
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
#pragma
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
Direktiva #define 
\end_layout

\begin_layout Standard
Direktiva
\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorske direktive!
\family typewriter
define
\end_layout

\end_inset

 
\family typewriter
#define
\family default
 koristi se za definisanje identifikatora i niza znakova koji će biti zamenjeni
 tim identifikatorom kad god se on pronađe u datoteci sa izvornim kôdom.
 Opšti oblik direktive je 
\end_layout

\begin_layout Standard

\family typewriter
#define ime_makroa niz_znakova
\end_layout

\begin_layout Standard
Između identifikatora i početka niza znakova može da bude proizvoljan broj
 praznina, ali kada niz znakova počne, završava se tek prelaskom u sledeći
 red.
 Na primer, ako želimo da koristimo reč “GORE” za vrednost 1 i reč “DOLE”
 za vrednost 0, to bi deklarisali ovako: 
\end_layout

\begin_layout Standard

\family typewriter
#define GORE 1 
\end_layout

\begin_layout Standard

\family typewriter
#define DOLE 0 
\end_layout

\begin_layout Standard
Ove naredbe naterale bi kompajler da reči 
\family typewriter
GORE
\family default
 i 
\family typewriter
DOLE
\family default
 zameni sa 1 ili 0 kad god ih pronađe u datoteci.
 
\end_layout

\begin_layout Standard
Ako je niz znakova duži od jednog reda, može se nastaviti tako što će se
 na kraj reda staviti obrnuta kosa crta, kao u sledećem primeru: 
\end_layout

\begin_layout Standard

\family typewriter
#define DUGACAK_STRING "ovo je veoma dugacak 
\backslash
 
\end_layout

\begin_layout Standard

\family typewriter
string koji sluzi kao primer" 
\end_layout

\begin_layout Standard
C++ programeri često koriste sva velika slova za nazive makroa, jer to olakšava
 prepoznavanje mesta na kojima će nastupiti zamena.
 Takođe, preporučljivo je sve direktive 
\family typewriter
#define
\family default
 staviti na početak datoteke, ili u posebno zaglavlje, radi bolje preglednosti.
 Treba znati da C++ umesto korišćenja ove direktive nudi bolji način za
 definisanje konstanti, a to je ključna reč 
\family typewriter
const
\family default
.
 Međutim, pošto su mnogi C++ programeri prešli sa jezika C, u kome za tu
 namenu služi direktiva 
\family typewriter
#define
\family default
, ona se često sreće i u C++ kôdu.
\end_layout

\begin_layout Subsection*
Makroi funkcija 
\end_layout

\begin_layout Standard
Ime makroa u direktivi 
\family typewriter
#define
\family default
 može i da ima argumente.
 U tom slučaju, kad god preprocesor naiđe na ime makroa, zamenjuje njegove
 argumente stvarnim argumentima iz programa.
 Tipičan primer je makro za traženje manjeg od dva argumenta: 
\end_layout

\begin_layout Standard

\family typewriter
#define MIN(a,b) (a < b ? a : b)
\end_layout

\begin_layout Standard
Makroi funkcija koriste se za definisanje funkcija čiji se kôd razvija na
 licu mesta, umesto da se pozivaju.
 Naizgled nepotrebne zagrade oko makroa 
\family typewriter
MIN
\family default
 neophodne su da bi se obezbedilo pravilno tumačenje izraza koji se zamenjuje
 zbog prioriteta operatora.
 Iako se još uvek često sreću u C++ kdu, makroi funkcija su potpuno nepotrebni
 jer za istu namenu služi specifikator 
\family typewriter
inline
\family default
, koji je bolji i bezbedniji za korišćenje jer ne zahteva dodatne zagrade.
 
\end_layout

\begin_layout Subsection*
Direktiva #error 
\end_layout

\begin_layout Standard
Kada naiđe na direktivu
\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorske direktive!
\family typewriter
error
\end_layout

\end_inset

 
\family typewriter
#error
\family default
, kompajler prekida prevođenje.
 Ova direktiva se koristi prvenstveno za debagovanje, a opšti oblik joj
 je
\end_layout

\begin_layout Standard

\family typewriter
#error error_message
\end_layout

\begin_layout Standard
Uočite da se poruka o greški (error-message) ne piše između navodnika.
 Kada kompajler naiđe na ovu direktivu, prikazuje poruku 
\family typewriter
error_message
\family default
 i prekida prevođenje.
 
\end_layout

\begin_layout Subsection*
Direktiva #include 
\end_layout

\begin_layout Standard
Preprocesorska direktiva
\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorske direktive!
\family typewriter
include
\end_layout

\end_inset

 
\family typewriter
#include
\family default
 kompajleru nalaže da uključi standardno zaglavlje ili neku drugu datoteku
 sa izvornim kôdom u datoteku u kojoj je navedena direktiva 
\family typewriter
#include
\family default
.
 Naziv standardnog zaglavlja treba da se nalazi između znakova < > (npr.
 
\family typewriter
#include <fstream>
\family default
 uključuje standardno zaglavlje za rad sa datotekama).
 Ako se uključuje neka druga datoteka, njeno ime navodi se između navodnika
 (npr.
 
\family typewriter
#include "sample.h"
\family default
).
 Kada se uključuje datoteka, način na koji se navodi (između znakova < >
 ili pod navodnicima) određuje mesto gde će se tražiti datoteka.
 Ako je naziv datoteke naveden između znakova < >, kompajler će je tražiti
 u nekoliko predefinisanih direktorijuma.
 Ako je naziv naveden pod navodnicima, ona se obično traži u tekućem radnom
 direktorijumu (a ako se tamo ne pronađe, onda se traži kao da je navedena
 pod znacima < >).
 
\end_layout

\begin_layout Subsection*
Direktive za uslovno prevođenje 
\end_layout

\begin_layout Standard
Postoji nekoliko direktiva koje omogućuju selektivno kompajliranje delova
 izvornog kôda.
 Ovakav pristup, koji se zove uslovno prevođenje (conditional compilation),
 često se koristi u softverskim kućama koje održavaju veliki broj prilagođenih
 verzija istog programa.
\end_layout

\begin_layout Subsubsection*
Direktive #if, #else, #elif, and #endif 
\end_layout

\begin_layout Standard
Ako konstantan izraz iza direktive 
\family typewriter
#if
\family default
 ima vrednost 
\family typewriter
true
\family default
, kôd koji se nalazi između ove i direktive 
\family typewriter
#endif
\family default
 će se kompajlirati; u suprotnom, kompajler će ga preskočiti.
 Direktiva 
\family typewriter
#endif
\family default
 koristi se za označavanje kraja 
\family typewriter
#if
\family default
 bloka.
 Opšti oblik direktive
\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorske direktive!
\family typewriter
if
\end_layout

\end_inset

 
\family typewriter
#if
\family default
 je 
\end_layout

\begin_layout Standard

\family typewriter
#if konstantan_izraz niz naredbi #endif
\end_layout

\begin_layout Subsubsection*
Direktive #ifdef and #ifndef 
\end_layout

\begin_layout Standard
Drugi metod za uslovno prevođenje su direktive
\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorske direktive!
\family typewriter
ifndef
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorske direktive!
\family typewriter
ifdef
\end_layout

\end_inset

 
\family typewriter
#ifdef
\family default
 i 
\family typewriter
#ifndef
\family default
, koje znače “ako je definisano” i “ako nije definisano,” redom, a odnose
 se na imena makroa.
 Opšti oblik direktive 
\family typewriter
#ifdef
\family default
 je
\end_layout

\begin_layout Standard

\family typewriter
#ifdef ime_makroa niz naredbi #endif 
\end_layout

\begin_layout Standard
Ako je ime makroa prethodno definisano pomoću direktive 
\family typewriter
#define
\family default
, niz naredbi između 
\family typewriter
#ifdef
\family default
 i 
\family typewriter
#endif
\family default
 će se kompajlirati.
 Opšti oblik direktive
\family typewriter
 #ifndef
\family default
 je
\end_layout

\begin_layout Standard

\family typewriter
#ifndef ime_makroa niz naredbi #endif
\end_layout

\begin_layout Standard
Ako ime makroa trenutno nije definisano pomoću direktive
\family typewriter
 #define
\family default
, blok kôda će se kompajlirati.
 
\end_layout

\begin_layout Standard
Za utvrđivanje da li je ime makroa definisano osim direktive 
\family typewriter
#ifdef
\family default
 postoji još jedan način.
 Direktiva 
\family typewriter
#if
\family default
 može se koristiti zajedno sa operatorom.
 Na primer, da bi se odredilo da li je definisan makro 
\family typewriter
MOJADATOTEKA
\family default
, može se upotrebiti bilo koja od sledeće dve preprocesorske direktive:
\end_layout

\begin_layout Standard

\family typewriter
#if defined MOJADATOTEKA
\end_layout

\begin_layout Standard

\family typewriter
#ifdef MOJADATOTEKA
\family default
 
\end_layout

\begin_layout Standard
Direktiva za uslovno prevođenje 
\family typewriter
#ifndef 
\family default
često se koristi za izbegavanje višestrukog uključivanja zaglavlja u program
 (tzv.
 include guard).
 Ta tehnika će biti objašnjena na sledećem primeru:
\end_layout

\begin_layout LyX-Code

\family typewriter
#ifndef PRIMER_H
\end_layout

\begin_layout LyX-Code

\family typewriter
#define PRIMER_H
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
//sadrzaj datoteke zaglavlja primer.h
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
#endif
\end_layout

\begin_layout Standard
Kada se prvi put naiđe na direktivu 
\family typewriter
#include
\family default
 
\family typewriter
primer.h
\family default
, definisaće se konstanta 
\family typewriter
PRIMER_H
\family default
.
 Kada se sledeći put naiđe na direktivu 
\family typewriter
#include
\family default
 
\family typewriter
primer.h
\family default
, preskočiće se ceo sadržaj zaglavlja jer je konstanta 
\family typewriter
PRIMER_H
\family default
 već definisana.
 Tako se obezbeđuje da se zaglavlje u program uključi samo jednom.
\end_layout

\begin_layout Subsubsection*
#undef 
\end_layout

\begin_layout Standard
Direktiva
\begin_inset Index idx
status open

\begin_layout Plain Layout
preprocesorske direktive!
\family typewriter
undef
\end_layout

\end_inset


\family typewriter
 #undef
\family default
 koristi se za uklanjanje definicije imena makroa koji je prethodno definisan
 u direktivi 
\family typewriter
#define
\family default
.
 Opšti oblik ove direktive je
\end_layout

\begin_layout Standard

\family typewriter
#undef ime_makroa
\family default
 
\end_layout

\begin_layout Standard
Na primer: 
\end_layout

\begin_layout Standard

\family typewriter
#define TIMEOUT 100 
\end_layout

\begin_layout Standard

\family typewriter
#define WAIT 0 // ...
 
\end_layout

\begin_layout Standard

\family typewriter
#undef TIMEOUT 
\end_layout

\begin_layout Standard

\family typewriter
#undef WAIT
\family default
 
\end_layout

\begin_layout Standard
U ovom slučaju i 
\family typewriter
TIMEOUT
\family default
 i 
\family typewriter
WAIT
\family default
 su definisani dok se ne naiđe na direktive 
\family typewriter
#undef
\family default
.
 Najvažnija primena direktive 
\family typewriter
#undef
\family default
 jeste za lokalizovanje makroa samo na delove kôda kojima su oni potrebni.
\end_layout

\begin_layout Chapter*
Dodatak C: Prevođenje programa sa više datoteka
\end_layout

\begin_layout Standard
Mnogi programi koje smo dosad pisali nalazili su se u jednoj datoteci.
 Međutim, kako programi postaju veći, postaje neophodno da se oni podele
 u više datoteka.
 U opštem slučaju, program sa više datoteka sastoji se od dva tipa datoteka:
 jednih koje sadrže definicije funkcija, i drugih koje sadrže prototipove
 (deklaracije) funkcija.
 Obično se prilikom deljenja programa u datoteke primenjuje sledeća strategija:
\end_layout

\begin_layout Itemize
Sve specijalizovane funkcije koje izvršavaju slične zadatke grupišu se u
 istu datoteku.
 Na primer, pravi se datoteka koja sadrži funkcije za matematičke operacije,
 datoteka koja sadrži funkcije za unos i ispis podataka i sl.
\end_layout

\begin_layout Itemize
Funkcija 
\family typewriter
main()
\family default
 i sve druge funkcije koje imaju veoma važnu ulogu u programu grupišu se
 u jednu datoteku.
\end_layout

\begin_layout Itemize
Za svaku datoteku sa definicijama funkcija (.cpp) pravi se posebna datoteka
 zaglavlje (.h) u kojoj se nalaze prototipovi svih funkcija.
\end_layout

\begin_layout Standard
Svaka datoteka čije se ime završava sa .cpp sadrži definicije funkcija.
 Svaka .cpp datoteka ima odgovarajuću datoteku zaglavlje koja se završava
 sa .h.
 Zaglavlje sadrži prototipove svih funkcija koje se nalaze u odgovarajućoj
 .cpp datoteci.
 Svaka .cpp datoteka ima direktivu 
\family typewriter
#include
\family default
 kojom čita sopstveno zaglavlje ( odgovarajuću .h datoteku).
 Ako .cpp datoteka poziva funkcije iz neke druge .cpp datoteke, onda će imati
 direktivu 
\family typewriter
#include
\family default
 za čitanje zaglavlja tih funkcija.
\end_layout

\begin_layout Standard
Sve .cpp datoteke kompajliraju se u zasebne objektne datoteke, koje se zatim
 povezuju u jednu izvršnu datoteku.
 Taj postupak se u IDE okruženjima obavlja automatski unutar projekta (može
 se postići i pomoću uslužnog programa make i odgovarajućih datoteka Makefile).
 
\end_layout

\begin_layout Standard
Doseg (scope) globalnih promenljivih je isključivo datoteka u kojoj su definisan
e.
 Da bi globalna promenljiva definisana u datoteci A bila dostupna u datoteci
 B, datoteka B mora da sadrži deklaraciju te promenljive ispred koje se
 nalazi ključna reč 
\family typewriter
extern
\begin_inset Index idx
status open

\begin_layout Plain Layout
extern
\end_layout

\end_inset


\family default
.
 Deklaracija 
\family typewriter
extern
\family default
 ne definiše drugu promenljivu, već proširuje doseg postojeće globalne promenlji
ve.
 
\end_layout

\begin_layout Standard
Ako je globalna promenljiva definisana kao statička, ona nikako ne može
 da bude vidljiva izvan datoteke u kojoj je definisana.
 Ključna reč 
\family typewriter
static
\family default
 u ovom slučaju se koristi da bi globalna promenljiva bila privatna za datoteku
 u kojoj je definisana.
\end_layout

\begin_layout Standard
Deklaracije klasa i definicije funkcija članica obično se čuvaju u zasebnim
 datotekama.
 Obično se to radi na sledeći način:
\end_layout

\begin_layout Itemize
Deklaracija klase smešta se u posebno zaglavlje, koje se zove specifikacija
 klase.
 Ime tog zaglavlja obično je isto kao ime klase, sa nastavkom .h.
\end_layout

\begin_layout Itemize
Definicije funkcija članica klase čuvaju se u posebnoj .cpp datoteci, koja
 se zove implementaciona datoteka.
 Ime te datoteke obično je isto kao ime klase, sa nastavkom .cpp.
\end_layout

\begin_layout Itemize
Svai program koji koristi klasu treba da ima direktivu 
\family typewriter
#include
\family default
 za specifikaciju klase.
 Datoteka .cpp sa implementacijom klase trebalo bi da se kompajlira i povezuje
 sa programom 
\family typewriter
main
\family default
, što se u IDE okruženjima obavlja automatski.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter*
Dodatak D: Poređenje jezika C++ i Java
\end_layout

\begin_layout Standard
Ovaj dodatak namenjen je čitaocima koji već poznaju programski jezik Java,
 a prelaze na C++.
 Bez obzira da li je C++ prvi programski jezik koji savladavate ili ne,
 sasvim je izvesno da neće biti i poslednji.
 Jezici C++ i Java trenutno su dva objektno orijentisana jezika koja se
 najčešće koriste, a pošto je Java nastala po ugledu na C++, mnoge osobine
 su im slične.
 U nastavku će biti prikazane samo razlike između ova dva jezika; pošto
 su na primer, naredbe za kontrolu toka programa (
\family typewriter
if
\family default
, 
\family typewriter
while
\family default
, 
\family typewriter
for
\family default
) u suštini identične u oba jezika, o njima neće biti reči.
 
\end_layout

\begin_layout Subsubsection*
Java je potpuno objektno orijentisan jezik
\end_layout

\begin_layout Standard
To znači da se sve operacije odvijaju isključivo preko objekata, odnosno
 preko metoda koji se na njih primenjuju.
 Zbog toga je programer prisiljen da od početka razmišlja na objektno orijentisa
n način.
 S druge strane, jezik C++ omogućuje i pisanje proceduralnog kôda, zbog
 kompatibilnosti sa jezikom C.
 On je projektovan tako da ne bude potpuno nov jezik, već tako da podrži
 kôd u jeziku C koji je osamdesetih godina bio dominantan.
 Java je potpuno nov jezik, neopterećen nasleđem, pa je mnogo toga u Javi
 elegantnije rešeno.
\end_layout

\begin_layout Subsubsection*
Javin kôd se izvodi na virtuelnoj mašini
\end_layout

\begin_layout Standard
Java kôd se ne prevodi u izvorni kôd mašine na kojoj se izvršava, kao C++
 kôd, već u tzv.
 Java bajtkod koji Javina virtuelna mašina interpretira i izvršava.
 Prednost ovog pristupa je to što se bajtkod može izvršavati na bilo kom
 sistemu na kome je instalirana virtuelna mašina.
 Nedostatak je sporost u poređenju sa C++ kôdom koji se prevodi (kompajlira)
 i izvršava direktno u procesoru.
\end_layout

\begin_layout Subsubsection*
Tipovi podataka i promenljivih
\end_layout

\begin_layout Standard
Tipovi podataka u jezicima C++ i Java su slični.
 Kao i Java, C++ ima tipove 
\family typewriter
int
\family default
 i 
\family typewriter
double
\family default
.
 Međutim, opseg numeričkih tipova kao što je 
\family typewriter
int
\family default
 zavisi od računara.
 Dok Java propisuje da integer zauzima tačno 32 bita, u zavisnosti od mašine
 na kojoj je implementiran, ceo broj u jeziku C++ može da zauzima 16, 20,
 32, čak i 64 bita.
 
\end_layout

\begin_layout Standard
C++ ima i tipove 
\family typewriter
short
\family default
 i 
\family typewriter
unsigned
\family default
 koji omogućuju efikasnije čuvanje brojeva, ali ih je bolje izbegavati osim
 u slučajevima kada je prednost koju nude od kritične važnosti.
 
\end_layout

\begin_layout Standard
Logički tip (
\family typewriter
Boolean
\family default
 ili 
\family typewriter
boolean
\family default
 u Javi), u jeziku C++ se zove 
\family typewriter
bool
\family default
.
\end_layout

\begin_layout Standard
Tip znakovnog niza (string) u jeziku C++ se zove 
\family typewriter
string
\family default
 i dosta liči na Javin tip 
\family typewriter
String
\family default
.
 Ipak, treba imati u vidu sledeće razlike:
\end_layout

\begin_layout Standard
1.
 C++ stringovi čuvaju 8-bitne ASCII, a ne 16-bitne Unicode znakove (kao
 u Javi)
\end_layout

\begin_layout Standard
2.
 C++ stringovi se mogu menjati, dok su Javini objekti klase 
\family typewriter
String
\family default
 nepromenljivi.
\end_layout

\begin_layout Standard
3.
 Mnoge metode Javine klase 
\family typewriter
String
\family default
 postoje i u klasi 
\family typewriter
string
\family default
 jezika C++, ali su im nazivi različiti.
\end_layout

\begin_layout Standard
4.
 Stringovi u jeziku C++ mogu se nadovezivati isključivo na druge stringove,
 a ne na objekte proizvoljnog tipa kao u Javi.
\end_layout

\begin_layout Standard
5.
 Za poređenje string
\begin_inset Index idx
status open

\begin_layout Plain Layout
string
\end_layout

\end_inset

ova u jeziku C++ koriste se relacioni operatori == != < <= > >= koji obavljaju
 leksičko poređenje.
 To je u suštini prirodnije od korišćenja metoda 
\family typewriter
equals
\family default
 i 
\family typewriter
compareTo
\family default
 u Javi.
\end_layout

\begin_layout Subsubsection*
Promenljive i konstante
\end_layout

\begin_layout Standard
C++ prevodilac ne proverava da li su sve lokalne promenljive inicijalizovane
 pre nego što se prvi put upotrebe, kao što je slučaj u Javi.
 Prilično je lako zaboraviti na inicijalizaciju promenljive u jeziku C++,
 a njena vrednost je u tom slučaju slučajan sadržaj memorijske lokacije
 koja joj je dodeljena.
 Očigledno je da je to pogodno tle za generisanje grešaka u programiranju.
\end_layout

\begin_layout Standard
Kao i u Javi, i u jeziku C++ klase mogu da sadrže podatke članove i statičke
 promenljive.
 Osim toga, promenljive mogu da budu deklarisane i izvan metoda i klasa.
 Takozvanim globalnim promenljivama može se pristupati iz bilo koje funkcije
 (metoda) u programu, što otežava upravljanje programima i zbog toga bi
 ih valjalo izbegavati.
 
\end_layout

\begin_layout Standard
U jeziku C++ konstante se mogu deklarisati na bilo kom mestu, za razliku
 od Jave gde konstante moraju da budu statički podaci članovi klase.
 C++ koristi ključnu reč 
\family typewriter
const
\family default
 umesto Javine ključne reči 
\family typewriter
final
\family default
.
\end_layout

\begin_layout Subsubsection*
Klase
\end_layout

\begin_layout Standard
Definicija klase u jeziku C++ donekle se razlikuje od one u Javi.
 
\end_layout

\begin_layout Standard
1.
 U jeziku C++, razdvojeni su javni i privatni delovi klase, označeni ključnim
 rečima 
\family typewriter
public
\family default
 i 
\family typewriter
private
\family default
.
 U Javi, svaka pojedinačna stavka mora da bude označena kao 
\family typewriter
public 
\family default
ili
\family typewriter
 private
\family default
.
\end_layout

\begin_layout Standard
2.
 Definicija klase u jeziku C++ sadrži samo deklaracije metoda, a stvarne
 implementacije (tj.
 definicije metoda) pišu se izvan deklaracije klase.
\end_layout

\begin_layout Standard
3.
 Inspektorske metode (koje ne menjaju podatke članove, tj.
 argumente funkcija) označavaju se ključnom reči 
\family typewriter
const
\end_layout

\begin_layout Standard
4.
 Na kraju deklaracije klase u jeziku C++ piše se tačka-zarez.
\end_layout

\begin_layout Standard
5.
 Implementacija metoda piše se nakon deklaracije klase.
 Pošto se metode definišu izvan klasa, ispred naziva svakog metoda navodi
 se ime klase.
 Operator razrešavanja dosega :: razdvaja ime klase i ime metoda.
 
\end_layout

\begin_layout Subsubsection*
Objekti
\end_layout

\begin_layout Standard
Najvažnija razlika između jezika Java i C++ je u ponašanju objektnih promenljivi
h.
 U jeziku C++ objektne promenljive sadrže vrednosti, a ne reference na objekte.
 Operator 
\family typewriter
new
\family default
 nikada se ne koristi za konstruisanje objekata u jeziku C++, već se argumenti
 konstruktora navode nakon imena promenljive.
 Ako se ne navedu parametri konstruktora, objekat se kreira pozivom podrazumevan
og konstruktora.
\end_layout

\begin_layout Standard
To je veoma važna razlika u odnosu na Javu.
 Ako je 
\family typewriter
Tacka
\family default
 korisnički definisana klasa, onda bi naredba:
\end_layout

\begin_layout Standard

\family typewriter
\size small
Tacka t;
\end_layout

\begin_layout Standard
u Javi napravila samo neinicijalizovanu referencu, dok u jeziku C++ konstruiše
 stvarni objekat.
\end_layout

\begin_layout Standard
Kada se jedan objekat dodeljuje drugome, u jeziku C++ pravi se kopija njegovih
 stvarnih vrednosti, dok se u Javi kopiranjem objekta pravi samo još jedna
 referenca na isti objekat.
 Kopiranje u jeziku C++ zapravo je ono što se postiže pozivom metode 
\family typewriter
clone
\family default
 u Javi: menjanje kopije ne utiče na original.
 U većini slučajeva, činjenica da se objekti ponašaju kao vrednosti je pogodna,
 ali postoje i situacije kada ovakvo ponašanje nije poželjno.
 
\end_layout

\begin_layout Standard
1.
 Kada se menja objekat u funkciji, programer mora da se seti da koristi
 poziv preko reference.
\end_layout

\begin_layout Standard
2.
 Dve objektne promenljive ne mogu zajednički da pristupaju istom objektu;
 ako je potrebno postići takav efekat u jeziku C++ , moraju da se koriste
 pokazivači.
\end_layout

\begin_layout Standard
3.
 Objektna promenljiva može da sadrži samo objekte određenog tipa; ako treba
 da sadrži i objekte tipa izvedenih klasa, moraju da se upotrebe pokazivači
\end_layout

\begin_layout Standard
4.
 Ako neka promenljiva treba da pokazuje na 
\family typewriter
null
\family default
 ili na stvarni objekat, u jeziku C++ moraju da se koriste pokazivači.
\end_layout

\begin_layout Subsubsection*
Funkcije
\end_layout

\begin_layout Standard
U Javi, svaka funkcija mora da bude ili funkcija članica (metod) klase,
 ili statička funkcija klase.
 C++ podržava oba pomenuta tipa metoda, ali dozvoljava i funkcije koje nisu
 sastavni deo nijedne klase.
 Takve funkcije zovu se globalne funkcije.
\end_layout

\begin_layout Standard
Izvršavanje svake C++ funkcije počinje iz globalne funkcije 
\family typewriter
main()
\family default
.
 Povratni tip funkcije 
\family typewriter
main()
\family default
 u jeziku C++ je 
\family typewriter
int
\family default
 (0 ako je program uspešno izvršen, neki drugi ceo broj ako nije).
\end_layout

\begin_layout Standard
U Javi, funkcije mogu da promene vrednost objekata koji im se prenose kao
 stvarni argumenti prilikom poziva.
 U jeziku C++ postoje dve vrste prenosa argumenata u funkcije: po vrednosti
 i po referenci.
 Kod prenosa po vrednosti (call-by-value), pravi se kopija stvarnih argumenata
 koji su korišćeni kao stvarni argumenti prilikom poziva funkcije, što znači
 da funkcija nikako ne može da promeni stvarni argument.
 Drugi mehanizam prenosa je poziv po referenci (call-by-reference); u tom
 slučaju funkcija može da promeni vrednost svog stvarnog argumenta.
 Poziv po referenci u jeziku C++ označava se navođenjem znaka & iza tipa
 argumenta.
\end_layout

\begin_layout LyX-Code

\size small
void povecajPlatu(Zaposleni& e, double zaKoliko){ 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
...
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Java ne podržava preklapanje operatora.
\end_layout

\begin_layout Subsubsection*
Pokazivači i upravljanje memorijom
\end_layout

\begin_layout Standard
Već smo napomenuli da u jeziku C++ objektne promenljive sadrže vrednosti
 objekata, za razliku od Jave u kojoj objektne promenljive sadrže referencu
 na objekat.
 Postoje situacije kada je tako nešto potrebno i u jeziku C++, i za to služe
 pokazivači.
 Promenljiva koja pokazuje na neki objekat (odnosno sadrži adresu tog objekta
 u memoriji) u jeziku C++ zove se pokazivač.
 Ako je 
\family typewriter
T
\family default
 neki tip (prosti ili klasni), onda je 
\family typewriter
T*
\family default
 tip pokazivača na objekat tipa 
\family typewriter
T
\family default
.
\end_layout

\begin_layout Standard
Slično kao u Javi, pokazivačka promenljiva može se inicijalizovati vrednošću
 
\family typewriter
NULL
\family default
, drugim pokazivačem ili pozivom operatora 
\family typewriter
new
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
\size small
Zaposleni* p = NULL;
\end_layout

\begin_layout Standard

\family typewriter
\size small
Zaposleni* q = new Zaposleni("Petar, Petrovic", 35000);
\end_layout

\begin_layout Standard

\family typewriter
\size small
Zaposleni* r = q;
\end_layout

\begin_layout Standard
Četvrta mogućnost jeste da se pokazivač inicijalizuje adresom drugog objekta,
 korišćenjem operatora &.
\end_layout

\begin_layout Standard

\family typewriter
\size small
Zaposleni sef("Nikola, Vukovic", 83000);
\end_layout

\begin_layout Standard

\family typewriter
\size small
Zaposleni* s = &sef;
\end_layout

\begin_layout Standard
To obično nije preporučljivo.
 Zlatno pravilo koga se treba držati jeste da C++ pokazivači treba da pokazuju
 isključivo na objekte alocirane pomoću operatora 
\family typewriter
new
\family default
.
\end_layout

\begin_layout Standard
Dosad, C++ pokazivači veoma liče na Javine objektne promenljive.
 Postoji međutim jedna velika razlika u sintaksi: da bi se pristupilo objektu
 na koji pokazuje pokazivač, u jeziku C++ mora se upotrebiti operator *.
 Ako je 
\family typewriter
p
\family default
 pokazivač na objekat 
\family typewriter
Zaposleni
\family default
, onda 
\family typewriter
*p
\family default
 pokazuje na taj objekat.
\end_layout

\begin_layout LyX-Code

\size small
Zaposleni* p = .
 .
 .;
\end_layout

\begin_layout LyX-Code

\size small
Zaposleni sef = *p;
\end_layout

\begin_layout Standard
Sintaksa *p mora da se koristi i kada se izvršava metod ili se pristupa
 podatku članu.
\end_layout

\begin_layout Standard

\family typewriter
(*p).zadajPlatu(91000);
\end_layout

\begin_layout Standard
Zagrade su neophodne zato što je operator .
 većeg prioriteta od operatora *.
 Da je to ružno, primetili su i projektanti jezika C, pa su uveli alternativni
 operator -> koji služi za kombinovanje operatora * i ., pa tako izraz:
\end_layout

\begin_layout Standard

\family typewriter
\size small
p->zadajPlatu(91000);
\end_layout

\begin_layout Standard
poziva metod 
\family typewriter
zadajPlatu
\family default
 za objekat 
\family typewriter
*p
\family default
.
 
\end_layout

\begin_layout Standard
Ako se pokazivač u jeziku C++ ne inicijalizuje, ima vrednost 
\family typewriter
NULL
\family default
 ili pokazuje na neki objekat koji više ne postoji, primena operatora *
 ili -> prouzrokuje grešku.
 Tokom izvršavanja C++ programa takve greške se ne proveravaju, pa se dešava
 da program 
\begin_inset Quotes eld
\end_inset

umire u mukama
\begin_inset Quotes erd
\end_inset

 ili ne radi kako bi trebalo.
\end_layout

\begin_layout Standard
U Javi takve greške nisu moguće, jer ne može da postoji referenca koja nije
 inicijalizovana.
 Objekti se održavaju 
\begin_inset Quotes eld
\end_inset

u životu
\begin_inset Quotes erd
\end_inset

 dogod postoji referenca na njih, što znači da ne može da postoji referenca
 na obrisani objekat.
 Tokom izvršavanja Java programa proverava se da li postoje 
\family typewriter
null
\family default
 reference i baca se izuzetak ako se to otkrije.
\end_layout

\begin_layout Standard
U Javu je ugrađen "sakupljač smeća
\begin_inset Quotes erd
\end_inset

 (engl.
 
\shape italic
garbage collector
\shape default
) koji automatski iz memorije uklanja sve objekte koji više nisu potrebni.
 U jeziku C++, programer je odgovoran za upravljanje memorijom.
\end_layout

\begin_layout Standard
Objektne promenljive u jeziku C++ automatski nestaju kada prestane njihova
 oblast važnosti, ali objekti napravljeni pomoću operatora 
\family typewriter
new
\begin_inset Index idx
status open

\begin_layout Plain Layout
new
\end_layout

\end_inset


\family default
 moraju se ručno ukloniti pozivom operatora 
\family typewriter
delete
\begin_inset Index idx
status open

\begin_layout Plain Layout
delete
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout LyX-Code

\size small
Zaposleni* p = new Zaposleni("Petar, Petrovic", 38000);
\end_layout

\begin_layout LyX-Code

\size small
...
\end_layout

\begin_layout LyX-Code

\size small
delete p; /* ovaj objekat vise nije potreban*/
\end_layout

\begin_layout Standard
Ako se objekat napravljen pomoću operatora 
\family typewriter
new
\family default
 ne ukloni pomoću operatora 
\family typewriter
delete
\family default
, može se desiti da se 
\begin_inset Quotes eld
\end_inset

potroši
\begin_inset Quotes erd
\end_inset

 sva memorija koja je na raspolaganju programu.
 Takvi problemi zovu se 
\begin_inset Quotes eld
\end_inset

curenje memorije
\begin_inset Quotes erd
\end_inset

 (memory leak).
 Što je još važnije, ako se neki objekat ukloni, a zatim nastavi da se koristi,
 može se desiti da se promene podaci koji više ne pripadaju programu.
 Ako se prepišu memorijske lokacije koje su bile korišćene za dinamičko
 alociranje, mehanizmi za alokaciju mogu da se kompromituju i da prouzrokuju
 greške koje se veoma teško pronalaze i ispravljaju.
 Zbog toga treba biti vrlo oprezan pri radu sa pokazivačima u jeziku C++.
\end_layout

\begin_layout Subsubsection*
Nasleđivanje
\end_layout

\begin_layout Standard
U jeziku C++, za označavanje nasleđivanja koristi se sintaksa 
\family typewriter
: public
\family default
 umesto ključne reči 
\family typewriter
extends
\family default
.
 (C++ podržava i koncept privatnog nasleđivanja, ali on nije preterano koristan
 jer se isti efekat može postići i kompozicijom.) Funkcije u jeziku C++ nisu
 podrazumevano sa dinamičkim vezivanjem; ako to želite, funkciju morate
 da označite kao virtuelnu (navođenjem ključne reči 
\family typewriter
virtual
\family default
).
\end_layout

\begin_layout LyX-Code

\size small
class Direktor : public Zaposleni {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
private:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
string odeljenje;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
public:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Direktor(string ime, double plata, string odeljenje);
\end_layout

\begin_layout LyX-Code

\size small
virtual void print() const;
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
};
\end_layout

\begin_layout Standard
Kao i u Javi, u jeziku C++ postoji posebna sintaksa za poziv konstruktora
 roditeljske klase.
 U Javi se koristi ključna reč 
\family typewriter
super
\family default
, a u jeziku C++ konstruktor roditeljske klase mora se pozvati izvan tela
 konstruktora klase-naslednice, kao u sledećem primeru.
\end_layout

\begin_layout LyX-Code

\size small
Direktor::Direktor(string ime, double plata, string od): 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Zaposleni(ime, plata){ 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
odeljenje = od;
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Java ključnu reč 
\family typewriter
super
\family default
 koristi i kada se iz metoda klase-naslednice poziva metod roditeljske klase.
 U jeziku C++, umesto toga se koriste ime roditeljske klase i operator ::
\end_layout

\begin_layout LyX-Code

\size small
void Direktor::print() const { 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
Zaposleni::print();
\end_layout

\begin_layout LyX-Code

\size small
cout << odeljenje << "
\backslash
n";
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
U jeziku C++ objektna promenljiva sadrži objekte određenog tipa (a ne reference
 na njih); da bi se iskoristio polimorfizam, u jeziku C++ su neophodni pokazivač
i.
 Pokazivač tipa 
\family typewriter
T*
\family default
 može da pokazuje na objekte tipa 
\family typewriter
T
\family default
, ali i na objekte tipa bilo koje klase izvedene iz 
\family typewriter
T
\family default
.
\end_layout

\begin_layout Standard
U Javi ne postoji ključna reč 
\family typewriter
virtual
\family default
, već su sve metode klase implicitno virtuelne (mogu se nadjačavati).
\end_layout

\begin_layout Standard
U jeziku C++ ne postoji pojam interfejsa (
\family typewriter
interface
\family default
) iz Jave; umesto njega, koristi se apstraktna klasa u kojoj su sve metode
 čiste virtuelne, a koja nema podataka članova.
\end_layout

\begin_layout Standard
I konačno, u jeziku C++ ne postoji korenska klasa (klasa 
\family typewriter
Object
\family default
 u Javi), ali je omogućeno višestruko nasleđivanje.
\end_layout

\begin_layout Chapter*
Dodatak E: Okruženje Microsoft Visual C++ 2010 Express
\end_layout

\begin_layout Standard
Ovaj dodatak služi kao kratko uputstvo za izvođenje sledećih operacija u
 integrisanom razvojnom okruženju (IDE) Microsoft Visual C++ 2010 Express
 koje se može besplatno preuzeti sa Interneta:
\end_layout

\begin_layout Enumerate
Pravljenje novog projekta i unošenje kôda
\end_layout

\begin_layout Enumerate
Snimanje projekta na disk
\end_layout

\begin_layout Enumerate
Kompajliranje i izvršavanje projekta
\end_layout

\begin_layout Enumerate
Otvaranje postojećeg projekta
\end_layout

\begin_layout Standard
Uputstvo se odnosi na pravljenje konzolnih programa koji su korišćeni za
 većinu primera u ovoj knjizi.
\end_layout

\begin_layout Standard
Prvi korak u pravljenju programa u okruženju Visual C++ jeste kreiranje
 projekta.
 Projekat (project) je skup datoteka koje čine program (aplikaciju).
 Čak i ako program ima samo jednu datoteku, ona mora da pripada projektu.
\end_layout

\begin_layout Standard
Da biste kreirali projekat:
\end_layout

\begin_layout Standard
\align left
1.
 Pokrenite Microsoft Visual C++ (iz menija 
\shape slanted
Start > All Programs
\shape default
).
 Otvoriće se sledeći prozor:
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/VC1.png
	scale 30

\end_inset


\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align block
2.
 Izaberite 
\shape slanted
File
\shape default
 u liniji menija, a zatim 
\shape slanted
New > Project
\shape default
 (ili pritisnite opciju 
\shape slanted
New Project
\shape default
 na naslovnoj strani).
 Pojaviće se sledeći dijalog:
\end_layout

\begin_layout Standard
\align block
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/VC2.png
	scale 35

\end_inset


\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
Pošto su svi programi u ovoj knjizi konzolni, u listi tipova projekata sa
 leve strane izaberite izaberite 
\shape slanted
Win32
\shape default
, a zatim sa desne strane 
\shape slanted
Win32 Console Application
\shape default
.
 Zatim unesite naziv projekta u polje 
\shape slanted
Name
\shape default
 (u ovom slučaju, PrimerProjekta).
 U polju Location pojaviće se naziv direktorijuma gde će projekat biti smešten.
 Standardna lokacija gde se smeštaju projekti može se promeniti pritiskom
 na dugme 
\shape slanted
Browse
\shape default
.
\end_layout

\begin_layout Standard
3.
 Kada pritisnete dugme 
\shape slanted
OK
\shape default
, pojaviće se dijalog za izbor podešavanja aplikacije; izaberite opciju
 
\shape slanted
ApplicationSettings
\shape default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/VC3.png
	scale 35

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
4.
 U dijalogu 
\shape slanted
Application Settings
\shape default
 izaberite opciju 
\shape slanted
Empty Project
\shape default
, kao na slici; kada pritisnete 
\shape slanted
Finish
\shape default
, vratićete se u glavni prozor okruženja koji će biti prazan.
 Ako nije prikazan prozor 
\shape slanted
Solution Explorer
\shape default
, prikažite ga pritiskom na ikonu 
\begin_inset Graphics
	filename Slike/VC5.png
	scale 70

\end_inset

 u gornjem desnom uglu ekrana.
\end_layout

\begin_layout Standard
5.
 Sada treba napraviti novu datoteku sa izvornim kôdom u projektu.
 U prozoru 
\shape slanted
Solution Explorer
\shape default
 desnim tasterom miša pritisnite poslednju kategoriju (Source Files) i izaberite
 
\shape slanted
Add > New Item ...

\shape default
 Pojaviće se sledeći dijalog:
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/VC6.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
U panou sa leve strane izaberite
\shape slanted
 Code
\shape default
, a sa desne strane 
\shape slanted
C++ file (.cpp)
\shape default
.
 U polje 
\shape slanted
Name
\shape default
 upišite ime .cpp datoteke (u ovom slučaju, Primer).
 Nije potrebno da kucate nastavak imena (.cpp), već samo naziv.
 Kada pritisnete dugme 
\shape slanted
Add
\shape default
, vratićete se u glavni prozor okruženja.
 Ako želite da napravite datoteku zaglavlje (header), u ovom dijalogu na
 sličan način treba izabrati opciju 
\shape slanted
Header file (.h)
\shape default
.
\end_layout

\begin_layout Standard
6.
 Sa desne strane sada je prikazan editor u kome možete da unosite izvorni
 kôd.
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Slike/VC7.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
7.
 Datoteku sa kôdom koji ste uneli najlakše ćete snimiti na disk pomoću prečice
 Ctrl+S (ili izborom opcije 
\shape slanted
File > Save Primer.cpp
\shape default
 iz menija).
 Kada snimite datoteku, nestaće zvezdica pored njenog naziva u naslovnoj
 liniji.
\end_layout

\begin_layout Standard
8.
 Kada završite sa unosom kôda, možete da ga kompajlirate i izvršite sledećim
 metodama:
\end_layout

\begin_layout Itemize
pritiskanjem ikone 
\shape slanted
Debug
\shape default
 
\begin_inset Graphics
	filename Slike/VC8.png
	scale 60

\end_inset


\end_layout

\begin_layout Itemize
pritiskanjem tastera Ctrl+F5
\end_layout

\begin_layout Standard
Prozor na dnu ekrana prikazivaće poruke o statusu tokom kompajliranja programa,
 kao i poruke o greškama.
 
\end_layout

\begin_layout Standard
9.
 Ako u projektu imate više datoteka, a ne želite sve uvek da ih kompajlirate,
 možete da kompajlirate pojedinačne datoteke koje su trenutno aktivne pomoću
 prečice Ctrl+F7.
\end_layout

\begin_layout Standard
10.
 U meniju File pronaći ćete i opcije za otvaranje postojećih projekata (
\shape slanted
File > Open Project/Solution
\shape default
 ili 
\shape slanted
File > Recent Projects and Solutions
\shape default
).
\end_layout

\begin_layout Chapter*
Odgovori na pitanja
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="48" columns="9">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Glava 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Glava 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Glava 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Glava 4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Glava 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Glava 6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Glava 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Glava 8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a, d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b, c, e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a, b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a, d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a, c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a, d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a, b, d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b, d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
34
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a, c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a, c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
39
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
42
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a, c, e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
43
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
44
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
46
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"

\end_inset

Cay Horstmann and Timothy Budd.
 
\shape italic
Big C++
\shape default
.
 John Wiley and Sons, 2005.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-7"

\end_inset

Ivor Horton.
 
\shape italic
Beginning C++.

\shape default
 John Wiley and Sons, 2006.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-8"

\end_inset

Herbert Shildt.
 
\shape italic
C++ The Complete Reference
\shape default
.
 McGraw Hill, 3rd Edition, 2003.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-9"

\end_inset

Herbert Shildt.
 
\shape italic
The art of C++
\shape default
.
 McGraw-Hill, 2004.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-10"

\end_inset

John Moluzzo.
 
\shape italic
C++ for Business Programming
\shape default
.
 2nd Edition, Prentice Hall, 2005.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-11"

\end_inset

Deitel.
 
\shape italic
C++ How To Program
\shape default
.
 5
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 Edition, Prentice Hall, 2005.
 
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-12"

\end_inset

Stanley Lipmann, 
\shape italic
C++ Primer
\shape default
.
 4
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 Edition, Addison-Wesley, 2005.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

Julijan Šribar i Boris Motik.
 
\shape italic
Demistificirani C++
\shape default
.
 Element, 2010.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset

Bjarne Stroustrup.
 
\shape italic
The C++ programming language (Special Edition)
\shape default
.
 Addison-Wesley, 2000.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

Dragan Milićev.
 
\shape italic
Objektno orijentisano programiranje na jeziku C++
\shape default
.
 Mikroknjiga, 1995.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-4"

\end_inset

Ranko Popović i Zona Kostić.
 
\shape italic
Programski jezik C++ sa rešenim zadacima
\shape default
.
 Univerzitet Singidunum, 2010.
\end_layout

\begin_layout Bibliography
\labelwidthstring Bibliografija
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"

\end_inset

Jeffrey Richter.

\shape italic
 Programming Applications for Windows.

\shape default
 Microsoft Press, 1999.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
